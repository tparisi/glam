// three.js - http://github.com/mrdoob/three.js
'use strict';var THREE={REVISION:"66dev"};self.console=self.console||{info:function(){},log:function(){},debug:function(){},warn:function(){},error:function(){}};THREE.extend=function(a,b){if(Object.keys)for(var c=Object.keys(b),d=0,e=c.length;d<e;d++){var f=c[d];Object.defineProperty(a,f,Object.getOwnPropertyDescriptor(b,f))}else for(f in c={}.hasOwnProperty,b)c.call(b,f)&&(a[f]=b[f]);return a};
(function(){for(var a=0,b=["ms","moz","webkit","o"],c=0;c<b.length&&!self.requestAnimationFrame;++c)self.requestAnimationFrame=self[b[c]+"RequestAnimationFrame"],self.cancelAnimationFrame=self[b[c]+"CancelAnimationFrame"]||self[b[c]+"CancelRequestAnimationFrame"];void 0===self.requestAnimationFrame&&void 0!==self.setTimeout&&(self.requestAnimationFrame=function(b){var c=Date.now(),f=Math.max(0,16-(c-a)),g=self.setTimeout(function(){b(c+f)},f);a=c+f;return g});void 0===self.cancelAnimationFrame&&void 0!==
self.clearTimeout&&(self.cancelAnimationFrame=function(a){self.clearTimeout(a)})})();THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;
THREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;
THREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;
THREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;
THREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){return 3===arguments.length?this.setRGB(arguments[0],arguments[1],arguments[2]):this.set(a)};
THREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*
c:0.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a};b=0.5>=c?c*(1+b):c+b-c*b;c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))return a=/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))return a=/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a),this.r=
Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\#([0-9a-f]{6})$/i.test(a))return a=/^\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=
a.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<
8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){a=a||{h:0,s:0,l:0};var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f,f=0.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(a,
b,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;
this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};
THREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,
darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,
grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,
lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,
palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,
tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};
THREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,_euler:void 0,_updateEuler:function(a){void 0!==this._euler&&this._euler.setFromQuaternion(this,void 0,!1)},get x(){return this._x},set x(a){this._x=a;this._updateEuler()},get y(){return this._y},set y(a){this._y=a;this._updateEuler()},get z(){return this._z},set z(a){this._z=a;this._updateEuler()},get w(){return this._w},set w(a){this._w=a;this._updateEuler()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=
d;this._updateEuler();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._w=a._w;this._updateEuler();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2);"XYZ"===a.order?(this._x=f*d*e+c*g*h,this._y=c*
g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"YXZ"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):"ZXY"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"ZYX"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):"YZX"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):"XZY"===a.order&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,
this._z=c*d*h+f*g*e,this._w=c*d*e+f*g*h);!1!==b&&this._updateEuler();return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this._updateEuler();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6],b=b[10],l=c+f+b;0<l?(c=0.5/Math.sqrt(l+1),this._w=0.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=
0.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=0.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=0.25*c);this._updateEuler();return this},inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this._updateEuler();return this},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*
this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);return this},multiply:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=
a._w,g=b._x,h=b._y,k=b._z,l=b._w;this._x=c*l+f*g+d*k-e*h;this._y=d*l+f*h+e*g-c*k;this._z=e*l+f*k+c*h-d*g;this._w=f*l-c*g-d*h-e*k;this._updateEuler();return this},multiplyVector3:function(a){console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=
-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.acos(g),k=Math.sqrt(1-g*g);if(0.001>Math.abs(k))return this._w=0.5*(f+this._w),this._x=0.5*(c+this._x),this._y=0.5*(d+this._y),this._z=0.5*(e+this._z),this;g=Math.sin((1-b)*h)/k;h=Math.sin(b*h)/k;this._w=f*g+this._w*h;this._x=c*g+this._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this._updateEuler();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},
fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this._updateEuler();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},clone:function(){return new THREE.Quaternion(this._x,this._y,this._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};
THREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,
b){if(void 0!==b)return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=
a.y;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);
return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x;a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/
b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};
THREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+
a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*
b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+
a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,l=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-l*-f;this.y=k*a+b*-f+l*-e-h*-g;this.z=l*a+b*-g+h*-f-k*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;
this.z=a[2]*b+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=
b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},
setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=
a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this},angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(a,b){console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")},
setEulerFromQuaternion:function(a,b){console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")},getPositionFromMatrix:function(a){console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.");
return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.");return this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length();
a=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};
THREE.extend(THREE.Vector3.prototype,{applyEuler:function(){var a=new THREE.Quaternion;return function(b){!1===b instanceof THREE.Euler&&console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a=new THREE.Quaternion;return function(b,c){this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),projectOnVector:function(){var a=new THREE.Vector3;
return function(b){a.copy(b).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new THREE.Vector3;return function(b){return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}()});THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},
addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},
applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,
this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d;a=a.elements;var e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],k=a[9];c=a[2];b=a[6];var l=a[10];if(0.01>Math.abs(d-g)&&0.01>Math.abs(f-c)&&0.01>Math.abs(k-b)){if(0.1>Math.abs(d+g)&&0.1>Math.abs(f+c)&&0.1>Math.abs(k+b)&&0.1>Math.abs(e+h+l-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;l=(l+1)/2;d=(d+g)/4;f=(f+c)/4;k=(k+b)/4;e>h&&e>l?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>l?0.01>
h?(b=0.707106781,c=0,d=0.707106781):(c=Math.sqrt(h),b=d/c,d=k/c):0.01>l?(c=b=0.707106781,d=0):(d=Math.sqrt(l),b=f/d,c=k/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-k)*(b-k)+(f-c)*(f-c)+(g-d)*(g-d));0.001>Math.abs(a)&&(a=1);this.x=(b-k)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+l-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=
a.y);this.z<a.z&&(this.z=a.z);this.w<a.w&&(this.w=a.w);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*
this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&
a.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,this.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");THREE.Euler.DefaultOrder="XYZ";
THREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,_quaternion:void 0,_updateQuaternion:function(){void 0!==this._quaternion&&this._quaternion.setFromEuler(this,!1)},get x(){return this._x},set x(a){this._x=a;this._updateQuaternion()},get y(){return this._y},set y(a){this._y=a;this._updateQuaternion()},get z(){return this._z},set z(a){this._z=a;this._updateQuaternion()},get order(){return this._order},set order(a){this._order=a;this._updateQuaternion()},
set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this._updateQuaternion();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this._updateQuaternion();return this},setFromRotationMatrix:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],k=d[5],l=d[9],n=d[2],q=d[6],d=d[10];b=b||this._order;"XYZ"===b?(this._y=Math.asin(c(g)),0.99999>Math.abs(g)?(this._x=Math.atan2(-l,d),this._z=
Math.atan2(-f,e)):(this._x=Math.atan2(q,k),this._z=0)):"YXZ"===b?(this._x=Math.asin(-c(l)),0.99999>Math.abs(l)?(this._y=Math.atan2(g,d),this._z=Math.atan2(h,k)):(this._y=Math.atan2(-n,e),this._z=0)):"ZXY"===b?(this._x=Math.asin(c(q)),0.99999>Math.abs(q)?(this._y=Math.atan2(-n,d),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,e))):"ZYX"===b?(this._y=Math.asin(-c(n)),0.99999>Math.abs(n)?(this._x=Math.atan2(q,d),this._z=Math.atan2(h,e)):(this._x=0,this._z=Math.atan2(-f,k))):"YZX"===b?(this._z=
Math.asin(c(h)),0.99999>Math.abs(h)?(this._x=Math.atan2(-l,k),this._y=Math.atan2(-n,e)):(this._x=0,this._y=Math.atan2(g,d))):"XZY"===b?(this._z=Math.asin(-c(f)),0.99999>Math.abs(f)?(this._x=Math.atan2(q,k),this._y=Math.atan2(g,e)):(this._x=Math.atan2(-l,d),this._y=0)):console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: "+b);this._order=b;this._updateQuaternion();return this},setFromQuaternion:function(a,b,c){function d(a){return Math.min(Math.max(a,-1),1)}var e=a.x*a.x,f=
a.y*a.y,g=a.z*a.z,h=a.w*a.w;b=b||this._order;"XYZ"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),h-e-f+g),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w))),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h+e-f-g)):"YXZ"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z))),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h-e-f+g),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h-e+f-g)):"ZXY"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z))),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),h-e-f+g),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h-e+f-g)):"ZYX"===
b?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),h-e-f+g),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z))),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h+e-f-g)):"YZX"===b?(this._x=Math.atan2(2*(a.x*a.w-a.z*a.y),h-e+f-g),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),h+e-f-g),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w)))):"XZY"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),h-e+f-g),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h+e-f-g),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y)))):console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: "+
b);this._order=b;!1!==c&&this._updateQuaternion();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);this.setFromQuaternion(a,b)}}(),fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this._updateQuaternion();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},clone:function(){return new THREE.Euler(this._x,
this._y,this._z,this._order)}};THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};
THREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,
b){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);
this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};
THREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var c=1,d=a.length;c<d;c++)b=a[c],b.x<this.min.x?this.min.x=b.x:b.x>this.max.x&&(this.max.x=b.x),b.y<this.min.y?this.min.y=b.y:b.y>this.max.y&&(this.max.y=b.y)}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);
this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);
this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),
(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);
return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};
THREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},addPoint:function(a){a.x<this.min.x?this.min.x=a.x:a.x>this.max.x&&(this.max.x=a.x);a.y<this.min.y?this.min.y=a.y:a.y>this.max.y&&(this.max.y=a.y);a.z<this.min.z?this.min.z=a.z:a.z>this.max.z&&(this.max.z=a.z)},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var b=1,c=a.length;b<c;b++)this.addPoint(a[b])}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=
new THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);this.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,g=e.length;f<g;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);
this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);
this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-
this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=
new THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=0.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,
this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);
this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};THREE.Matrix3=function(a,b,c,d,e,f,g,h,k){this.elements=new Float32Array(9);this.set(void 0!==a?a:1,b||0,c||0,d||0,void 0!==e?e:1,f||0,g||0,h||0,void 0!==k?k:1)};
THREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,k){var l=this.elements;l[0]=a;l[3]=b;l[6]=c;l[1]=d;l[4]=e;l[7]=f;l[2]=g;l[5]=h;l[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},
multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,
b){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];c=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");this.identity();return this}this.multiplyScalar(1/
c);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],
a[6],a[7],a[8]]},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,k,l,n,q,s,u,t,p){var v=this.elements=new Float32Array(16);v[0]=void 0!==a?a:1;v[4]=b||0;v[8]=c||0;v[12]=d||0;v[1]=e||0;v[5]=void 0!==f?f:1;v[9]=g||0;v[13]=h||0;v[2]=k||0;v[6]=l||0;v[10]=void 0!==n?n:1;v[14]=q||0;v[3]=s||0;v[7]=u||0;v[11]=t||0;v[15]=void 0!==p?p:1};
THREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,k,l,n,q,s,u,t,p){var v=this.elements;v[0]=a;v[4]=b;v[8]=c;v[12]=d;v[1]=e;v[5]=f;v[9]=g;v[13]=h;v[2]=k;v[6]=l;v[10]=n;v[14]=q;v[3]=s;v[7]=u;v[11]=t;v[15]=p;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
return this.copyPosition(a)},copyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements;b=b.elements;var d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===
a instanceof THREE.Euler&&console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if("XYZ"===a.order){a=f*h;var k=f*e,l=c*h,n=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+l*d;b[5]=a-n*d;b[9]=-c*g;b[2]=n-a*d;b[6]=l+k*d;b[10]=f*g}else"YXZ"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a+n*c,b[4]=l*c-k,b[8]=
f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-l,b[6]=n+a*c,b[10]=f*g):"ZXY"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a-n*c,b[4]=-f*e,b[8]=l+k*c,b[1]=k+l*c,b[5]=f*h,b[9]=n-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):"ZYX"===a.order?(a=f*h,k=f*e,l=c*h,n=c*e,b[0]=g*h,b[4]=l*d-k,b[8]=a*d+n,b[1]=g*e,b[5]=n*d+a,b[9]=k*d-l,b[2]=-d,b[6]=c*g,b[10]=f*g):"YZX"===a.order?(a=f*g,k=f*d,l=c*g,n=c*d,b[0]=g*h,b[4]=n-a*e,b[8]=l*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+l,b[10]=a-n*e):"XZY"===a.order&&(a=f*g,k=f*d,l=c*g,n=c*d,b[0]=
g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+n,b[5]=f*h,b[9]=k*e-l,b[2]=l*e-k,b[6]=c*h,b[10]=n*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,k=e+e;a=c*g;var l=c*
h,c=c*k,n=d*h,d=d*k,e=e*k,g=f*g,h=f*h,f=f*k;b[0]=1-(n+e);b[4]=l-f;b[8]=c+h;b[1]=l+f;b[5]=1-(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+n);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var g=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=
a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],k=c[12],l=c[1],n=c[5],q=c[9],s=c[13],u=c[2],t=c[6],p=c[10],v=c[14],w=c[3],r=c[7],y=c[11],
c=c[15],E=d[0],z=d[4],P=d[8],J=d[12],A=d[1],C=d[5],M=d[9],H=d[13],K=d[2],x=d[6],N=d[10],F=d[14],B=d[3],D=d[7],G=d[11],d=d[15];e[0]=f*E+g*A+h*K+k*B;e[4]=f*z+g*C+h*x+k*D;e[8]=f*P+g*M+h*N+k*G;e[12]=f*J+g*H+h*F+k*d;e[1]=l*E+n*A+q*K+s*B;e[5]=l*z+n*C+q*x+s*D;e[9]=l*P+n*M+q*N+s*G;e[13]=l*J+n*H+q*F+s*d;e[2]=u*E+t*A+p*K+v*B;e[6]=u*z+t*C+p*x+v*D;e[10]=u*P+t*M+p*N+v*G;e[14]=u*J+t*H+p*F+v*d;e[3]=w*E+r*A+y*K+c*B;e[7]=w*z+r*C+y*x+c*D;e[11]=w*P+r*M+y*N+c*G;e[15]=w*J+r*H+y*F+c*d;return this},multiplyToArray:function(a,
b,c){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
return a.applyProjection(this)},multiplyVector4:function(a){console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyProjection(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
a.transformDirection(this)},crossVector:function(a){console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],l=a[2],n=a[6],q=a[10],s=a[14];return a[3]*(+e*h*n-d*k*n-e*g*q+c*k*q+d*g*s-c*h*s)+a[7]*(+b*h*s-b*k*q+e*f*q-d*f*s+d*k*l-e*h*l)+a[11]*(+b*k*n-b*g*s-e*f*n+c*f*s+e*g*l-c*k*l)+a[15]*(-d*g*l-b*h*n+b*g*q+d*f*n-c*f*
q+c*h*l)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},flattenToArrayOffset:function(a,b){var c=this.elements;
a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=this.elements;
b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],k=d[1],l=d[5],n=d[9],q=d[13],s=d[2],u=d[6],t=d[10],p=d[14],v=d[3],w=d[7],r=d[11],d=d[15];c[0]=n*p*w-q*t*w+q*u*r-l*p*r-n*u*d+l*t*d;c[4]=h*t*w-g*p*w-h*u*r+f*p*r+g*u*d-f*t*d;c[8]=g*q*w-h*n*w+h*l*r-f*q*r-g*l*d+f*n*d;c[12]=h*n*u-g*q*u-h*l*t+f*q*t+g*l*p-f*n*p;c[1]=q*t*v-n*p*v-q*s*r+k*p*r+n*s*d-k*t*d;c[5]=g*p*v-h*t*v+h*s*r-e*p*r-g*s*d+e*t*d;c[9]=h*n*v-g*q*v-h*k*r+e*q*r+g*k*d-
e*n*d;c[13]=g*q*s-h*n*s+h*k*t-e*q*t-g*k*p+e*n*p;c[2]=l*p*v-q*u*v+q*s*w-k*p*w-l*s*d+k*u*d;c[6]=h*u*v-f*p*v-h*s*w+e*p*w+f*s*d-e*u*d;c[10]=f*q*v-h*l*v+h*k*w-e*q*w-f*k*d+e*l*d;c[14]=h*l*s-f*q*s-h*k*u+e*q*u+f*k*p-e*l*p;c[3]=n*u*v-l*t*v-n*s*w+k*t*w+l*s*r-k*u*r;c[7]=f*t*v-g*u*v+g*s*w-e*t*w-f*s*r+e*u*r;c[11]=g*l*v-f*n*v-g*k*w+e*n*w+f*k*r-e*l*r;c[15]=f*n*s-g*l*s+g*k*u-e*n*u-f*k*t+e*l*t;c=e*c[0]+k*c[4]+s*c[8]+v*c[12];if(0==c){if(b)throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
this.identity();return this}this.multiplyScalar(1/c);return this},translate:function(a){console.warn("DEPRECATED: Matrix4's .translate() has been removed.")},rotateX:function(a){console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")},rotateY:function(a){console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")},rotateZ:function(a){console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")},rotateByAxis:function(a,b){console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")},
scale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(1,
0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,k=e*f,l=e*g;this.set(k*f+c,k*g-d*h,k*h+d*g,0,k*g+d*h,l*g+c,l*h-d*f,0,k*h-d*g,l*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,
0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);c=1/g;var f=1/h,l=1/k;b.elements[0]*=c;b.elements[1]*=
c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=l;b.elements[9]*=l;b.elements[10]*=l;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){a=c*Math.tan(THREE.Math.degToRad(0.5*a));
var e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,k=c-d,l=f-e;g[0]=2/h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/k;g[9]=0;g[13]=-((c+d)/k);g[2]=0;g[6]=0;g[10]=-2/l;g[14]=-((f+e)/l);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=
this.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};
THREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);
var d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(0.5),f=b.clone().sub(a).normalize(),g=0.5*a.distanceTo(b),
h=this.origin.clone().sub(e);a=-this.direction.dot(f);b=h.dot(this.direction);var k=-h.dot(f),l=h.lengthSq(),n=Math.abs(1-a*a),q,s;0<=n?(h=a*k-b,q=a*b-k,s=g*n,0<=h?q>=-s?q<=s?(g=1/n,h*=g,q*=g,a=h*(h+a*q+2*b)+q*(a*h+q+2*k)+l):(q=g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l):(q=-g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l):q<=-s?(h=Math.max(0,-(-a*g+b)),q=0<h?-g:Math.min(Math.max(-g,-k),g),a=-h*h+q*(q+2*k)+l):q<=s?(h=0,q=Math.min(Math.max(-g,-k),g),a=q*(q+2*k)+l):(h=Math.max(0,-(a*g+b)),q=0<h?g:Math.min(Math.max(-g,
-k),g),a=-h*h+q*(q+2*k)+l)):(q=0<a?-g:g,h=Math.max(0,-(a*q+b)),a=-h*h+q*(q+2*k)+l);c&&c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));d&&d.copy(f.clone().multiplyScalar(q).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?
0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;return function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=
a.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==c)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<
f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},
clone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};
THREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=
this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);
return a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};
THREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],l=c[7],n=c[8],q=c[9],s=c[10],u=c[11],t=c[12],p=c[13],v=c[14],c=c[15];b[0].setComponents(f-a,l-g,u-n,c-t).normalize();b[1].setComponents(f+
a,l+g,u+n,c+t).normalize();b[2].setComponents(f+d,l+h,u+q,c+p).normalize();b[3].setComponents(f-d,l-h,u-q,c-p).normalize();b[4].setComponents(f-e,l-k,u-s,c-v).normalize();b[5].setComponents(f+e,l+k,u+s,c+v).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,
c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),
containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};
THREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,
c);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,
b){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),
coplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(d,e){var f=e||c.getNormalMatrix(d),f=a.copy(this.normal).applyMatrix3(f),g=this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f,g);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&
a.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};THREE.Math={PI2:2*Math.PI,generateUUID:function(){var a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]="-":14==e?b[e]="4":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join("")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,
b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/
180;return function(b){return b*a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}(),isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a}};THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,k,l,n,q,s;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:
f+2;l=this.points[c[0]];n=this.points[c[1]];q=this.points[c[2]];s=this.points[c[3]];h=g*g;k=g*h;d.x=b(l.x,n.x,q.x,s.x,g,h,k);d.y=b(l.y,n.y,q.y,s.y,g,h,k);d.z=b(l.z,n.z,q.z,s.z,g,h,k);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],k=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=
a/c,d=this.getPoint(b),g.copy(d),k+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=k,e=b);h[h.length]=k;return{chunks:h,total:k}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],k=new THREE.Vector3,l=this.getLength();h.push(k.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=l.chunks[b]-l.chunks[b-1];g=Math.ceil(a*c/l.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+1/g*c*(f-e),d=this.getPoint(d),h.push(k.copy(d).clone());
h.push(k.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();
THREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var l=d*k-e*e;h=h||new THREE.Vector3;if(0==l)return h.set(-2,-1,-1);l=1/l;k=(k*f-e*g)*l;d=(d*g-e*f)*l;return h.set(1-k-d,d,k)}}();
THREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();
THREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return 0.5*a.cross(b).length()}}(),midpoint:function(a){return(a||
new THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},
clone:function(){return(new THREE.Triangle).copy(this)}};THREE.Vertex=function(a){console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");return a};THREE.UV=function(a,b){console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");return new THREE.Vector2(a,b)};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};
THREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),
a=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};
THREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&
c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(){var a=[];return function(b){if(void 0!==this._listeners){var c=this._listeners[b.type];if(void 0!==c){b.target=this;for(var d=c.length,e=0;e<d;e++)a[e]=c[e];for(e=0;e<d;e++)a[e].call(this,
b)}}}}()};(function(a){a.Raycaster=function(b,c,d,e){this.ray=new a.Ray(b,c);this.near=d||0;this.far=e||Infinity};var b=new a.Sphere,c=new a.Ray;new a.Plane;new a.Vector3;var d=new a.Vector3,e=new a.Matrix4,f=function(a,b){return a.distance-b.distance},g=new a.Vector3,h=new a.Vector3,k=new a.Vector3,l=function(f,n,u){if(f instanceof a.Sprite){d.setFromMatrixPosition(f.matrixWorld);var t=n.ray.distanceToPoint(d);if(t>f.scale.x)return u;u.push({distance:t,point:f.position,face:null,object:f})}else if(f instanceof
a.LOD)d.setFromMatrixPosition(f.matrixWorld),t=n.ray.origin.distanceTo(d),l(f.getObjectForDistance(t),n,u);else if(f instanceof a.Mesh){var p=f.geometry;null===p.boundingSphere&&p.computeBoundingSphere();b.copy(p.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===n.ray.isIntersectionSphere(b))return u;e.getInverse(f.matrixWorld);c.copy(n.ray).applyMatrix4(e);if(null!==p.boundingBox&&!1===c.isIntersectionBox(p.boundingBox))return u;if(p instanceof a.BufferGeometry){var v=f.material;if(void 0===
v||!1===p.dynamic)return u;var w,r,y=n.precision;if(void 0!==p.attributes.index)for(var E=p.offsets,z=p.attributes.index.array,P=p.attributes.position.array,J=p.offsets.length,A=p.attributes.index.array.length/3,A=0;A<J;++A)for(var t=E[A].start,C=E[A].index,p=t,M=t+E[A].count;p<M;p+=3)t=C+z[p],w=C+z[p+1],r=C+z[p+2],g.set(P[3*t],P[3*t+1],P[3*t+2]),h.set(P[3*w],P[3*w+1],P[3*w+2]),k.set(P[3*r],P[3*r+1],P[3*r+2]),w=v.side===a.BackSide?c.intersectTriangle(k,h,g,!0):c.intersectTriangle(g,h,k,v.side!==a.DoubleSide),
null!==w&&(w.applyMatrix4(f.matrixWorld),t=n.ray.origin.distanceTo(w),t<y||t<n.near||t>n.far||u.push({distance:t,point:w,face:null,faceIndex:null,object:f}));else for(P=p.attributes.position.array,A=p.attributes.position.array.length,p=0;p<A;p+=3)t=p,w=p+1,r=p+2,g.set(P[3*t],P[3*t+1],P[3*t+2]),h.set(P[3*w],P[3*w+1],P[3*w+2]),k.set(P[3*r],P[3*r+1],P[3*r+2]),w=v.side===a.BackSide?c.intersectTriangle(k,h,g,!0):c.intersectTriangle(g,h,k,v.side!==a.DoubleSide),null!==w&&(w.applyMatrix4(f.matrixWorld),
t=n.ray.origin.distanceTo(w),t<y||t<n.near||t>n.far||u.push({distance:t,point:w,face:null,faceIndex:null,object:f}))}else if(p instanceof a.Geometry)for(z=f.material instanceof a.MeshFaceMaterial,P=!0===z?f.material.materials:null,y=n.precision,E=p.vertices,J=0,A=p.faces.length;J<A;J++)if(C=p.faces[J],v=!0===z?P[C.materialIndex]:f.material,void 0!==v){t=E[C.a];w=E[C.b];r=E[C.c];if(!0===v.morphTargets){var M=p.morphTargets,H=f.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);k.set(0,0,0);for(var K=
0,x=M.length;K<x;K++){var N=H[K];if(0!==N){var F=M[K].vertices;g.x+=(F[C.a].x-t.x)*N;g.y+=(F[C.a].y-t.y)*N;g.z+=(F[C.a].z-t.z)*N;h.x+=(F[C.b].x-w.x)*N;h.y+=(F[C.b].y-w.y)*N;h.z+=(F[C.b].z-w.z)*N;k.x+=(F[C.c].x-r.x)*N;k.y+=(F[C.c].y-r.y)*N;k.z+=(F[C.c].z-r.z)*N}}g.add(t);h.add(w);k.add(r);t=g;w=h;r=k}w=v.side===a.BackSide?c.intersectTriangle(r,w,t,!0):c.intersectTriangle(t,w,r,v.side!==a.DoubleSide);null!==w&&(w.applyMatrix4(f.matrixWorld),t=n.ray.origin.distanceTo(w),t<y||t<n.near||t>n.far||u.push({distance:t,
point:w,face:C,faceIndex:J,object:f}))}}else if(f instanceof a.Line){y=n.linePrecision;v=y*y;p=f.geometry;null===p.boundingSphere&&p.computeBoundingSphere();b.copy(p.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===n.ray.isIntersectionSphere(b))return u;e.getInverse(f.matrixWorld);c.copy(n.ray).applyMatrix4(e);if(p instanceof a.Geometry)for(E=p.vertices,y=E.length,w=new a.Vector3,r=new a.Vector3,A=f.type===a.LineStrip?1:2,p=0;p<y-1;p+=A)c.distanceSqToSegment(E[p],E[p+1],r,w)>v||(t=c.origin.distanceTo(r),
t<n.near||t>n.far||u.push({distance:t,point:w.clone().applyMatrix4(f.matrixWorld),face:null,faceIndex:null,object:f}))}},n=function(a,b,c){a=a.getDescendants();for(var d=0,e=a.length;d<e;d++)l(a[d],b,c)};a.Raycaster.prototype.precision=1E-4;a.Raycaster.prototype.linePrecision=1;a.Raycaster.prototype.set=function(a,b){this.ray.set(a,b)};a.Raycaster.prototype.intersectObject=function(a,b){var c=[];!0===b&&n(a,this,c);l(a,this,c);c.sort(f);return c};a.Raycaster.prototype.intersectObjects=function(a,
b){for(var c=[],d=0,e=a.length;d<e;d++)l(a[d],this,c),!0===b&&n(a[d],this,c);c.sort(f);return c}})(THREE);THREE.Object3D=function(){this.id=THREE.Object3DIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.parent=void 0;this.children=[];this.up=new THREE.Vector3(0,1,0);this.position=new THREE.Vector3;this._rotation=new THREE.Euler;this._quaternion=new THREE.Quaternion;this.scale=new THREE.Vector3(1,1,1);this._rotation._quaternion=this.quaternion;this._quaternion._euler=this.rotation;this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;
this.visible=this.matrixWorldNeedsUpdate=this.matrixAutoUpdate=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.userData={}};
THREE.Object3D.prototype={constructor:THREE.Object3D,get rotation(){return this._rotation},set rotation(a){this._rotation=a;this._rotation._quaternion=this._quaternion;this._quaternion._euler=this._rotation;this._rotation._updateQuaternion()},get quaternion(){return this._quaternion},set quaternion(a){this._quaternion=a;this._quaternion._euler=this._rotation;this._rotation._quaternion=this._quaternion;this._quaternion._updateEuler()},get eulerOrder(){console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
return this.rotation.order},set eulerOrder(a){console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");this.rotation.order=a},get useQuaternion(){console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")},set useQuaternion(a){console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);
this.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=
new THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b);a.applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translate:function(a,b){console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");
return this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),
lookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(a===this)console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");else if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:"added"});this.children.push(a);for(var b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}},remove:function(a){var b=
this.children.indexOf(a);if(-1!==b){a.parent=void 0;a.dispatchEvent({type:"removed"});this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},getObjectById:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,
b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==e))return e}},getChildByName:function(a,b){console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(a,b)},getDescendants:function(a){void 0===a&&(a=[]);Array.prototype.push.apply(a,this.children);for(var b=0,c=this.children.length;b<c;b++)this.children[b].getDescendants(a);return a},updateMatrix:function(){this.matrix.compose(this.position,
this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a,b){void 0===a&&(a=new THREE.Object3D);void 0===b&&(b=!0);
a.name=this.name;a.up.copy(this.up);a.position.copy(this.position);a.quaternion.copy(this.quaternion);a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;a.userData=JSON.parse(JSON.stringify(this.userData));
if(!0===b)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;THREE.Projector=function(){function a(){if(n===s){var a=new THREE.RenderableVertex;q.push(a);s++;n++;return a}return q[n++]}function b(){if(t===v){var a=new THREE.RenderableFace3;p.push(a);v++;t++;return a}return p[t++]}function c(){if(r===E){var a=new THREE.RenderableLine;y.push(a);E++;r++;return a}return y[r++]}function d(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function e(a,b){var c=0,d=1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&
0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var f,g,h=[],k=0,l,n,q=[],s=0,u,t,p=[],v=0,w,r,y=[],E=0,z,P,J=[],A=0,C={objects:[],sprites:[],lights:[],elements:[]},M=new THREE.Vector3,H=new THREE.Vector3,K=new THREE.Vector3,x=new THREE.Vector3,N=new THREE.Vector4,F=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),B=new THREE.Box3,D=Array(3),G=new THREE.Matrix4,
Y=new THREE.Matrix4,S,la=new THREE.Matrix4,U=new THREE.Matrix3,oa=new THREE.Vector3,Q=new THREE.Frustum,fa=new THREE.Vector4,V=new THREE.Vector4;this.projectVector=function(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);Y.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(Y)};this.unprojectVector=function(){var a=new THREE.Matrix4;return function(b,c){a.getInverse(c.projectionMatrix);Y.multiplyMatrices(c.matrixWorld,a);return b.applyProjection(Y)}}();this.pickingRay=
function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var I=function(a){if(g===k){var b=new THREE.RenderableObject;h.push(b);k++;g++;f=b}else f=h[g++];f.id=a.id;f.object=a;null!==a.renderDepth?f.z=a.renderDepth:(x.setFromMatrixPosition(a.matrixWorld),x.applyProjection(Y),f.z=x.z);return f},R=function(a){if(!1!==a.visible){a instanceof THREE.Light?C.lights.push(a):a instanceof THREE.Mesh||a instanceof
THREE.Line?!1!==a.frustumCulled&&!0!==Q.intersectsObject(a)||C.objects.push(I(a)):a instanceof THREE.Sprite&&C.sprites.push(I(a));for(var b=0,c=a.children.length;b<c;b++)R(a.children[b])}},Z=new function(){var d=[],e=null,f=new THREE.Matrix3,g=function(a){var b=a.positionWorld,c=a.positionScreen;b.copy(a.position).applyMatrix4(S);c.copy(b).applyMatrix4(Y);b=1/c.w;c.x*=b;c.y*=b;c.z*=b;a.visible=-1<=c.x&&1>=c.x&&-1<=c.y&&1>=c.y&&-1<=c.z&&1>=c.z},h=function(a,b,c){D[0]=a.positionScreen;D[1]=b.positionScreen;
D[2]=c.positionScreen;return!0===a.visible||!0===b.visible||!0===c.visible||F.isIntersectionBox(B.setFromPoints(D))?0>(c.positionScreen.x-a.positionScreen.x)*(b.positionScreen.y-a.positionScreen.y)-(c.positionScreen.y-a.positionScreen.y)*(b.positionScreen.x-a.positionScreen.x):!1};return{setObject:function(a){e=a;f.getNormalMatrix(e.matrixWorld);d.length=0},projectVertex:g,checkTriangleVisibility:h,pushVertex:function(b,c,d){l=a();l.position.set(b,c,d);g(l)},pushNormal:function(a,b,c){d.push(a,b,
c)},pushLine:function(a,b){var d=q[a],f=q[b];w=c();w.id=e.id;w.v1.copy(d);w.v2.copy(f);u.z=(d.positionScreen.z+f.positionScreen.z)/2;w.material=e.material;C.elements.push(w)},pushTriangle:function(a,c,g){var k=q[a],l=q[c],n=q[g];if(!0===h(k,l,n)){u=b();u.id=e.id;u.v1.copy(k);u.v2.copy(l);u.v3.copy(n);u.z=(k.positionScreen.z+l.positionScreen.z+n.positionScreen.z)/3;for(k=0;3>k;k++)l=3*arguments[k],n=u.vertexNormalsModel[k],n.set(d[l+0],d[l+1],d[l+2]),n.applyMatrix3(f).normalize();u.vertexNormalsLength=
3;u.material=e.material;C.elements.push(u)}}}};this.projectScene=function(f,h,k,l){var p,s,v,y,x,I,E,F,D;P=r=t=0;C.elements.length=0;!0===f.autoUpdate&&f.updateMatrixWorld();void 0===h.parent&&h.updateMatrixWorld();G.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));Y.multiplyMatrices(h.projectionMatrix,G);Q.setFromMatrix(Y);g=0;C.objects.length=0;C.sprites.length=0;C.lights.length=0;R(f);!0===k&&C.objects.sort(d);f=0;for(k=C.objects.length;f<k;f++)if(p=C.objects[f].object,s=p.geometry,Z.setObject(p),
S=p.matrixWorld,n=0,p instanceof THREE.Mesh)if(s instanceof THREE.BufferGeometry){if(y=s.attributes,void 0!==y.position){I=y.position.array;p=0;for(s=I.length;p<s;p+=3)Z.pushVertex(I[p],I[p+1],I[p+2]);F=y.normal.array;p=0;for(s=F.length;p<s;p+=3)Z.pushNormal(F[p],F[p+1],F[p+2]);if(void 0!==y.index)for(y=y.index.array,p=0,s=y.length;p<s;p+=3)Z.pushTriangle(y[p],y[p+1],y[p+2]);else for(p=0,s=I.length/3;p<s;p+=3)Z.pushTriangle(p,p+1,p+2)}}else if(s instanceof THREE.Geometry2)for(v=s.vertices,y=p=0,s=
v.length;p<s;p+=9,y+=3)Z.pushVertex(v[p+0],v[p+1],v[p+2]),Z.pushVertex(v[p+3],v[p+4],v[p+5]),Z.pushVertex(v[p+6],v[p+7],v[p+8]),Z.pushTriangle(y+0,y+1,y+2);else{if(s instanceof THREE.Geometry){v=s.vertices;y=s.faces;I=s.faceVertexUvs;U.getNormalMatrix(S);F=p.material instanceof THREE.MeshFaceMaterial;D=!0===F?p.material:null;for(var B=0,Ja=v.length;B<Ja;B++){var Ea=v[B];Z.pushVertex(Ea.x,Ea.y,Ea.z)}B=0;for(Ja=y.length;B<Ja;B++)if(v=y[B],Ea=!0===F?D.materials[v.materialIndex]:p.material,void 0!==Ea){E=
Ea.side;x=q[v.a];var ma=q[v.b],pa=q[v.c];if(!0===Ea.morphTargets){var qa=s.morphTargets,Oa=p.morphTargetInfluences,Pa=x.position,Qa=ma.position,Aa=pa.position;M.set(0,0,0);H.set(0,0,0);K.set(0,0,0);for(var Ra=0,Ba=qa.length;Ra<Ba;Ra++){var $=Oa[Ra];if(0!==$){var ja=qa[Ra].vertices;M.x+=(ja[v.a].x-Pa.x)*$;M.y+=(ja[v.a].y-Pa.y)*$;M.z+=(ja[v.a].z-Pa.z)*$;H.x+=(ja[v.b].x-Qa.x)*$;H.y+=(ja[v.b].y-Qa.y)*$;H.z+=(ja[v.b].z-Qa.z)*$;K.x+=(ja[v.c].x-Aa.x)*$;K.y+=(ja[v.c].y-Aa.y)*$;K.z+=(ja[v.c].z-Aa.z)*$}}x.position.add(M);
ma.position.add(H);pa.position.add(K);Z.projectVertex(x);Z.projectVertex(ma);Z.projectVertex(pa)}qa=Z.checkTriangleVisibility(x,ma,pa);if(qa!==(E===THREE.BackSide)){u=b();u.id=p.id;u.v1.copy(x);u.v2.copy(ma);u.v3.copy(pa);u.normalModel.copy(v.normal);!1!==qa||E!==THREE.BackSide&&E!==THREE.DoubleSide||u.normalModel.negate();u.normalModel.applyMatrix3(U).normalize();u.centroidModel.copy(v.centroid).applyMatrix4(S);x=v.vertexNormals;ma=0;for(pa=Math.min(x.length,3);ma<pa;ma++)Oa=u.vertexNormalsModel[ma],
Oa.copy(x[ma]),!1!==qa||E!==THREE.BackSide&&E!==THREE.DoubleSide||Oa.negate(),Oa.applyMatrix3(U).normalize();u.vertexNormalsLength=x.length;x=0;for(ma=Math.min(I.length,3);x<ma;x++)if(E=I[x][B],void 0!==E)for(pa=0,qa=E.length;pa<qa;pa++)u.uvs[x][pa]=E[pa];u.color=v.color;u.material=Ea;oa.copy(u.centroidModel).applyProjection(Y);u.z=oa.z;C.elements.push(u)}}}}else if(p instanceof THREE.Line)if(s instanceof THREE.BufferGeometry){if(y=s.attributes,void 0!==y.position){I=y.position.array;p=0;for(s=I.length;p<
s;p+=3)Z.pushVertex(I[p],I[p+1],I[p+2]);if(void 0!==y.index)for(y=y.index.array,p=0,s=y.length;p<s;p+=2)Z.pushLine(y[p],y[p+1]);else for(p=0,s=I.length/3-1;p<s;p++)Z.pushLine(p,p+1)}}else if(s instanceof THREE.Geometry)for(la.multiplyMatrices(Y,S),v=p.geometry.vertices,x=a(),x.positionScreen.copy(v[0]).applyMatrix4(la),s=p.type===THREE.LinePieces?2:1,B=1,Ja=v.length;B<Ja;B++)x=a(),x.positionScreen.copy(v[B]).applyMatrix4(la),0<(B+1)%s||(ma=q[n-2],fa.copy(x.positionScreen),V.copy(ma.positionScreen),
!0===e(fa,V)&&(fa.multiplyScalar(1/fa.w),V.multiplyScalar(1/V.w),w=c(),w.id=p.id,w.v1.positionScreen.copy(fa),w.v2.positionScreen.copy(V),w.z=Math.max(fa.z,V.z),w.material=p.material,p.material.vertexColors===THREE.VertexColors&&(w.vertexColors[0].copy(p.geometry.colors[B]),w.vertexColors[1].copy(p.geometry.colors[B-1])),C.elements.push(w)));f=0;for(k=C.sprites.length;f<k;f++)p=C.sprites[f].object,S=p.matrixWorld,N.set(S.elements[12],S.elements[13],S.elements[14],1),N.applyMatrix4(Y),s=1/N.w,N.z*=
s,-1<=N.z&&1>=N.z&&(P===A?(y=new THREE.RenderableSprite,J.push(y),A++,P++,z=y):z=J[P++],z.id=p.id,z.x=N.x*s,z.y=N.y*s,z.z=N.z,z.object=p,z.rotation=p.rotation,z.scale.x=p.scale.x*Math.abs(z.x-(N.x+h.projectionMatrix.elements[0])/(N.w+h.projectionMatrix.elements[12])),z.scale.y=p.scale.y*Math.abs(z.y-(N.y+h.projectionMatrix.elements[5])/(N.w+h.projectionMatrix.elements[13])),z.material=p.material,C.elements.push(z));!0===l&&C.elements.sort(d);return C}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0;this.centroid=new THREE.Vector3};
THREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();
return a}};THREE.Face4=function(a,b,c,d,e,f,g){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new THREE.Face3(a,b,c,e,f,g)};THREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=
this.elementsNeedUpdate=this.verticesNeedUpdate=!1};
THREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){var e=this.faces[c];e.normal.applyMatrix3(b).normalize();for(var f=0,g=e.vertexNormals.length;f<g;f++)e.vertexNormals[f].applyMatrix3(b).normalize();e.centroid.applyMatrix4(a)}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof
THREE.Sphere&&this.computeBoundingSphere()},computeCentroids:function(){var a,b,c;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.centroid.set(0,0,0),c.centroid.add(this.vertices[c.a]),c.centroid.add(this.vertices[c.b]),c.centroid.add(this.vertices[c.c]),c.centroid.divideScalar(3)},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,
g);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,k=new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),k.subVectors(e,f),h.cross(k),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else for(a=
0,b=this.faces.length;a<b;a++)c=this.faces[a],d[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal);b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.vertexNormals[0]=d[c.a].clone(),c.vertexNormals[1]=d[c.b].clone(),c.vertexNormals[2]=d[c.c].clone()},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++)for(e=this.faces[c],e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=
e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]),a=0,b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone();var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;var g=
this.morphNormals[a].vertexNormals,h,k;c=0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,k={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(k)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(e.normal),k.a.copy(e.vertexNormals[0]),k.b.copy(e.vertexNormals[1]),k.c.copy(e.vertexNormals[2])}c=0;for(d=this.faces.length;c<
d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,g,h,k,l,n,q,s,u,t,p,v,w=[],r=[];c=new THREE.Vector3;var y=new THREE.Vector3,E=new THREE.Vector3,z=new THREE.Vector3,P=new THREE.Vector3;a=0;for(b=this.vertices.length;a<b;a++)w[a]=new THREE.Vector3,r[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,v=e.b,e=e.c,g=this.vertices[d],h=this.vertices[v],k=this.vertices[e],
l=f[0],n=f[1],q=f[2],f=h.x-g.x,s=k.x-g.x,u=h.y-g.y,t=k.y-g.y,h=h.z-g.z,g=k.z-g.z,k=n.x-l.x,p=q.x-l.x,n=n.y-l.y,l=q.y-l.y,q=1/(k*l-p*n),c.set((l*f-n*s)*q,(l*u-n*t)*q,(l*h-n*g)*q),y.set((k*s-p*f)*q,(k*t-p*u)*q,(k*g-p*h)*q),w[d].add(c),w[v].add(c),w[e].add(c),r[d].add(y),r[v].add(y),r[e].add(y);y=["a","b","c","d"];a=0;for(b=this.faces.length;a<b;a++)for(e=this.faces[a],c=0;c<Math.min(e.vertexNormals.length,3);c++)P.copy(e.vertexNormals[c]),d=e[y[c]],v=w[d],E.copy(v),E.sub(P.multiplyScalar(P.dot(v))).normalize(),
z.crossVectors(e.vertexNormals[c],v),d=z.dot(r[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(E.x,E.y,E.z,d);this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);
this.boundingSphere.setFromPoints(this.vertices)},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+"_"+Math.round(d.y*e)+"_"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++)for(e=this.faces[f],e.a=c[e.a],e.b=c[e.b],e.c=c[e.c],e=[e.a,e.b,e.c],d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(e=
a[f],this.faces.splice(e,1),c=0,g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,1);f=this.vertices.length-b.length;this.vertices=b;return f},clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=b.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],g=0,h=e.length;g<h;g++)f.push(new THREE.Vector2(e[g].x,e[g].y));a.faceVertexUvs[0].push(f)}return a},
dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.Geometry2=function(a){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.vertices=void 0!==a?new Float32Array(3*a):[];this.normals=void 0!==a?new Float32Array(3*a):[];this.uvs=void 0!==a?new Float32Array(2*a):[];this.boundingSphere=this.boundingBox=null};
THREE.Geometry2.prototype={constructor:THREE.Geometry2,applyMatrix:function(a){a.multiplyVector3Array(this.vertices)},computeBoundingSphere:function(){var a=new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);a.makeEmpty();for(var c=this.vertices,d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.addPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));
this.boundingSphere.radius=Math.sqrt(g)}}(),dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry2.prototype);THREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.attributes={};this.dynamic=!0;this.offsets=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1};
THREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c,d){this.attributes[a]={itemSize:d,array:new b(c*d)}},applyMatrix:function(a){var b,c;this.attributes.position&&(b=this.attributes.position.array);this.attributes.normal&&(c=this.attributes.normal.array);void 0!==b&&(a.multiplyVector3Array(b),this.verticesNeedUpdate=!0);void 0!==c&&((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(c),this.normalizeNormals(),this.normalsNeedUpdate=!0)},computeBoundingBox:function(){null===
this.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox,c,d,e;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var f=3,g=a.length;f<g;f+=3)c=a[f],d=a[f+1],e=a[f+2],c<b.min.x?b.min.x=c:c>b.max.x&&(b.max.x=c),d<b.min.y?b.min.y=d:d>b.max.y&&(b.max.y=d),e<b.min.z?b.min.z=e:e>b.max.z&&(b.max.z=e)}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){var a=
new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){a.makeEmpty();for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.addPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(g)}}}(),computeVertexNormals:function(){if(this.attributes.position){var a,
b,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else for(a=0,b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0;var e=this.attributes.position.array,f=this.attributes.normal.array,g,h,k,l,n,q,s=new THREE.Vector3,u=new THREE.Vector3,t=new THREE.Vector3,p=new THREE.Vector3,v=new THREE.Vector3;if(this.attributes.index){var w=this.attributes.index.array,r=this.offsets;c=0;for(d=
r.length;c<d;++c){b=r[c].start;g=r[c].count;var y=r[c].index;a=b;for(b+=g;a<b;a+=3)g=y+w[a],h=y+w[a+1],k=y+w[a+2],l=e[3*g],n=e[3*g+1],q=e[3*g+2],s.set(l,n,q),l=e[3*h],n=e[3*h+1],q=e[3*h+2],u.set(l,n,q),l=e[3*k],n=e[3*k+1],q=e[3*k+2],t.set(l,n,q),p.subVectors(t,u),v.subVectors(s,u),p.cross(v),f[3*g]+=p.x,f[3*g+1]+=p.y,f[3*g+2]+=p.z,f[3*h]+=p.x,f[3*h+1]+=p.y,f[3*h+2]+=p.z,f[3*k]+=p.x,f[3*k+1]+=p.y,f[3*k+2]+=p.z}}else for(a=0,b=e.length;a<b;a+=9)l=e[a],n=e[a+1],q=e[a+2],s.set(l,n,q),l=e[a+3],n=e[a+4],
q=e[a+5],u.set(l,n,q),l=e[a+6],n=e[a+7],q=e[a+8],t.set(l,n,q),p.subVectors(t,u),v.subVectors(s,u),p.cross(v),f[a]=p.x,f[a+1]=p.y,f[a+2]=p.z,f[a+3]=p.x,f[a+4]=p.y,f[a+5]=p.z,f[a+6]=p.x,f[a+7]=p.y,f[a+8]=p.z;this.normalizeNormals();this.normalsNeedUpdate=!0}},normalizeNormals:function(){for(var a=this.attributes.normal.array,b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},computeTangents:function(){function a(a,b,c){q=d[3*a];s=d[3*a+1];
u=d[3*a+2];t=d[3*b];p=d[3*b+1];v=d[3*b+2];w=d[3*c];r=d[3*c+1];y=d[3*c+2];E=f[2*a];z=f[2*a+1];P=f[2*b];J=f[2*b+1];A=f[2*c];C=f[2*c+1];M=t-q;H=w-q;K=p-s;x=r-s;N=v-u;F=y-u;B=P-E;D=A-E;G=J-z;Y=C-z;S=1/(B*Y-D*G);la.set((Y*M-G*H)*S,(Y*K-G*x)*S,(Y*N-G*F)*S);U.set((B*H-D*M)*S,(B*x-D*K)*S,(B*F-D*N)*S);k[a].add(la);k[b].add(la);k[c].add(la);l[a].add(U);l[b].add(U);l[c].add(U)}function b(a){va.x=e[3*a];va.y=e[3*a+1];va.z=e[3*a+2];wa.copy(va);da=k[a];T.copy(da);T.sub(va.multiplyScalar(va.dot(da))).normalize();
Ia.crossVectors(wa,da);za=Ia.dot(l[a]);Ca=0>za?-1:1;h[4*a]=T.x;h[4*a+1]=T.y;h[4*a+2]=T.z;h[4*a+3]=Ca}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");else{var c=this.attributes.index.array,d=this.attributes.position.array,e=this.attributes.normal.array,f=this.attributes.uv.array,g=d.length/3;void 0===this.attributes.tangent&&
(this.attributes.tangent={itemSize:4,array:new Float32Array(4*g)});for(var h=this.attributes.tangent.array,k=[],l=[],n=0;n<g;n++)k[n]=new THREE.Vector3,l[n]=new THREE.Vector3;var q,s,u,t,p,v,w,r,y,E,z,P,J,A,C,M,H,K,x,N,F,B,D,G,Y,S,la=new THREE.Vector3,U=new THREE.Vector3,oa,Q,fa,V,I,R=this.offsets,n=0;for(Q=R.length;n<Q;++n){oa=R[n].start;fa=R[n].count;var Z=R[n].index,g=oa;for(oa+=fa;g<oa;g+=3)fa=Z+c[g],V=Z+c[g+1],I=Z+c[g+2],a(fa,V,I)}var T=new THREE.Vector3,Ia=new THREE.Vector3,va=new THREE.Vector3,
wa=new THREE.Vector3,Ca,da,za,n=0;for(Q=R.length;n<Q;++n)for(oa=R[n].start,fa=R[n].count,Z=R[n].index,g=oa,oa+=fa;g<oa;g+=3)fa=Z+c[g],V=Z+c[g+1],I=Z+c[g+2],b(fa),b(V),b(I);this.tangentsNeedUpdate=this.hasTangents=!0}},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,array:null},d=0,g=b.length;d<g;d++){var h=
b[d];if(e instanceof h){f.array=new h(e);break}}a.attributes[c]=f}d=0;for(g=this.offsets.length;d<g;d++)b=this.offsets[d],a.offsets.push({start:b.start,index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();
THREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a};THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};
THREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(0.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};
THREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};THREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=0.5;this.quadraticAttenuation=0.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,
0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=
this.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);THREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};
THREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,addStatusElement:function(){var a=document.createElement("div");a.style.position="absolute";a.style.right="0px";a.style.top="0px";a.style.fontSize="0.8em";a.style.textAlign="left";a.style.background="rgba(0,0,0,0.25)";a.style.color="#fff";a.style.width="120px";a.style.padding="0.5em 0.5em 0.5em 0.5em";a.style.zIndex=1E3;a.innerHTML="Loading ...";return a},updateProgress:function(a){var b="Loaded ",b=a.total?b+((100*a.loaded/a.total).toFixed(0)+
"%"):b+((a.loaded/1E3).toFixed(2)+" KB");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split("/");if(1===a.length)return"./";a.pop();return a.join("/")+"/"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=THREE.Loader.prototype.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.floor(a)==
a}function d(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function e(a,b){var e=new Image;e.onload=function(){if(c(this.width)&&c(this.height))a.image=this;else{var b=d(this.width),e=d(this.height);a.image.width=b;a.image.height=e;a.image.getContext("2d").drawImage(this,0,0,b,e)}a.needsUpdate=!0};void 0!==h.crossOrigin&&(e.crossOrigin=h.crossOrigin);e.src=b}function f(a,c,d,f,g,h,k){var l=/\.dds$/i.test(d),n=b+d;if(l){var E=THREE.ImageUtils.loadCompressedTexture(n);a[c]=E}else E=document.createElement("canvas"),
a[c]=new THREE.Texture(E);a[c].sourceFile=d;f&&(a[c].repeat.set(f[0],f[1]),1!==f[0]&&(a[c].wrapS=THREE.RepeatWrapping),1!==f[1]&&(a[c].wrapT=THREE.RepeatWrapping));g&&a[c].offset.set(g[0],g[1]);h&&(d={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==d[h[0]]&&(a[c].wrapS=d[h[0]]),void 0!==d[h[1]]&&(a[c].wrapT=d[h[1]]));k&&(a[c].anisotropy=k);l||e(a[c],n)}function g(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var h=this,k="MeshLambertMaterial",l={color:15658734,opacity:1,
map:null,lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var n=a.shading.toLowerCase();"phong"===n?k="MeshPhongMaterial":"basic"===n&&(k="MeshBasicMaterial")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(l.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)l.transparent=a.transparent;void 0!==a.depthTest&&(l.depthTest=a.depthTest);void 0!==a.depthWrite&&(l.depthWrite=a.depthWrite);void 0!==a.visible&&(l.visible=a.visible);void 0!==a.flipSided&&(l.side=THREE.BackSide);
void 0!==a.doubleSided&&(l.side=THREE.DoubleSide);void 0!==a.wireframe&&(l.wireframe=a.wireframe);void 0!==a.vertexColors&&("face"===a.vertexColors?l.vertexColors=THREE.FaceColors:a.vertexColors&&(l.vertexColors=THREE.VertexColors));a.colorDiffuse?l.color=g(a.colorDiffuse):a.DbgColor&&(l.color=a.DbgColor);a.colorSpecular&&(l.specular=g(a.colorSpecular));a.colorAmbient&&(l.ambient=g(a.colorAmbient));a.transparency&&(l.opacity=a.transparency);a.specularCoef&&(l.shininess=a.specularCoef);a.mapDiffuse&&
b&&f(l,"map",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);a.mapLight&&b&&f(l,"lightMap",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&f(l,"bumpMap",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&f(l,"normalMap",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&f(l,"specularMap",a.mapSpecular,a.mapSpecularRepeat,
a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapBumpScale&&(l.bumpScale=a.mapBumpScale);a.mapNormal?(k=THREE.ShaderLib.normalmap,n=THREE.UniformsUtils.clone(k.uniforms),n.tNormal.value=l.normalMap,a.mapNormalFactor&&n.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),l.map&&(n.tDiffuse.value=l.map,n.enableDiffuse.value=!0),l.specularMap&&(n.tSpecular.value=l.specularMap,n.enableSpecular.value=!0),l.lightMap&&(n.tAO.value=l.lightMap,n.enableAO.value=!0),n.diffuse.value.setHex(l.color),
n.specular.value.setHex(l.specular),n.ambient.value.setHex(l.ambient),n.shininess.value=l.shininess,void 0!==l.opacity&&(n.opacity.value=l.opacity),k=new THREE.ShaderMaterial({fragmentShader:k.fragmentShader,vertexShader:k.vertexShader,uniforms:n,lights:!0,fog:!0}),l.transparent&&(k.transparent=!0)):k=new THREE[k](l);void 0!==a.DbgName&&(k.name=a.DbgName);return k}};THREE.XHRLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=new XMLHttpRequest;void 0!==b&&f.addEventListener("load",function(c){b(c.target.responseText);e.manager.itemEnd(a)},!1);void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1);void 0!==d&&f.addEventListener("error",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.open("GET",a,!0);f.send(null);e.manager.itemStart(a)},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=document.createElement("img");void 0!==b&&f.addEventListener("load",function(c){e.manager.itemEnd(a);b(this)},!1);void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1);void 0!==d&&f.addEventListener("error",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.src=a;e.manager.itemStart(a);return f},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a);this.withCredentials=!1};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);THREE.JSONLoader.prototype.load=function(a,b,c){c=c&&"string"===typeof c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};
THREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){var f=new XMLHttpRequest,g=0;f.onreadystatechange=function(){if(f.readyState===f.DONE)if(200===f.status||0===f.status){if(f.responseText){var h=JSON.parse(f.responseText);if("scene"===h.metadata.type){console.error('THREE.JSONLoader: "'+b+'" seems to be a Scene. Use THREE.SceneLoader instead.');return}h=a.parse(h,d);c(h.geometry,h.materials)}else console.error('THREE.JSONLoader: "'+b+'" seems to be unreachable or the file is empty.');a.onLoadComplete()}else console.error("THREE.JSONLoader: Couldn't load \""+
b+'" ('+f.status+")");else f.readyState===f.LOADING?e&&(0===g&&(g=f.getResponseHeader("Content-Length")),e({total:g,loaded:f.responseText.length})):f.readyState===f.HEADERS_RECEIVED&&void 0!==e&&(g=f.getResponseHeader("Content-Length"))};f.open("GET",b,!0);f.withCredentials=this.withCredentials;f.send(null)};
THREE.JSONLoader.prototype.parse=function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/a.scale:1;(function(b){var d,g,h,k,l,n,q,s,u,t,p,v,w,r=a.faces;n=a.vertices;var y=a.normals,E=a.colors,z=0;if(void 0!==a.uvs){for(d=0;d<a.uvs.length;d++)a.uvs[d].length&&z++;for(d=0;d<z;d++)c.faceVertexUvs[d]=[]}k=0;for(l=n.length;k<l;)d=new THREE.Vector3,d.x=n[k++]*b,d.y=n[k++]*b,d.z=n[k++]*b,c.vertices.push(d);k=0;for(l=r.length;k<l;)if(b=r[k++],u=b&1,h=b&2,d=b&8,q=b&16,t=b&32,n=b&64,b&=128,u){u=new THREE.Face3;
u.a=r[k];u.b=r[k+1];u.c=r[k+3];p=new THREE.Face3;p.a=r[k+1];p.b=r[k+2];p.c=r[k+3];k+=4;h&&(h=r[k++],u.materialIndex=h,p.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<z;d++)for(v=a.uvs[d],c.faceVertexUvs[d][h]=[],c.faceVertexUvs[d][h+1]=[],g=0;4>g;g++)s=r[k++],w=v[2*s],s=v[2*s+1],w=new THREE.Vector2(w,s),2!==g&&c.faceVertexUvs[d][h].push(w),0!==g&&c.faceVertexUvs[d][h+1].push(w);q&&(q=3*r[k++],u.normal.set(y[q++],y[q++],y[q]),p.normal.copy(u.normal));if(t)for(d=0;4>d;d++)q=3*r[k++],t=new THREE.Vector3(y[q++],
y[q++],y[q]),2!==d&&u.vertexNormals.push(t),0!==d&&p.vertexNormals.push(t);n&&(n=r[k++],n=E[n],u.color.setHex(n),p.color.setHex(n));if(b)for(d=0;4>d;d++)n=r[k++],n=E[n],2!==d&&u.vertexColors.push(new THREE.Color(n)),0!==d&&p.vertexColors.push(new THREE.Color(n));c.faces.push(u);c.faces.push(p)}else{u=new THREE.Face3;u.a=r[k++];u.b=r[k++];u.c=r[k++];h&&(h=r[k++],u.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<z;d++)for(v=a.uvs[d],c.faceVertexUvs[d][h]=[],g=0;3>g;g++)s=r[k++],w=v[2*s],s=v[2*s+1],
w=new THREE.Vector2(w,s),c.faceVertexUvs[d][h].push(w);q&&(q=3*r[k++],u.normal.set(y[q++],y[q++],y[q]));if(t)for(d=0;3>d;d++)q=3*r[k++],t=new THREE.Vector3(y[q++],y[q++],y[q]),u.vertexNormals.push(t);n&&(n=r[k++],u.color.setHex(E[n]));if(b)for(d=0;3>d;d++)n=r[k++],u.vertexColors.push(new THREE.Color(E[n]));c.faces.push(u)}})(d);(function(){if(a.skinWeights)for(var b=0,d=a.skinWeights.length;b<d;b+=2)c.skinWeights.push(new THREE.Vector4(a.skinWeights[b],a.skinWeights[b+1],0,0));if(a.skinIndices)for(b=
0,d=a.skinIndices.length;b<d;b+=2)c.skinIndices.push(new THREE.Vector4(a.skinIndices[b],a.skinIndices[b+1],0,0));c.bones=a.bones;c.bones&&0<c.bones.length&&(c.skinWeights.length!==c.skinIndices.length||c.skinIndices.length!==c.vertices.length)&&console.warn("When skinning, number of vertices ("+c.vertices.length+"), skinIndices ("+c.skinIndices.length+"), and skinWeights ("+c.skinWeights.length+") should match.");c.animation=a.animation;c.animations=a.animations})();(function(b){if(void 0!==a.morphTargets){var d,
g,h,k,l,n;d=0;for(g=a.morphTargets.length;d<g;d++)for(c.morphTargets[d]={},c.morphTargets[d].name=a.morphTargets[d].name,c.morphTargets[d].vertices=[],l=c.morphTargets[d].vertices,n=a.morphTargets[d].vertices,h=0,k=n.length;h<k;h+=3){var q=new THREE.Vector3;q.x=n[h]*b;q.y=n[h+1]*b;q.z=n[h+2]*b;l.push(q)}}if(void 0!==a.morphColors)for(d=0,g=a.morphColors.length;d<g;d++)for(c.morphColors[d]={},c.morphColors[d].name=a.morphColors[d].name,c.morphColors[d].colors=[],k=c.morphColors[d].colors,l=a.morphColors[d].colors,
b=0,h=l.length;b<h;b+=3)n=new THREE.Color(16755200),n.setRGB(l[b],l[b+1],l[b+2]),k.push(n)})(d);c.computeCentroids();c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials)return{geometry:c};d=this.initMaterials(a.materials,b);this.needsTangents(d)&&c.computeTangents();return{geometry:c,materials:d}};THREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b,c,d){var e=this;c=new THREE.XHRLoader;c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){b(e.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE.BufferGeometry,c=a.attributes,d=a.offsets;a=a.boundingSphere;for(var e in c){var f=c[e];b.attributes[e]={itemSize:f.itemSize,array:new self[f.type](f.array)}}void 0!==d&&(b.offsets=JSON.parse(JSON.stringify(d)));
void 0!==a&&(b.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(void 0!==a.center?a.center:[0,0,0]),a.radius));return b}};THREE.GeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.GeometryLoader.prototype={constructor:THREE.GeometryLoader,load:function(a,b,c,d){var e=this;c=new THREE.XHRLoader;c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){b(e.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b,c,d){var e=this;c=new THREE.XHRLoader;c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){b(e.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE[a.type];void 0!==a.color&&b.color.setHex(a.color);void 0!==a.ambient&&b.ambient.setHex(a.ambient);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&
(b.shininess=a.shininess);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.blending&&(b.blending=a.blending);void 0!==a.side&&(b.side=a.side);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.wireframe&&(b.wireframe=a.wireframe);if(void 0!==a.materials)for(var c=0,d=a.materials.length;c<d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b,c,d){var e=this;c=new THREE.XHRLoader(e.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){b(e.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=this.parseGeometries(a.geometries),c=this.parseMaterials(a.materials);return this.parseObject(a.object,b,c)},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,
e=0,f=a.length;e<f;e++){var g,h=a[e];switch(h.type){case "PlaneGeometry":g=new THREE.PlaneGeometry(h.width,h.height,h.widthSegments,h.heightSegments);break;case "BoxGeometry":case "CubeGeometry":g=new THREE.BoxGeometry(h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case "CircleGeometry":g=new THREE.CircleGeometry(h.radius,h.segments);break;case "CylinderGeometry":g=new THREE.CylinderGeometry(h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded);
break;case "SphereGeometry":g=new THREE.SphereGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case "IcosahedronGeometry":g=new THREE.IcosahedronGeometry(h.radius,h.detail);break;case "TorusGeometry":g=new THREE.TorusGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case "TorusKnotGeometry":g=new THREE.TorusKnotGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.p,h.q,h.heightScale);break;case "BufferGeometry":g=
d.parse(h.data);break;case "Geometry":g=c.parse(h.data).geometry}g.uuid=h.uuid;void 0!==h.name&&(g.name=h.name);b[h.uuid]=g}return b},parseMaterials:function(a){var b={};if(void 0!==a)for(var c=new THREE.MaterialLoader,d=0,e=a.length;d<e;d++){var f=a[d],g=c.parse(f);g.uuid=f.uuid;void 0!==f.name&&(g.name=f.name);b[f.uuid]=g}return b},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){var e;switch(b.type){case "Scene":e=new THREE.Scene;break;case "PerspectiveCamera":e=new THREE.PerspectiveCamera(b.fov,
b.aspect,b.near,b.far);break;case "OrthographicCamera":e=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case "AmbientLight":e=new THREE.AmbientLight(b.color);break;case "DirectionalLight":e=new THREE.DirectionalLight(b.color,b.intensity);break;case "PointLight":e=new THREE.PointLight(b.color,b.intensity,b.distance);break;case "SpotLight":e=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.exponent);break;case "HemisphereLight":e=new THREE.HemisphereLight(b.color,
b.groundColor,b.intensity);break;case "Mesh":e=c[b.geometry];var f=d[b.material];void 0===e&&console.error("THREE.ObjectLoader: Undefined geometry "+b.geometry);void 0===f&&console.error("THREE.ObjectLoader: Undefined material "+b.material);e=new THREE.Mesh(e,f);break;case "Sprite":f=d[b.material];void 0===f&&console.error("THREE.ObjectLoader: Undefined material "+b.material);e=new THREE.Sprite(f);break;default:e=new THREE.Object3D}e.uuid=b.uuid;void 0!==b.name&&(e.name=b.name);void 0!==b.matrix?
(a.fromArray(b.matrix),a.decompose(e.position,e.quaternion,e.scale)):(void 0!==b.position&&e.position.fromArray(b.position),void 0!==b.rotation&&e.rotation.fromArray(b.rotation),void 0!==b.scale&&e.scale.fromArray(b.scale));void 0!==b.visible&&(e.visible=b.visible);void 0!==b.userData&&(e.userData=b.userData);if(void 0!==b.children)for(var g in b.children)e.add(this.parseObject(b.children[g],c,d));return e}}()};THREE.SceneLoader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};this.callbackSync=function(){};this.callbackProgress=function(){};this.geometryHandlers={};this.hierarchyHandlers={};this.addGeometryHandler("ascii",THREE.JSONLoader)};
THREE.SceneLoader.prototype={constructor:THREE.SceneLoader,load:function(a,b,c,d){var e=this;c=new THREE.XHRLoader(e.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(c){e.parse(JSON.parse(c),b,a)})},setCrossOrigin:function(a){this.crossOrigin=a},addGeometryHandler:function(a,b){this.geometryHandlers[a]={loaderClass:b}},addHierarchyHandler:function(a,b){this.hierarchyHandlers[a]={loaderClass:b}},parse:function(a,b,c){function d(a,b){return"relativeToHTML"==b?a:u+"/"+a}function e(){f(A.scene,
M.objects)}function f(a,b){var c,e,g,h,l,n;for(n in b){var q=A.objects[n],r=b[n];if(void 0===q){if(r.type&&r.type in s.hierarchyHandlers){if(void 0===r.loading){c={type:1,url:1,material:1,position:1,rotation:1,scale:1,visible:1,children:1,userData:1,skin:1,morph:1,mirroredLoop:1,duration:1};var u={},w;for(w in r)w in c||(u[w]=r[w]);p=A.materials[r.material];r.loading=!0;c=s.hierarchyHandlers[r.type].loaderObject;c.options?c.load(d(r.url,M.urlBaseType),k(n,a,p,r)):c.load(d(r.url,M.urlBaseType),k(n,
a,p,r),u)}}else if(void 0!==r.geometry){if(t=A.geometries[r.geometry]){q=!1;p=A.materials[r.material];q=p instanceof THREE.ShaderMaterial;e=r.position;g=r.rotation;h=r.scale;c=r.matrix;l=r.quaternion;r.material||(p=new THREE.MeshFaceMaterial(A.face_materials[r.geometry]));p instanceof THREE.MeshFaceMaterial&&0===p.materials.length&&(p=new THREE.MeshFaceMaterial(A.face_materials[r.geometry]));if(p instanceof THREE.MeshFaceMaterial)for(u=0;u<p.materials.length;u++)q=q||p.materials[u]instanceof THREE.ShaderMaterial;
q&&t.computeTangents();r.skin?q=new THREE.SkinnedMesh(t,p):r.morph?(q=new THREE.MorphAnimMesh(t,p),void 0!==r.duration&&(q.duration=r.duration),void 0!==r.time&&(q.time=r.time),void 0!==r.mirroredLoop&&(q.mirroredLoop=r.mirroredLoop),p.morphNormals&&t.computeMorphNormals()):q=new THREE.Mesh(t,p);q.name=n;c?(q.matrixAutoUpdate=!1,q.matrix.set(c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9],c[10],c[11],c[12],c[13],c[14],c[15])):(q.position.fromArray(e),l?q.quaternion.fromArray(l):q.rotation.fromArray(g),
q.scale.fromArray(h));q.visible=r.visible;q.castShadow=r.castShadow;q.receiveShadow=r.receiveShadow;a.add(q);A.objects[n]=q}}else if("AmbientLight"===r.type||"PointLight"===r.type||"DirectionalLight"===r.type||"SpotLight"===r.type||"HemisphereLight"===r.type||"AreaLight"===r.type){u=r.color;c=r.intensity;e=r.distance;g=r.position;h=r.rotation;switch(r.type){case "AmbientLight":y=new THREE.AmbientLight(u);break;case "PointLight":y=new THREE.PointLight(u,c,e);y.position.fromArray(g);break;case "DirectionalLight":y=
new THREE.DirectionalLight(u,c);y.position.fromArray(r.direction);break;case "SpotLight":y=new THREE.SpotLight(u,c,e,1);y.angle=r.angle;y.position.fromArray(g);y.target.set(g[0],g[1]-e,g[2]);y.target.applyEuler(new THREE.Euler(h[0],h[1],h[2],"XYZ"));break;case "HemisphereLight":y=new THREE.DirectionalLight(u,c,e);y.target.set(g[0],g[1]-e,g[2]);y.target.applyEuler(new THREE.Euler(h[0],h[1],h[2],"XYZ"));break;case "AreaLight":y=new THREE.AreaLight(u,c),y.position.fromArray(g),y.width=r.size,y.height=
r.size_y}a.add(y);y.name=n;A.lights[n]=y;A.objects[n]=y}else"PerspectiveCamera"===r.type||"OrthographicCamera"===r.type?(e=r.position,g=r.rotation,l=r.quaternion,"PerspectiveCamera"===r.type?v=new THREE.PerspectiveCamera(r.fov,r.aspect,r.near,r.far):"OrthographicCamera"===r.type&&(v=new THREE.OrthographicCamera(r.left,r.right,r.top,r.bottom,r.near,r.far)),v.name=n,v.position.fromArray(e),void 0!==l?v.quaternion.fromArray(l):void 0!==g&&v.rotation.fromArray(g),a.add(v),A.cameras[n]=v,A.objects[n]=
v):(e=r.position,g=r.rotation,h=r.scale,l=r.quaternion,q=new THREE.Object3D,q.name=n,q.position.fromArray(e),l?q.quaternion.fromArray(l):q.rotation.fromArray(g),q.scale.fromArray(h),q.visible=void 0!==r.visible?r.visible:!1,a.add(q),A.objects[n]=q,A.empties[n]=q);if(q){if(void 0!==r.userData)for(var x in r.userData)q.userData[x]=r.userData[x];if(void 0!==r.groups)for(u=0;u<r.groups.length;u++)c=r.groups[u],void 0===A.groups[c]&&(A.groups[c]=[]),A.groups[c].push(n)}}void 0!==q&&void 0!==r.children&&
f(q,r.children)}}function g(a,b,c,d,f){var g=f.rotation,h=f.quaternion,k=f.scale;a.position.fromArray(f.position);h?a.quaternion.fromArray(h):a.rotation.fromArray(g);a.scale.fromArray(k);d&&a.traverse(function(a){a.material=d});var l=void 0!==f.visible?f.visible:!0;a.traverse(function(a){a.visible=l});c.add(a);a.name=b;A.objects[b]=a;e()}function h(a){return function(b,c){b.name=a;A.geometries[a]=b;A.face_materials[a]=c;e();E-=1;s.onLoadComplete();n()}}function k(a,b,c,d){return function(e){g(e.content?
e.content:e.dae?e.scene:e,a,b,c,d);E-=1;s.onLoadComplete();n()}}function l(a){return function(b,c){b.name=a;A.geometries[a]=b;A.face_materials[a]=c}}function n(){s.callbackProgress({totalModels:P,totalTextures:J,loadedModels:P-E,loadedTextures:J-z},A);s.onLoadProgress();if(0===E&&0===z){for(var a=0;a<C.length;a++){var c=C[a],d=A.objects[c.targetName];d?c.object.target=d:(c.object.target=new THREE.Object3D,A.scene.add(c.object.target));c.object.target.userData.targetInverse=c.object}b(A)}}function q(a,
b){b(a);if(void 0!==a.children)for(var c in a.children)q(a.children[c],b)}var s=this,u=THREE.Loader.prototype.extractUrlBase(c),t,p,v,w,r,y,E,z,P,J,A,C=[],M=a,H;for(H in this.geometryHandlers)a=this.geometryHandlers[H].loaderClass,this.geometryHandlers[H].loaderObject=new a;for(H in this.hierarchyHandlers)a=this.hierarchyHandlers[H].loaderClass,this.hierarchyHandlers[H].loaderObject=new a;z=E=0;A={scene:new THREE.Scene,geometries:{},face_materials:{},materials:{},textures:{},objects:{},cameras:{},
lights:{},fogs:{},empties:{},groups:{}};M.transform&&(H=M.transform.position,a=M.transform.rotation,c=M.transform.scale,H&&A.scene.position.fromArray(H),a&&A.scene.rotation.fromArray(a),c&&A.scene.scale.fromArray(c),H||a||c)&&(A.scene.updateMatrix(),A.scene.updateMatrixWorld());H=function(a){return function(){z-=a;n();s.onLoadComplete()}};for(var K in M.fogs)a=M.fogs[K],"linear"===a.type?w=new THREE.Fog(0,a.near,a.far):"exp2"===a.type&&(w=new THREE.FogExp2(0,a.density)),a=a.color,w.color.setRGB(a[0],
a[1],a[2]),A.fogs[K]=w;for(var x in M.geometries)w=M.geometries[x],w.type in this.geometryHandlers&&(E+=1,s.onLoadStart());for(var N in M.objects)q(M.objects[N],function(a){a.type&&a.type in s.hierarchyHandlers&&(E+=1,s.onLoadStart())});P=E;for(x in M.geometries)if(w=M.geometries[x],"cube"===w.type)t=new THREE.BoxGeometry(w.width,w.height,w.depth,w.widthSegments,w.heightSegments,w.depthSegments),t.name=x,A.geometries[x]=t;else if("plane"===w.type)t=new THREE.PlaneGeometry(w.width,w.height,w.widthSegments,
w.heightSegments),t.name=x,A.geometries[x]=t;else if("sphere"===w.type)t=new THREE.SphereGeometry(w.radius,w.widthSegments,w.heightSegments),t.name=x,A.geometries[x]=t;else if("cylinder"===w.type)t=new THREE.CylinderGeometry(w.topRad,w.botRad,w.height,w.radSegs,w.heightSegs),t.name=x,A.geometries[x]=t;else if("torus"===w.type)t=new THREE.TorusGeometry(w.radius,w.tube,w.segmentsR,w.segmentsT),t.name=x,A.geometries[x]=t;else if("icosahedron"===w.type)t=new THREE.IcosahedronGeometry(w.radius,w.subdivisions),
t.name=x,A.geometries[x]=t;else if(w.type in this.geometryHandlers){N={};for(r in w)"type"!==r&&"url"!==r&&(N[r]=w[r]);this.geometryHandlers[w.type].loaderObject.load(d(w.url,M.urlBaseType),h(x),N)}else"embedded"===w.type&&(N=M.embeds[w.id],N.metadata=M.metadata,N&&(N=this.geometryHandlers.ascii.loaderObject.parse(N,""),l(x)(N.geometry,N.materials)));for(var F in M.textures)if(x=M.textures[F],x.url instanceof Array)for(z+=x.url.length,r=0;r<x.url.length;r++)s.onLoadStart();else z+=1,s.onLoadStart();
J=z;for(F in M.textures){x=M.textures[F];void 0!==x.mapping&&void 0!==THREE[x.mapping]&&(x.mapping=new THREE[x.mapping]);if(x.url instanceof Array){N=x.url.length;w=[];for(r=0;r<N;r++)w[r]=d(x.url[r],M.urlBaseType);r=(r=/\.dds$/i.test(w[0]))?THREE.ImageUtils.loadCompressedTextureCube(w,x.mapping,H(N)):THREE.ImageUtils.loadTextureCube(w,x.mapping,H(N))}else r=/\.dds$/i.test(x.url),N=d(x.url,M.urlBaseType),w=H(1),r=r?THREE.ImageUtils.loadCompressedTexture(N,x.mapping,w):THREE.ImageUtils.loadTexture(N,
x.mapping,w),void 0!==THREE[x.minFilter]&&(r.minFilter=THREE[x.minFilter]),void 0!==THREE[x.magFilter]&&(r.magFilter=THREE[x.magFilter]),x.anisotropy&&(r.anisotropy=x.anisotropy),x.repeat&&(r.repeat.set(x.repeat[0],x.repeat[1]),1!==x.repeat[0]&&(r.wrapS=THREE.RepeatWrapping),1!==x.repeat[1]&&(r.wrapT=THREE.RepeatWrapping)),x.offset&&r.offset.set(x.offset[0],x.offset[1]),x.wrap&&(N={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==N[x.wrap[0]]&&(r.wrapS=N[x.wrap[0]]),void 0!==
N[x.wrap[1]]&&(r.wrapT=N[x.wrap[1]]));A.textures[F]=r}var B,D;for(B in M.materials){F=M.materials[B];for(D in F.parameters)"envMap"===D||"map"===D||"lightMap"===D||"bumpMap"===D?F.parameters[D]=A.textures[F.parameters[D]]:"shading"===D?F.parameters[D]="flat"===F.parameters[D]?THREE.FlatShading:THREE.SmoothShading:"side"===D?F.parameters[D]="double"==F.parameters[D]?THREE.DoubleSide:"back"==F.parameters[D]?THREE.BackSide:THREE.FrontSide:"blending"===D?F.parameters[D]=F.parameters[D]in THREE?THREE[F.parameters[D]]:
THREE.NormalBlending:"combine"===D?F.parameters[D]=F.parameters[D]in THREE?THREE[F.parameters[D]]:THREE.MultiplyOperation:"vertexColors"===D?"face"==F.parameters[D]?F.parameters[D]=THREE.FaceColors:F.parameters[D]&&(F.parameters[D]=THREE.VertexColors):"wrapRGB"===D&&(H=F.parameters[D],F.parameters[D]=new THREE.Vector3(H[0],H[1],H[2]));void 0!==F.parameters.opacity&&1>F.parameters.opacity&&(F.parameters.transparent=!0);F.parameters.normalMap?(H=THREE.ShaderLib.normalmap,x=THREE.UniformsUtils.clone(H.uniforms),
r=F.parameters.color,N=F.parameters.specular,w=F.parameters.ambient,K=F.parameters.shininess,x.tNormal.value=A.textures[F.parameters.normalMap],F.parameters.normalScale&&x.uNormalScale.value.set(F.parameters.normalScale[0],F.parameters.normalScale[1]),F.parameters.map&&(x.tDiffuse.value=F.parameters.map,x.enableDiffuse.value=!0),F.parameters.envMap&&(x.tCube.value=F.parameters.envMap,x.enableReflection.value=!0,x.reflectivity.value=F.parameters.reflectivity),F.parameters.lightMap&&(x.tAO.value=F.parameters.lightMap,
x.enableAO.value=!0),F.parameters.specularMap&&(x.tSpecular.value=A.textures[F.parameters.specularMap],x.enableSpecular.value=!0),F.parameters.displacementMap&&(x.tDisplacement.value=A.textures[F.parameters.displacementMap],x.enableDisplacement.value=!0,x.uDisplacementBias.value=F.parameters.displacementBias,x.uDisplacementScale.value=F.parameters.displacementScale),x.diffuse.value.setHex(r),x.specular.value.setHex(N),x.ambient.value.setHex(w),x.shininess.value=K,F.parameters.opacity&&(x.opacity.value=
F.parameters.opacity),p=new THREE.ShaderMaterial({fragmentShader:H.fragmentShader,vertexShader:H.vertexShader,uniforms:x,lights:!0,fog:!0})):p=new THREE[F.type](F.parameters);p.name=B;A.materials[B]=p}for(B in M.materials)if(F=M.materials[B],F.parameters.materials){D=[];for(r=0;r<F.parameters.materials.length;r++)D.push(A.materials[F.parameters.materials[r]]);A.materials[B].materials=D}e();A.cameras&&M.defaults.camera&&(A.currentCamera=A.cameras[M.defaults.camera]);A.fogs&&M.defaults.fog&&(A.scene.fog=
A.fogs[M.defaults.fog]);s.callbackSync(A);n()}};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b,c,d){c=new THREE.ImageLoader(this.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)})},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};
THREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]="overdraw"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;
a.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};
THREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=
this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=
"round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;
a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.wrapAround=this.metal=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=
1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);
a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};THREE.ParticleSystemMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.ParticleSystemMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone=function(){var a=new THREE.ParticleSystemMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleBasicMaterial=THREE.ParticleSystemMaterial;THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.vertexShader=this.fragmentShader="void main() {}";this.uniforms={};this.defines={};this.attributes=null;this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName="position";this.setValues(a)};
THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=
this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.rotation=0;this.fog=!1;this.setValues(a)};THREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.clone=function(){var a=new THREE.SpriteMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.rotation=this.rotation;a.fog=this.fog;return a};THREE.SpriteCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(a,c){};this.setValues(a)};THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteCanvasMaterial.prototype.clone=function(){var a=new THREE.SpriteCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleCanvasMaterial=THREE.SpriteCanvasMaterial;THREE.Texture=function(a,b,c,d,e,f,g,h,k){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.image=a;this.mipmaps=[];this.mapping=void 0!==b?b:new THREE.UVMapping;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;
this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this._needsUpdate=!1;this.onUpdate=null};
THREE.Texture.prototype={constructor:THREE.Texture,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=
this.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=this.unpackAlignment;return a},update:function(){this.dispatchEvent({type:"update"})},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,k,l,n){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,k,l,n){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.ParticleSystemMaterial({color:16777215*Math.random()});this.frustumCulled=this.sortParticles=!1};THREE.ParticleSystem.prototype=Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone=function(a){void 0===a&&(a=new THREE.ParticleSystem(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets=function(){if(void 0!==this.geometry.morphTargets&&0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};
THREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log("THREE.Mesh.getMorphTargetIndexByName: morph target "+a+" does not exist. Returning 0.");return 0};THREE.Mesh.prototype.clone=function(a){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.skinMatrix=new THREE.Matrix4};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);THREE.Bone.prototype.update=function(a,b){this.matrixAutoUpdate&&(b|=this.updateMatrix());if(b||this.matrixWorldNeedsUpdate)a?this.skinMatrix.multiplyMatrices(a,this.matrix):this.skinMatrix.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,b=!0;var c,d=this.children.length;for(c=0;c<d;c++)this.children[c].update(this.skinMatrix,b)};THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;this.bones=[];this.boneMatrices=[];var d,e,f;if(this.geometry&&void 0!==this.geometry.bones){for(a=0;a<this.geometry.bones.length;a++)c=this.geometry.bones[a],d=c.pos,e=c.rotq,f=c.scl,b=this.addBone(),b.name=c.name,b.position.set(d[0],d[1],d[2]),b.quaternion.set(e[0],e[1],e[2],e[3]),void 0!==f?b.scale.set(f[0],f[1],f[2]):b.scale.set(1,1,1);for(a=0;a<this.bones.length;a++)c=
this.geometry.bones[a],b=this.bones[a],-1===c.parent?this.add(b):this.bones[c.parent].add(b);a=this.bones.length;this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<a?64:64<a?32:16<a?16:8,this.boneMatrices=new Float32Array(this.boneTextureWidth*this.boneTextureHeight*4),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),this.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=
THREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*a);this.pose()}};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.addBone=function(a){void 0===a&&(a=new THREE.Bone(this));this.bones.push(a);return a};
THREE.SkinnedMesh.prototype.updateMatrixWorld=function(){var a=new THREE.Matrix4;return function(b){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||b)this.parent?this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1;b=0;for(var c=this.children.length;b<c;b++){var d=this.children[b];d instanceof THREE.Bone?d.update(this.identityMatrix,!1):d.updateMatrixWorld(!0)}if(void 0==this.boneInverses)for(this.boneInverses=
[],b=0,c=this.bones.length;b<c;b++)d=new THREE.Matrix4,d.getInverse(this.bones[b].skinMatrix),this.boneInverses.push(d);b=0;for(c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b].skinMatrix,this.boneInverses[b]),a.flattenToArrayOffset(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)}}();THREE.SkinnedMesh.prototype.pose=function(){this.updateMatrixWorld(!0);this.normalizeSkinWeights()};
THREE.SkinnedMesh.prototype.normalizeSkinWeights=function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};THREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};
THREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};
THREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)(\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var g=a.morphTargets[e].name.match(d);if(g&&1<g.length){g=g[1];c[g]||(c[g]={start:Infinity,end:-Infinity});var h=c[g];e<h.start&&(h.start=e);e>h.end&&(h.end=e);b||(b=g)}}a.firstAnimation=b};
THREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=(c.end-c.start)/b*1E3,this.time=0):console.warn("animation["+a+"] undefined")};
THREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time&&(this.time=0,this.directionBackwards=!1)}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&
(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};
THREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.objects=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);THREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);b=Math.abs(b);for(var c=0;c<this.objects.length&&!(b<this.objects[c].distance);c++);this.objects.splice(c,0,{distance:b,object:a});this.add(a)};THREE.LOD.prototype.getObjectForDistance=function(a){for(var b=1,c=this.objects.length;b<c&&!(a<this.objects[b].distance);b++);return this.objects[b-1].object};
THREE.LOD.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){if(1<this.objects.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);this.objects[0].object.visible=!0;for(var d=1,e=this.objects.length;d<e;d++)if(c>=this.objects[d].distance)this.objects[d-1].object.visible=!1,this.objects[d].object.visible=!0;else break;for(;d<e;d++)this.objects[d].object.visible=!1}}}();
THREE.LOD.prototype.clone=function(a){void 0===a&&(a=new THREE.LOD);THREE.Object3D.prototype.clone.call(this,a);for(var b=0,c=this.objects.length;b<c;b++){var d=this.objects[b].object.clone();d.visible=0===b;a.addLevel(d,this.objects[b].distance)}return a};THREE.Sprite=function(a){THREE.Object3D.call(this);this.material=void 0!==a?a:new THREE.SpriteMaterial};THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0};THREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Particle=THREE.Sprite;THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}this.dispatchEvent({type:"objectAdded",object:a});a.dispatchEvent({type:"addedToScene",scene:this});for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};
THREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));this.dispatchEvent({type:"objectRemoved",object:a});a.dispatchEvent({type:"removedFromScene",scene:this});for(b=
0;b<a.children.length;b++)this.__removeObject(a.children[b])};THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name="";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name="";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.CanvasRenderer=function(a){function b(a,b,c){for(var d=0,e=P.length;d<e;d++){var f=P[d];Na.copy(f.color);if(f instanceof THREE.DirectionalLight){var g=ga.setFromMatrixPosition(f.matrixWorld).normalize(),h=b.dot(g);0>=h||(h*=f.intensity,c.add(Na.multiplyScalar(h)))}else f instanceof THREE.PointLight&&(g=ga.setFromMatrixPosition(f.matrixWorld),h=b.dot(ga.subVectors(g,a).normalize()),0>=h||(h*=0==f.distance?1:1-Math.min(a.distanceTo(g)/f.distance,1),0!=h&&(h*=f.intensity,c.add(Na.multiplyScalar(h)))))}}
function c(a,b,c,d){s(b);u(c);t(d);p(a.getStyle());x.stroke();ja.expandByScalar(2*b)}function d(a){v(a.getStyle());x.fill()}function e(a){f(a.target)}function f(a){var b=a.wrapS===THREE.RepeatWrapping,c=a.wrapT===THREE.RepeatWrapping,d=a.image,e=document.createElement("canvas");e.width=d.width;e.height=d.height;var f=e.getContext("2d");f.setTransform(1,0,0,-1,0,d.height);f.drawImage(d,0,0);Za[a.id]=x.createPattern(e,!0===b&&!0===c?"repeat":!0===b&&!1===c?"repeat-x":!1===b&&!0===c?"repeat-y":"no-repeat")}
function g(a,b,c,d,g,h,m,k,l,p,n,r,q){if(!(q instanceof THREE.DataTexture)){!1===q.hasEventListener("update",e)&&(void 0!==q.image&&0<q.image.width&&f(q),q.addEventListener("update",e));var s=Za[q.id];if(void 0!==s){v(s);var s=q.offset.x/q.repeat.x,u=q.offset.y/q.repeat.y,t=q.image.width*q.repeat.x;q=q.image.height*q.repeat.y;m=(m+s)*t;k=(k+u)*q;c-=a;d-=b;g-=a;h-=b;l=(l+s)*t-m;p=(p+u)*q-k;n=(n+s)*t-m;r=(r+u)*q-k;q=l*r-n*p;0!==q&&(s=1/q,q=(r*c-p*g)*s,p=(r*d-p*h)*s,c=(l*g-n*c)*s,d=(l*h-n*d)*s,a=a-q*
m-c*k,b=b-p*m-d*k,x.save(),x.transform(q,p,c,d,a,b),x.fill(),x.restore())}else v("rgba(0,0,0,1)"),x.fill()}}function h(a,b,c,d,e,f,g,h,m,k,l,p,n){var q,r;q=n.width-1;r=n.height-1;g*=q;h*=r;c-=a;d-=b;e-=a;f-=b;m=m*q-g;k=k*r-h;l=l*q-g;p=p*r-h;r=1/(m*p-l*k);q=(p*c-k*e)*r;k=(p*d-k*f)*r;c=(m*e-l*c)*r;d=(m*f-l*d)*r;a=a-q*g-c*h;b=b-k*g-d*h;x.save();x.transform(q,k,c,d,a,b);x.clip();x.drawImage(n,0,0);x.restore()}function k(a,b,c,d){ea[0]=255*a.r|0;ea[1]=255*a.g|0;ea[2]=255*a.b|0;ea[4]=255*b.r|0;ea[5]=255*
b.g|0;ea[6]=255*b.b|0;ea[8]=255*c.r|0;ea[9]=255*c.g|0;ea[10]=255*c.b|0;ea[12]=255*d.r|0;ea[13]=255*d.g|0;ea[14]=255*d.b|0;Sa.putImageData(Wa,0,0);ib.drawImage(m,0,0);return Ka}function l(a,b,c){var d=b.x-a.x,e=b.y-a.y,f=d*d+e*e;0!==f&&(c/=Math.sqrt(f),d*=c,e*=c,b.x+=d,b.y+=e,a.x-=d,a.y-=e)}function n(a){B!==a&&(B=x.globalAlpha=a)}function q(a){D!==a&&(a===THREE.NormalBlending?x.globalCompositeOperation="source-over":a===THREE.AdditiveBlending?x.globalCompositeOperation="lighter":a===THREE.SubtractiveBlending&&
(x.globalCompositeOperation="darker"),D=a)}function s(a){S!==a&&(S=x.lineWidth=a)}function u(a){la!==a&&(la=x.lineCap=a)}function t(a){U!==a&&(U=x.lineJoin=a)}function p(a){G!==a&&(G=x.strokeStyle=a)}function v(a){Y!==a&&(Y=x.fillStyle=a)}function w(a,b){if(oa!==a||Q!==b)x.setLineDash([a,b]),oa=a,Q=b}console.log("THREE.CanvasRenderer",THREE.REVISION);var r=THREE.Math.smoothstep;a=a||{};var y=this,E,z,P,J=new THREE.Projector,A=void 0!==a.canvas?a.canvas:document.createElement("canvas"),C=A.width,M=
A.height,H=Math.floor(C/2),K=Math.floor(M/2),x=A.getContext("2d"),N=new THREE.Color(0),F=0,B=1,D=0,G=null,Y=null,S=null,la=null,U=null,oa=null,Q=0,fa,V,I,R;new THREE.RenderableVertex;new THREE.RenderableVertex;var Z,T,Ia,va,wa,Ca,da=new THREE.Color,za=new THREE.Color,xa=new THREE.Color,ya=new THREE.Color,Ma=new THREE.Color,Da=new THREE.Color,Ha=new THREE.Color,Na=new THREE.Color,Za={},Ja,Ea,ma,pa,qa,Oa,Pa,Qa,Aa,Ra,Ba=new THREE.Box2,$=new THREE.Box2,ja=new THREE.Box2,hb=new THREE.Color,zb=new THREE.Color,
ua=new THREE.Color,ga=new THREE.Vector3,ha=new THREE.Vector3,La=new THREE.Matrix3,m,Sa,Wa,ea,Ka,ib,db=16;m=document.createElement("canvas");m.width=m.height=2;Sa=m.getContext("2d");Sa.fillStyle="rgba(0,0,0,1)";Sa.fillRect(0,0,2,2);Wa=Sa.getImageData(0,0,2,2);ea=Wa.data;Ka=document.createElement("canvas");Ka.width=Ka.height=db;ib=Ka.getContext("2d");ib.translate(-db/2,-db/2);ib.scale(db,db);db--;void 0===x.setLineDash&&(x.setLineDash=void 0!==x.mozDash?function(a){x.mozDash=null!==a[0]?a:null}:function(){});
this.domElement=A;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.supportsVertexTextures=function(){};this.setFaceCulling=function(){};this.setSize=function(a,b,c){C=a*this.devicePixelRatio;M=b*this.devicePixelRatio;H=Math.floor(C/2);K=Math.floor(M/2);A.width=C;A.height=M;1!==this.devicePixelRatio&&!1!==c&&(A.style.width=a+"px",
A.style.height=b+"px");Ba.min.set(-H,-K);Ba.max.set(H,K);$.min.set(-H,-K);$.max.set(H,K);B=1;D=0;U=la=S=Y=G=null};this.setClearColor=function(a,b){N.set(a);F=void 0!==b?b:1;$.min.set(-H,-K);$.max.set(H,K)};this.setClearColorHex=function(a,b){console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");this.setClearColor(a,b)};this.getMaxAnisotropy=function(){return 0};this.clear=function(){x.setTransform(1,0,0,-1,H,K);!1===$.empty()&&($.intersect(Ba),$.expandByScalar(2),
1>F&&x.clearRect($.min.x|0,$.min.y|0,$.max.x-$.min.x|0,$.max.y-$.min.y|0),0<F&&(q(THREE.NormalBlending),n(1),v("rgba("+Math.floor(255*N.r)+","+Math.floor(255*N.g)+","+Math.floor(255*N.b)+","+F+")"),x.fillRect($.min.x|0,$.min.y|0,$.max.x-$.min.x|0,$.max.y-$.min.y|0)),$.makeEmpty())};this.clearColor=function(){};this.clearDepth=function(){};this.clearStencil=function(){};this.render=function(a,m){if(!1===m instanceof THREE.Camera)console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
else{!0===this.autoClear&&this.clear();x.setTransform(1,0,0,-1,H,K);y.info.render.vertices=0;y.info.render.faces=0;E=J.projectScene(a,m,this.sortObjects,this.sortElements);z=E.elements;P=E.lights;fa=m;La.getNormalMatrix(m.matrixWorldInverse);hb.setRGB(0,0,0);zb.setRGB(0,0,0);ua.setRGB(0,0,0);for(var A=0,M=P.length;A<M;A++){var C=P[A],F=C.color;C instanceof THREE.AmbientLight?hb.add(F):C instanceof THREE.DirectionalLight?zb.add(F):C instanceof THREE.PointLight&&ua.add(F)}A=0;for(M=z.length;A<M;A++){var D=
z[A],B=D.material;if(void 0!==B&&!1!==B.visible){ja.makeEmpty();if(D instanceof THREE.RenderableSprite){V=D;V.x*=H;V.y*=K;C=V;F=B;n(F.opacity);q(F.blending);var N=D.scale.x*H,D=D.scale.y*K,B=0.5*Math.sqrt(N*N+D*D);ja.min.set(C.x-B,C.y-B);ja.max.set(C.x+B,C.y+B);if(!1===Ba.isIntersectionBox(ja))ja.makeEmpty();else if(F instanceof THREE.SpriteMaterial||F instanceof THREE.ParticleSystemMaterial){var G=F.map;if(null!==G){!1===G.hasEventListener("update",e)&&(void 0!==G.image&&0<G.image.width&&f(G),G.addEventListener("update",
e));B=Za[G.id];void 0!==B?v(B):v("rgba( 0, 0, 0, 1 )");var Q=G.image,B=Q.width*G.offset.x,S=Q.height*G.offset.y,Y=Q.width*G.repeat.x,G=Q.height*G.repeat.y,Q=N/Y,U=D/G;x.save();x.translate(C.x,C.y);0!==F.rotation&&x.rotate(F.rotation);x.translate(-N/2,-D/2);x.scale(Q,U);x.translate(-B,-S);x.fillRect(B,S,Y,G)}else v(F.color.getStyle()),x.save(),x.translate(C.x,C.y),0!==F.rotation&&x.rotate(F.rotation),x.scale(N,-D),x.fillRect(-0.5,-0.5,1,1);x.restore()}else F instanceof THREE.SpriteCanvasMaterial&&
(p(F.color.getStyle()),v(F.color.getStyle()),x.save(),x.translate(C.x,C.y),0!==F.rotation&&x.rotate(F.rotation),x.scale(N,D),F.program(x),x.restore())}else if(D instanceof THREE.RenderableLine){if(V=D.v1,I=D.v2,V.positionScreen.x*=H,V.positionScreen.y*=K,I.positionScreen.x*=H,I.positionScreen.y*=K,ja.setFromPoints([V.positionScreen,I.positionScreen]),!0===Ba.isIntersectionBox(ja))if(C=V,F=I,N=D,D=B,n(D.opacity),q(D.blending),x.beginPath(),x.moveTo(C.positionScreen.x,C.positionScreen.y),x.lineTo(F.positionScreen.x,
F.positionScreen.y),D instanceof THREE.LineBasicMaterial){s(D.linewidth);u(D.linecap);t(D.linejoin);if(D.vertexColors!==THREE.VertexColors)p(D.color.getStyle());else if(B=N.vertexColors[0].getStyle(),N=N.vertexColors[1].getStyle(),B===N)p(B);else{try{var ga=x.createLinearGradient(C.positionScreen.x,C.positionScreen.y,F.positionScreen.x,F.positionScreen.y);ga.addColorStop(0,B);ga.addColorStop(1,N)}catch(la){ga=B}p(ga)}x.stroke();ja.expandByScalar(2*D.linewidth)}else D instanceof THREE.LineDashedMaterial&&
(s(D.linewidth),u(D.linecap),t(D.linejoin),p(D.color.getStyle()),w(D.dashSize,D.gapSize),x.stroke(),ja.expandByScalar(2*D.linewidth),w(null,null))}else if(D instanceof THREE.RenderableFace3){V=D.v1;I=D.v2;R=D.v3;if(-1>V.positionScreen.z||1<V.positionScreen.z)continue;if(-1>I.positionScreen.z||1<I.positionScreen.z)continue;if(-1>R.positionScreen.z||1<R.positionScreen.z)continue;V.positionScreen.x*=H;V.positionScreen.y*=K;I.positionScreen.x*=H;I.positionScreen.y*=K;R.positionScreen.x*=H;R.positionScreen.y*=
K;0<B.overdraw&&(l(V.positionScreen,I.positionScreen,B.overdraw),l(I.positionScreen,R.positionScreen,B.overdraw),l(R.positionScreen,V.positionScreen,B.overdraw));ja.setFromPoints([V.positionScreen,I.positionScreen,R.positionScreen]);if(!0===Ba.isIntersectionBox(ja)){C=V;F=I;N=R;y.info.render.vertices+=3;y.info.render.faces++;n(B.opacity);q(B.blending);Z=C.positionScreen.x;T=C.positionScreen.y;Ia=F.positionScreen.x;va=F.positionScreen.y;wa=N.positionScreen.x;Ca=N.positionScreen.y;var S=Z,Y=T,G=Ia,
Q=va,U=wa,tc=Ca;x.beginPath();x.moveTo(S,Y);x.lineTo(G,Q);x.lineTo(U,tc);x.closePath();(B instanceof THREE.MeshLambertMaterial||B instanceof THREE.MeshPhongMaterial)&&null===B.map?(Da.copy(B.color),Ha.copy(B.emissive),B.vertexColors===THREE.FaceColors&&Da.multiply(D.color),!1===B.wireframe&&B.shading===THREE.SmoothShading&&3===D.vertexNormalsLength?(za.copy(hb),xa.copy(hb),ya.copy(hb),b(D.v1.positionWorld,D.vertexNormalsModel[0],za),b(D.v2.positionWorld,D.vertexNormalsModel[1],xa),b(D.v3.positionWorld,
D.vertexNormalsModel[2],ya),za.multiply(Da).add(Ha),xa.multiply(Da).add(Ha),ya.multiply(Da).add(Ha),Ma.addColors(xa,ya).multiplyScalar(0.5),ma=k(za,xa,ya,Ma),h(Z,T,Ia,va,wa,Ca,0,0,1,0,0,1,ma)):(da.copy(hb),b(D.centroidModel,D.normalModel,da),da.multiply(Da).add(Ha),!0===B.wireframe?c(da,B.wireframeLinewidth,B.wireframeLinecap,B.wireframeLinejoin):d(da))):B instanceof THREE.MeshBasicMaterial||B instanceof THREE.MeshLambertMaterial||B instanceof THREE.MeshPhongMaterial?null!==B.map?B.map.mapping instanceof
THREE.UVMapping&&(pa=D.uvs[0],g(Z,T,Ia,va,wa,Ca,pa[0].x,pa[0].y,pa[1].x,pa[1].y,pa[2].x,pa[2].y,B.map)):null!==B.envMap?B.envMap.mapping instanceof THREE.SphericalReflectionMapping&&(ha.copy(D.vertexNormalsModel[0]).applyMatrix3(La),qa=0.5*ha.x+0.5,Oa=0.5*ha.y+0.5,ha.copy(D.vertexNormalsModel[1]).applyMatrix3(La),Pa=0.5*ha.x+0.5,Qa=0.5*ha.y+0.5,ha.copy(D.vertexNormalsModel[2]).applyMatrix3(La),Aa=0.5*ha.x+0.5,Ra=0.5*ha.y+0.5,g(Z,T,Ia,va,wa,Ca,qa,Oa,Pa,Qa,Aa,Ra,B.envMap)):(da.copy(B.color),B.vertexColors===
THREE.FaceColors&&da.multiply(D.color),!0===B.wireframe?c(da,B.wireframeLinewidth,B.wireframeLinecap,B.wireframeLinejoin):d(da)):B instanceof THREE.MeshDepthMaterial?(Ja=fa.near,Ea=fa.far,za.r=za.g=za.b=1-r(C.positionScreen.z*C.positionScreen.w,Ja,Ea),xa.r=xa.g=xa.b=1-r(F.positionScreen.z*F.positionScreen.w,Ja,Ea),ya.r=ya.g=ya.b=1-r(N.positionScreen.z*N.positionScreen.w,Ja,Ea),Ma.addColors(xa,ya).multiplyScalar(0.5),ma=k(za,xa,ya,Ma),h(Z,T,Ia,va,wa,Ca,0,0,1,0,0,1,ma)):B instanceof THREE.MeshNormalMaterial&&
(B.shading===THREE.FlatShading?(ha.copy(D.normalModel).applyMatrix3(La),da.setRGB(ha.x,ha.y,ha.z).multiplyScalar(0.5).addScalar(0.5),!0===B.wireframe?c(da,B.wireframeLinewidth,B.wireframeLinecap,B.wireframeLinejoin):d(da)):B.shading===THREE.SmoothShading&&(ha.copy(D.vertexNormalsModel[0]).applyMatrix3(La),za.setRGB(ha.x,ha.y,ha.z).multiplyScalar(0.5).addScalar(0.5),ha.copy(D.vertexNormalsModel[1]).applyMatrix3(La),xa.setRGB(ha.x,ha.y,ha.z).multiplyScalar(0.5).addScalar(0.5),ha.copy(D.vertexNormalsModel[2]).applyMatrix3(La),
ya.setRGB(ha.x,ha.y,ha.z).multiplyScalar(0.5).addScalar(0.5),Ma.addColors(xa,ya).multiplyScalar(0.5),ma=k(za,xa,ya,Ma),h(Z,T,Ia,va,wa,Ca,0,0,1,0,0,1,ma)))}}$.union(ja)}}x.setTransform(1,0,0,1,0,0)}}};THREE.ShaderChunk={fog_pars_fragment:"#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",fog_fragment:"#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
envmap_pars_fragment:"#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",envmap_fragment:"#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
envmap_pars_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
envmap_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",map_particle_pars_fragment:"#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_particle_fragment:"#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",map_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",map_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",map_fragment:"#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",lightmap_pars_vertex:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
lightmap_fragment:"#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",lightmap_vertex:"#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",lights_lambert_pars_vertex:"uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
lights_lambert_vertex:"vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
lights_phong_pars_vertex:"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",lights_phong_vertex:"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",lights_phong_pars_fragment:"uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
lights_phong_fragment:"vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
color_pars_fragment:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_fragment:"#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",color_pars_vertex:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
skinbase_vertex:"#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif",
morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
default_vertex:"vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
skinnormal_vertex:"#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",defaultnormal_vertex:"vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",shadowmap_fragment:"#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",alphatest_fragment:"#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",linear_to_gamma_fragment:"#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"};THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};THREE.UniformsLib={common:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:"t",value:null},specularMap:{type:"t",value:null},envMap:{type:"t",value:null},flipEnvMap:{type:"f",value:-1},useRefract:{type:"i",value:0},reflectivity:{type:"f",value:1},refractionRatio:{type:"f",value:0.98},combine:{type:"i",value:0},morphTargetInfluences:{type:"f",value:0}},bump:{bumpMap:{type:"t",
value:null},bumpScale:{type:"f",value:1}},normalmap:{normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:"fv",value:[]},directionalLightDirection:{type:"fv",value:[]},directionalLightColor:{type:"fv",value:[]},hemisphereLightDirection:{type:"fv",value:[]},hemisphereLightSkyColor:{type:"fv",
value:[]},hemisphereLightGroundColor:{type:"fv",value:[]},pointLightColor:{type:"fv",value:[]},pointLightPosition:{type:"fv",value:[]},pointLightDistance:{type:"fv1",value:[]},spotLightColor:{type:"fv",value:[]},spotLightPosition:{type:"fv",value:[]},spotLightDirection:{type:"fv",value:[]},spotLightDistance:{type:"fv1",value:[]},spotLightAngleCos:{type:"fv1",value:[]},spotLightExponent:{type:"fv1",value:[]}},particle:{psColor:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},size:{type:"f",
value:1},scale:{type:"f",value:1},map:{type:"t",value:null},fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:"tv",value:[]},shadowMapSize:{type:"v2v",value:[]},shadowBias:{type:"fv1",value:[]},shadowDarkness:{type:"fv1",value:[]},shadowMatrix:{type:"m4v",value:[]}}};THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,
THREE.ShaderChunk.skinbase_vertex,"#ifdef USE_ENVMAP",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"#endif",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,
THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,
THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",
THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,
THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,
THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,"#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif",THREE.ShaderChunk.lightmap_fragment,
THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},specular:{type:"c",
value:new THREE.Color(1118481)},shininess:{type:"f",value:30},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,
"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"vNormal = normalize( transformedNormal );",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"vViewPosition = -mvPosition.xyz;",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,
THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,
THREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,
THREE.ShaderChunk.fog_fragment,"}"].join("\n")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:["uniform float size;\nuniform float scale;",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;",
THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 psColor;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,"void main() {\ngl_FragColor = vec4( psColor, opacity );",THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,
THREE.ShaderChunk.fog_fragment,"}"].join("\n")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,{scale:{type:"f",value:1},dashSize:{type:"f",value:1},totalSize:{type:"f",value:2}}]),vertexShader:["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},depth:{uniforms:{mNear:{type:"f",value:1},mFar:{type:"f",value:2E3},opacity:{type:"f",
value:1}},vertexShader:"void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"},normal:{uniforms:{opacity:{type:"f",value:1}},vertexShader:["varying vec3 vNormal;",THREE.ShaderChunk.morphtarget_pars_vertex,"void main() {\nvNormal = normalize( normalMatrix * normal );",
THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,"}"].join("\n"),fragmentShader:"uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:"i",value:0},enableDiffuse:{type:"i",value:0},enableSpecular:{type:"i",value:0},enableReflection:{type:"i",value:0},enableDisplacement:{type:"i",
value:0},tDisplacement:{type:"t",value:null},tDiffuse:{type:"t",value:null},tCube:{type:"t",value:null},tNormal:{type:"t",value:null},tSpecular:{type:"t",value:null},tAO:{type:"t",value:null},uNormalScale:{type:"v2",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:"f",value:0},uDisplacementScale:{type:"f",value:1},diffuse:{type:"c",value:new THREE.Color(16777215)},specular:{type:"c",value:new THREE.Color(1118481)},ambient:{type:"c",value:new THREE.Color(16777215)},shininess:{type:"f",value:30},
opacity:{type:"f",value:1},useRefract:{type:"i",value:0},refractionRatio:{type:"f",value:0.98},reflectivity:{type:"f",value:0.5},uOffset:{type:"v2",value:new THREE.Vector2(0,0)},uRepeat:{type:"v2",value:new THREE.Vector2(1,1)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}",
THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n"),vertexShader:["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,"#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")},
cube:{uniforms:{tCube:{type:"t",value:null},tFlip:{type:"f",value:-1}},vertexShader:"varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"},
depthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"}"].join("\n"),fragmentShader:"vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"}};THREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;"v2"===f.type?g=2:"v3"===f.type?g=3:"v4"===f.type?g=4:"c"===f.type&&(g=3);f.size=g;f.array=new Float32Array(c*g);f.buffer=m.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}
function c(a,b){var c=b.geometry,g=a.faces3,h=3*g.length,k=1*g.length,l=3*g.length,g=d(b,a),p=f(g),n=e(g),q=g.vertexColors?g.vertexColors:!1;a.__vertexArray=new Float32Array(3*h);n&&(a.__normalArray=new Float32Array(3*h));c.hasTangents&&(a.__tangentArray=new Float32Array(4*h));q&&(a.__colorArray=new Float32Array(3*h));p&&(0<c.faceVertexUvs.length&&(a.__uvArray=new Float32Array(2*h)),1<c.faceVertexUvs.length&&(a.__uv2Array=new Float32Array(2*h)));b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&
(a.__skinIndexArray=new Float32Array(4*h),a.__skinWeightArray=new Float32Array(4*h));a.__faceArray=new Uint16Array(3*k);a.__lineArray=new Uint16Array(2*l);if(a.numMorphTargets)for(a.__morphTargetsArrays=[],c=0,p=a.numMorphTargets;c<p;c++)a.__morphTargetsArrays.push(new Float32Array(3*h));if(a.numMorphNormals)for(a.__morphNormalsArrays=[],c=0,p=a.numMorphNormals;c<p;c++)a.__morphNormalsArrays.push(new Float32Array(3*h));a.__webglFaceCount=3*k;a.__webglLineCount=2*l;if(g.attributes){void 0===a.__webglCustomAttributesList&&
(a.__webglCustomAttributesList=[]);for(var r in g.attributes){var k=g.attributes[r],l={},s;for(s in k)l[s]=k[s];if(!l.__webglInitialized||l.createUniqueBuffers)l.__webglInitialized=!0,c=1,"v2"===l.type?c=2:"v3"===l.type?c=3:"v4"===l.type?c=4:"c"===l.type&&(c=3),l.size=c,l.array=new Float32Array(h*c),l.buffer=m.createBuffer(),l.buffer.belongsToAttribute=r,k.needsUpdate=!0,l.__original=k;a.__webglCustomAttributesList.push(l)}}a.__inittedArrays=!0}function d(a,b){return a.material instanceof THREE.MeshFaceMaterial?
a.material.materials[b.materialIndex]:a.material}function e(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function f(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a instanceof THREE.ShaderMaterial?!0:!1}function g(a,b,c,d){var e,f,g,k;for(f in b)g=b[f],e=c[f],0<=g&&(e?(k=e.itemSize,m.bindBuffer(m.ARRAY_BUFFER,e.buffer),h(g),m.vertexAttribPointer(g,
k,m.FLOAT,!1,0,d*k*4)):a.defaultAttributeValues&&(2===a.defaultAttributeValues[f].length?m.vertexAttrib2fv(g,a.defaultAttributeValues[f]):3===a.defaultAttributeValues[f].length&&m.vertexAttrib3fv(g,a.defaultAttributeValues[f])))}function h(a){$[a]||(m.enableVertexAttribArray(a),$[a]=!0)}function k(){for(var a in $)$[a]&&(m.disableVertexAttribArray(a),$[a]=!1)}function l(a,b){return a.z!==b.z?b.z-a.z:a.id-b.id}function n(a,b){return b[0]-a[0]}function q(a,b,c){if(a.length)for(var d=0,e=a.length;d<
e;d++)Ca=T=null,va=wa=ya=xa=Ja=Za=Ma=-1,ha=!0,a[d].render(b,c,Ra,Ba),Ca=T=null,va=wa=ya=xa=Ja=Za=Ma=-1,ha=!0}function s(a,b,c,d,e,f,g,h){var m,k,l,p;b?(k=a.length-1,p=b=-1):(k=0,b=a.length,p=1);for(var n=k;n!==b;n+=p)if(m=a[n],m.render){k=m.object;l=m.buffer;if(h)m=h;else{m=m[c];if(!m)continue;g&&I.setBlending(m.blending,m.blendEquation,m.blendSrc,m.blendDst);I.setDepthTest(m.depthTest);I.setDepthWrite(m.depthWrite);M(m.polygonOffset,m.polygonOffsetFactor,m.polygonOffsetUnits)}I.setMaterialFaces(m);
l instanceof THREE.BufferGeometry?I.renderBufferDirect(d,e,f,m,l,k):I.renderBuffer(d,e,f,m,l,k)}}function u(a,b,c,d,e,f,g){for(var h,m,k=0,l=a.length;k<l;k++)if(h=a[k],m=h.object,m.visible){if(g)h=g;else{h=h[b];if(!h)continue;f&&I.setBlending(h.blending,h.blendEquation,h.blendSrc,h.blendDst);I.setDepthTest(h.depthTest);I.setDepthWrite(h.depthWrite);M(h.polygonOffset,h.polygonOffsetFactor,h.polygonOffsetUnits)}I.renderImmediateObject(c,d,e,h,m)}}function t(a,d){var e,f,g,h;if(void 0===a.__webglInit&&
(a.__webglInit=!0,a._modelViewMatrix=new THREE.Matrix4,a._normalMatrix=new THREE.Matrix3,void 0!==a.geometry&&void 0===a.geometry.__webglInit&&(a.geometry.__webglInit=!0,a.geometry.addEventListener("dispose",Lb)),f=a.geometry,void 0!==f))if(f instanceof THREE.BufferGeometry){var k,l;for(k in f.attributes)l="index"===k?m.ELEMENT_ARRAY_BUFFER:m.ARRAY_BUFFER,h=f.attributes[k],h.buffer=m.createBuffer(),m.bindBuffer(l,h.buffer),m.bufferData(l,h.array,m.STATIC_DRAW)}else if(a instanceof THREE.Mesh){g=a.material;
if(void 0===f.geometryGroups){k=f;var n,q,r;l={};var s=k.morphTargets.length,u=k.morphNormals.length,t=g instanceof THREE.MeshFaceMaterial;k.geometryGroups={};g=0;for(n=k.faces.length;g<n;g++)q=k.faces[g],q=t?q.materialIndex:0,void 0===l[q]&&(l[q]={hash:q,counter:0}),r=l[q].hash+"_"+l[q].counter,void 0===k.geometryGroups[r]&&(k.geometryGroups[r]={faces3:[],materialIndex:q,vertices:0,numMorphTargets:s,numMorphNormals:u}),65535<k.geometryGroups[r].vertices+3&&(l[q].counter+=1,r=l[q].hash+"_"+l[q].counter,
void 0===k.geometryGroups[r]&&(k.geometryGroups[r]={faces3:[],materialIndex:q,vertices:0,numMorphTargets:s,numMorphNormals:u})),k.geometryGroups[r].faces3.push(g),k.geometryGroups[r].vertices+=3;k.geometryGroupsList=[];for(h in k.geometryGroups)k.geometryGroups[h].id=da++,k.geometryGroupsList.push(k.geometryGroups[h])}for(e in f.geometryGroups)if(h=f.geometryGroups[e],!h.__webglVertexBuffer){k=h;k.__webglVertexBuffer=m.createBuffer();k.__webglNormalBuffer=m.createBuffer();k.__webglTangentBuffer=m.createBuffer();
k.__webglColorBuffer=m.createBuffer();k.__webglUVBuffer=m.createBuffer();k.__webglUV2Buffer=m.createBuffer();k.__webglSkinIndicesBuffer=m.createBuffer();k.__webglSkinWeightsBuffer=m.createBuffer();k.__webglFaceBuffer=m.createBuffer();k.__webglLineBuffer=m.createBuffer();s=l=void 0;if(k.numMorphTargets)for(k.__webglMorphTargetsBuffers=[],l=0,s=k.numMorphTargets;l<s;l++)k.__webglMorphTargetsBuffers.push(m.createBuffer());if(k.numMorphNormals)for(k.__webglMorphNormalsBuffers=[],l=0,s=k.numMorphNormals;l<
s;l++)k.__webglMorphNormalsBuffers.push(m.createBuffer());I.info.memory.geometries++;c(h,a);f.verticesNeedUpdate=!0;f.morphTargetsNeedUpdate=!0;f.elementsNeedUpdate=!0;f.uvsNeedUpdate=!0;f.normalsNeedUpdate=!0;f.tangentsNeedUpdate=!0;f.colorsNeedUpdate=!0}}else a instanceof THREE.Line?f.__webglVertexBuffer||(h=f,h.__webglVertexBuffer=m.createBuffer(),h.__webglColorBuffer=m.createBuffer(),h.__webglLineDistanceBuffer=m.createBuffer(),I.info.memory.geometries++,h=f,k=h.vertices.length,h.__vertexArray=
new Float32Array(3*k),h.__colorArray=new Float32Array(3*k),h.__lineDistanceArray=new Float32Array(1*k),h.__webglLineCount=k,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0,f.lineDistancesNeedUpdate=!0):a instanceof THREE.ParticleSystem&&!f.__webglVertexBuffer&&(h=f,h.__webglVertexBuffer=m.createBuffer(),h.__webglColorBuffer=m.createBuffer(),I.info.memory.geometries++,h=f,k=h.vertices.length,h.__vertexArray=new Float32Array(3*k),h.__colorArray=new Float32Array(3*k),h.__sortArray=[],h.__webglParticleCount=
k,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0);if(void 0===a.__webglActive){if(a instanceof THREE.Mesh)if(f=a.geometry,f instanceof THREE.BufferGeometry)p(d.__webglObjects,f,a);else{if(f instanceof THREE.Geometry)for(e in f.geometryGroups)h=f.geometryGroups[e],p(d.__webglObjects,h,a)}else a instanceof THREE.Line||a instanceof THREE.ParticleSystem?(f=a.geometry,p(d.__webglObjects,f,a)):a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback?d.__webglObjectsImmediate.push({id:null,
object:a,opaque:null,transparent:null,z:0}):a instanceof THREE.Sprite?d.__webglSprites.push(a):a instanceof THREE.LensFlare&&d.__webglFlares.push(a);a.__webglActive=!0}}function p(a,b,c){a.push({id:null,buffer:b,object:c,opaque:null,transparent:null,z:0})}function v(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;return!1}function w(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function r(a,b){a instanceof THREE.Mesh||a instanceof THREE.ParticleSystem||a instanceof
THREE.Line?y(b.__webglObjects,a):a instanceof THREE.Sprite?E(b.__webglSprites,a):a instanceof THREE.LensFlare?E(b.__webglFlares,a):(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&y(b.__webglObjectsImmediate,a);delete a.__webglActive}function y(a,b){for(var c=a.length-1;0<=c;c--)a[c].object===b&&a.splice(c,1)}function E(a,b){for(var c=a.length-1;0<=c;c--)a[c]===b&&a.splice(c,1)}function z(a,b,c,d,e){za=0;d.needsUpdate&&(d.program&&Fb(d),I.initMaterial(d,b,c,e),d.needsUpdate=
!1);d.morphTargets&&!e.__webglMorphTargetInfluences&&(e.__webglMorphTargetInfluences=new Float32Array(I.maxMorphTargets));var f=!1,g=d.program,h=g.uniforms,k=d.uniforms;g!==T&&(m.useProgram(g),T=g,f=!0);d.id!==va&&(va=d.id,f=!0);if(f||a!==Ca)m.uniformMatrix4fv(h.projectionMatrix,!1,a.projectionMatrix.elements),a!==Ca&&(Ca=a);if(d.skinning)if(ub&&e.useVertexTexture){if(null!==h.boneTexture){var l=P();m.uniform1i(h.boneTexture,l);I.setTexture(e.boneTexture,l)}null!==h.boneTextureWidth&&m.uniform1i(h.boneTextureWidth,
e.boneTextureWidth);null!==h.boneTextureHeight&&m.uniform1i(h.boneTextureHeight,e.boneTextureHeight)}else null!==h.boneGlobalMatrices&&m.uniformMatrix4fv(h.boneGlobalMatrices,!1,e.boneMatrices);if(f){c&&d.fog&&(k.fogColor.value=c.color,c instanceof THREE.Fog?(k.fogNear.value=c.near,k.fogFar.value=c.far):c instanceof THREE.FogExp2&&(k.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d.lights){if(ha){var p,n=l=0,q=0,r,s,u,t=La,v=t.directional.colors,
w=t.directional.positions,y=t.point.colors,E=t.point.positions,z=t.point.distances,F=t.spot.colors,C=t.spot.positions,M=t.spot.distances,H=t.spot.directions,N=t.spot.anglesCos,G=t.spot.exponents,R=t.hemi.skyColors,Q=t.hemi.groundColors,K=t.hemi.positions,S=0,Y=0,Z=0,V=0,$=0,cc=0,ba=0,aa=0,da=p=0;c=u=da=0;for(f=b.length;c<f;c++)if(p=b[c],!p.onlyShadow)if(r=p.color,s=p.intensity,u=p.distance,p instanceof THREE.AmbientLight)p.visible&&(I.gammaInput?(l+=r.r*r.r,n+=r.g*r.g,q+=r.b*r.b):(l+=r.r,n+=r.g,q+=
r.b));else if(p instanceof THREE.DirectionalLight){if($+=1,p.visible&&(ga.setFromMatrixPosition(p.matrixWorld),ua.setFromMatrixPosition(p.target.matrixWorld),ga.sub(ua),ga.normalize(),0!==ga.x||0!==ga.y||0!==ga.z))p=3*S,w[p]=ga.x,w[p+1]=ga.y,w[p+2]=ga.z,I.gammaInput?J(v,p,r,s*s):A(v,p,r,s),S+=1}else p instanceof THREE.PointLight?(cc+=1,p.visible&&(da=3*Y,I.gammaInput?J(y,da,r,s*s):A(y,da,r,s),ua.setFromMatrixPosition(p.matrixWorld),E[da]=ua.x,E[da+1]=ua.y,E[da+2]=ua.z,z[Y]=u,Y+=1)):p instanceof THREE.SpotLight?
(ba+=1,p.visible&&(da=3*Z,I.gammaInput?J(F,da,r,s*s):A(F,da,r,s),ua.setFromMatrixPosition(p.matrixWorld),C[da]=ua.x,C[da+1]=ua.y,C[da+2]=ua.z,M[Z]=u,ga.copy(ua),ua.setFromMatrixPosition(p.target.matrixWorld),ga.sub(ua),ga.normalize(),H[da]=ga.x,H[da+1]=ga.y,H[da+2]=ga.z,N[Z]=Math.cos(p.angle),G[Z]=p.exponent,Z+=1)):p instanceof THREE.HemisphereLight&&(aa+=1,p.visible&&(ga.setFromMatrixPosition(p.matrixWorld),ga.normalize(),0!==ga.x||0!==ga.y||0!==ga.z))&&(u=3*V,K[u]=ga.x,K[u+1]=ga.y,K[u+2]=ga.z,r=
p.color,p=p.groundColor,I.gammaInput?(s*=s,J(R,u,r,s),J(Q,u,p,s)):(A(R,u,r,s),A(Q,u,p,s)),V+=1);c=3*S;for(f=Math.max(v.length,3*$);c<f;c++)v[c]=0;c=3*Y;for(f=Math.max(y.length,3*cc);c<f;c++)y[c]=0;c=3*Z;for(f=Math.max(F.length,3*ba);c<f;c++)F[c]=0;c=3*V;for(f=Math.max(R.length,3*aa);c<f;c++)R[c]=0;c=3*V;for(f=Math.max(Q.length,3*aa);c<f;c++)Q[c]=0;t.directional.length=S;t.point.length=Y;t.spot.length=Z;t.hemi.length=V;t.ambient[0]=l;t.ambient[1]=n;t.ambient[2]=q;ha=!1}c=La;k.ambientLightColor.value=
c.ambient;k.directionalLightColor.value=c.directional.colors;k.directionalLightDirection.value=c.directional.positions;k.pointLightColor.value=c.point.colors;k.pointLightPosition.value=c.point.positions;k.pointLightDistance.value=c.point.distances;k.spotLightColor.value=c.spot.colors;k.spotLightPosition.value=c.spot.positions;k.spotLightDistance.value=c.spot.distances;k.spotLightDirection.value=c.spot.directions;k.spotLightAngleCos.value=c.spot.anglesCos;k.spotLightExponent.value=c.spot.exponents;
k.hemisphereLightSkyColor.value=c.hemi.skyColors;k.hemisphereLightGroundColor.value=c.hemi.groundColors;k.hemisphereLightDirection.value=c.hemi.positions}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){k.opacity.value=d.opacity;I.gammaInput?k.diffuse.value.copyGammaToLinear(d.color):k.diffuse.value=d.color;k.map.value=d.map;k.lightMap.value=d.lightMap;k.specularMap.value=d.specularMap;d.bumpMap&&(k.bumpMap.value=d.bumpMap,k.bumpScale.value=
d.bumpScale);d.normalMap&&(k.normalMap.value=d.normalMap,k.normalScale.value.copy(d.normalScale));var U;d.map?U=d.map:d.specularMap?U=d.specularMap:d.normalMap?U=d.normalMap:d.bumpMap&&(U=d.bumpMap);void 0!==U&&(c=U.offset,U=U.repeat,k.offsetRepeat.value.set(c.x,c.y,U.x,U.y));k.envMap.value=d.envMap;k.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?1:-1;k.reflectivity.value=d.reflectivity;k.refractionRatio.value=d.refractionRatio;k.combine.value=d.combine;k.useRefract.value=d.envMap&&
d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(k.diffuse.value=d.color,k.opacity.value=d.opacity):d instanceof THREE.LineDashedMaterial?(k.diffuse.value=d.color,k.opacity.value=d.opacity,k.dashSize.value=d.dashSize,k.totalSize.value=d.dashSize+d.gapSize,k.scale.value=d.scale):d instanceof THREE.ParticleSystemMaterial?(k.psColor.value=d.color,k.opacity.value=d.opacity,k.size.value=d.size,k.scale.value=D.height/2,k.map.value=d.map):d instanceof THREE.MeshPhongMaterial?
(k.shininess.value=d.shininess,I.gammaInput?(k.ambient.value.copyGammaToLinear(d.ambient),k.emissive.value.copyGammaToLinear(d.emissive),k.specular.value.copyGammaToLinear(d.specular)):(k.ambient.value=d.ambient,k.emissive.value=d.emissive,k.specular.value=d.specular),d.wrapAround&&k.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?(I.gammaInput?(k.ambient.value.copyGammaToLinear(d.ambient),k.emissive.value.copyGammaToLinear(d.emissive)):(k.ambient.value=d.ambient,k.emissive.value=
d.emissive),d.wrapAround&&k.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(k.mNear.value=a.near,k.mFar.value=a.far,k.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(k.opacity.value=d.opacity);if(e.receiveShadow&&!d._shadowPass&&k.shadowMatrix)for(c=U=0,f=b.length;c<f;c++)l=b[c],l.castShadow&&(l instanceof THREE.SpotLight||l instanceof THREE.DirectionalLight&&!l.shadowCascade)&&(k.shadowMap.value[U]=l.shadowMap,k.shadowMapSize.value[U]=l.shadowMapSize,k.shadowMatrix.value[U]=
l.shadowMatrix,k.shadowDarkness.value[U]=l.shadowDarkness,k.shadowBias.value[U]=l.shadowBias,U++);b=d.uniformsList;k=0;for(U=b.length;k<U;k++)if(f=g.uniforms[b[k][1]])if(c=b[k][0],n=c.type,l=c.value,"i"===n)m.uniform1i(f,l);else if("f"===n)m.uniform1f(f,l);else if("v2"===n)m.uniform2f(f,l.x,l.y);else if("v3"===n)m.uniform3f(f,l.x,l.y,l.z);else if("v4"===n)m.uniform4f(f,l.x,l.y,l.z,l.w);else if("c"===n)m.uniform3f(f,l.r,l.g,l.b);else if("iv1"===n)m.uniform1iv(f,l);else if("iv"===n)m.uniform3iv(f,l);
else if("fv1"===n)m.uniform1fv(f,l);else if("fv"===n)m.uniform3fv(f,l);else if("v2v"===n){void 0===c._array&&(c._array=new Float32Array(2*l.length));n=0;for(q=l.length;n<q;n++)t=2*n,c._array[t]=l[n].x,c._array[t+1]=l[n].y;m.uniform2fv(f,c._array)}else if("v3v"===n){void 0===c._array&&(c._array=new Float32Array(3*l.length));n=0;for(q=l.length;n<q;n++)t=3*n,c._array[t]=l[n].x,c._array[t+1]=l[n].y,c._array[t+2]=l[n].z;m.uniform3fv(f,c._array)}else if("v4v"===n){void 0===c._array&&(c._array=new Float32Array(4*
l.length));n=0;for(q=l.length;n<q;n++)t=4*n,c._array[t]=l[n].x,c._array[t+1]=l[n].y,c._array[t+2]=l[n].z,c._array[t+3]=l[n].w;m.uniform4fv(f,c._array)}else if("m4"===n)void 0===c._array&&(c._array=new Float32Array(16)),l.flattenToArray(c._array),m.uniformMatrix4fv(f,!1,c._array);else if("m4v"===n){void 0===c._array&&(c._array=new Float32Array(16*l.length));n=0;for(q=l.length;n<q;n++)l[n].flattenToArrayOffset(c._array,16*n);m.uniformMatrix4fv(f,!1,c._array)}else if("t"===n){if(t=l,l=P(),m.uniform1i(f,
l),t)if(t.image instanceof Array&&6===t.image.length){if(c=t,f=l,6===c.image.length)if(c.needsUpdate){c.image.__webglTextureCube||(c.addEventListener("dispose",Db),c.image.__webglTextureCube=m.createTexture(),I.info.memory.textures++);m.activeTexture(m.TEXTURE0+f);m.bindTexture(m.TEXTURE_CUBE_MAP,c.image.__webglTextureCube);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,c.flipY);f=c instanceof THREE.CompressedTexture;l=[];for(n=0;6>n;n++)I.autoScaleCubemaps&&!f?(q=l,t=n,v=c.image[n],y=Yb,v.width<=y&&v.height<=
y||(E=Math.max(v.width,v.height),w=Math.floor(v.width*y/E),y=Math.floor(v.height*y/E),E=document.createElement("canvas"),E.width=w,E.height=y,E.getContext("2d").drawImage(v,0,0,v.width,v.height,0,0,w,y),v=E),q[t]=v):l[n]=c.image[n];n=l[0];q=THREE.Math.isPowerOfTwo(n.width)&&THREE.Math.isPowerOfTwo(n.height);t=B(c.format);v=B(c.type);x(m.TEXTURE_CUBE_MAP,c,q);for(n=0;6>n;n++)if(f)for(y=l[n].mipmaps,E=0,z=y.length;E<z;E++)w=y[E],c.format!==THREE.RGBAFormat?m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+
n,E,t,w.width,w.height,0,w.data):m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+n,E,t,w.width,w.height,0,t,v,w.data);else m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,t,t,v,l[n]);c.generateMipmaps&&q&&m.generateMipmap(m.TEXTURE_CUBE_MAP);c.needsUpdate=!1;if(c.onUpdate)c.onUpdate()}else m.activeTexture(m.TEXTURE0+f),m.bindTexture(m.TEXTURE_CUBE_MAP,c.image.__webglTextureCube)}else t instanceof THREE.WebGLRenderTargetCube?(c=t,m.activeTexture(m.TEXTURE0+l),m.bindTexture(m.TEXTURE_CUBE_MAP,c.__webglTexture)):
I.setTexture(t,l)}else if("tv"===n){void 0===c._array&&(c._array=[]);n=0;for(q=c.value.length;n<q;n++)c._array[n]=P();m.uniform1iv(f,c._array);n=0;for(q=c.value.length;n<q;n++)t=c.value[n],l=c._array[n],t&&I.setTexture(t,l)}else console.warn("THREE.WebGLRenderer: Unknown uniform type: "+n);(d instanceof THREE.ShaderMaterial||d instanceof THREE.MeshPhongMaterial||d.envMap)&&null!==h.cameraPosition&&(ua.setFromMatrixPosition(a.matrixWorld),m.uniform3f(h.cameraPosition,ua.x,ua.y,ua.z));(d instanceof
THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.skinning)&&null!==h.viewMatrix&&m.uniformMatrix4fv(h.viewMatrix,!1,a.matrixWorldInverse.elements)}m.uniformMatrix4fv(h.modelViewMatrix,!1,e._modelViewMatrix.elements);h.normalMatrix&&m.uniformMatrix3fv(h.normalMatrix,!1,e._normalMatrix.elements);null!==h.modelMatrix&&m.uniformMatrix4fv(h.modelMatrix,!1,e.matrixWorld.elements);return g}function P(){var a=za;a>=ib&&console.warn("WebGLRenderer: trying to use "+
a+" texture units while this GPU supports only "+ib);za+=1;return a}function J(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*d;a[b+2]=c.b*c.b*d}function A(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function C(a){a!==qa&&(m.lineWidth(a),qa=a)}function M(a,b,c){Ea!==a&&(a?m.enable(m.POLYGON_OFFSET_FILL):m.disable(m.POLYGON_OFFSET_FILL),Ea=a);!a||ma===b&&pa===c||(m.polygonOffset(b,c),ma=b,pa=c)}function H(a){a=a.split("\n");for(var b=0,c=a.length;b<c;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function K(a,
b){var c;"fragment"===a?c=m.createShader(m.FRAGMENT_SHADER):"vertex"===a&&(c=m.createShader(m.VERTEX_SHADER));m.shaderSource(c,b);m.compileShader(c);return m.getShaderParameter(c,m.COMPILE_STATUS)?c:(console.error(m.getShaderInfoLog(c)),console.error(H(b)),null)}function x(a,b,c){c?(m.texParameteri(a,m.TEXTURE_WRAP_S,B(b.wrapS)),m.texParameteri(a,m.TEXTURE_WRAP_T,B(b.wrapT)),m.texParameteri(a,m.TEXTURE_MAG_FILTER,B(b.magFilter)),m.texParameteri(a,m.TEXTURE_MIN_FILTER,B(b.minFilter))):(m.texParameteri(a,
m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),m.texParameteri(a,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),m.texParameteri(a,m.TEXTURE_MAG_FILTER,F(b.magFilter)),m.texParameteri(a,m.TEXTURE_MIN_FILTER,F(b.minFilter)));ea&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy)&&(m.texParameterf(a,ea.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Cb)),b.__oldAnisotropy=b.anisotropy)}function N(a,b){m.bindRenderbuffer(m.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_COMPONENT16,
b.width,b.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(m.renderbufferStorage(m.RENDERBUFFER,m.DEPTH_STENCIL,b.width,b.height),m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.RENDERBUFFER,a)):m.renderbufferStorage(m.RENDERBUFFER,m.RGBA4,b.width,b.height)}function F(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?m.NEAREST:m.LINEAR}function B(a){if(a===
THREE.RepeatWrapping)return m.REPEAT;if(a===THREE.ClampToEdgeWrapping)return m.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return m.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return m.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return m.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return m.NEAREST_MIPMAP_LINEAR;if(a===THREE.LinearFilter)return m.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return m.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return m.LINEAR_MIPMAP_LINEAR;
if(a===THREE.UnsignedByteType)return m.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return m.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return m.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return m.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return m.BYTE;if(a===THREE.ShortType)return m.SHORT;if(a===THREE.UnsignedShortType)return m.UNSIGNED_SHORT;if(a===THREE.IntType)return m.INT;if(a===THREE.UnsignedIntType)return m.UNSIGNED_INT;if(a===THREE.FloatType)return m.FLOAT;
if(a===THREE.AlphaFormat)return m.ALPHA;if(a===THREE.RGBFormat)return m.RGB;if(a===THREE.RGBAFormat)return m.RGBA;if(a===THREE.LuminanceFormat)return m.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return m.LUMINANCE_ALPHA;if(a===THREE.AddEquation)return m.FUNC_ADD;if(a===THREE.SubtractEquation)return m.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return m.FUNC_REVERSE_SUBTRACT;if(a===THREE.ZeroFactor)return m.ZERO;if(a===THREE.OneFactor)return m.ONE;if(a===THREE.SrcColorFactor)return m.SRC_COLOR;
if(a===THREE.OneMinusSrcColorFactor)return m.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return m.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return m.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return m.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return m.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return m.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return m.ONE_MINUS_DST_COLOR;if(a===THREE.SrcAlphaSaturateFactor)return m.SRC_ALPHA_SATURATE;if(void 0!==Ka){if(a===THREE.RGB_S3TC_DXT1_Format)return Ka.COMPRESSED_RGB_S3TC_DXT1_EXT;
if(a===THREE.RGBA_S3TC_DXT1_Format)return Ka.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return Ka.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return Ka.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}console.log("THREE.WebGLRenderer",THREE.REVISION);a=a||{};var D=void 0!==a.canvas?a.canvas:document.createElement("canvas"),G=void 0!==a.context?a.context:null,Y=void 0!==a.precision?a.precision:"highp",S=void 0!==a.alpha?a.alpha:!1,la=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:
!0,U=void 0!==a.antialias?a.antialias:!1,oa=void 0!==a.stencil?a.stencil:!0,Q=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,fa=new THREE.Color(0),V=0;this.domElement=D;this.context=null;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.autoUpdateObjects=this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.gammaOutput=this.gammaInput=!1;
this.shadowMapAutoUpdate=!0;this.shadowMapType=THREE.PCFShadowMap;this.shadowMapCullFace=THREE.CullFaceFront;this.shadowMapCascade=this.shadowMapDebug=!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var I=this,R=[],Z=0,T=null,Ia=null,va=-1,wa=null,Ca=null,da=0,za=0,xa=-1,ya=-1,Ma=-1,Da=-1,Ha=-1,Na=-1,Za=-1,Ja=-1,Ea=null,
ma=null,pa=null,qa=null,Oa=0,Pa=0,Qa=D.width,Aa=D.height,Ra=0,Ba=0,$={},ja=new THREE.Frustum,hb=new THREE.Matrix4,zb=new THREE.Matrix4,ua=new THREE.Vector3,ga=new THREE.Vector3,ha=!0,La={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],anglesCos:[],exponents:[]},hemi:{length:0,skyColors:[],groundColors:[],positions:[]}},m,Sa,Wa,ea,Ka;(function(){try{var a={alpha:S,premultipliedAlpha:la,
antialias:U,stencil:oa,preserveDrawingBuffer:Q};m=G||D.getContext("webgl",a)||D.getContext("experimental-webgl",a);if(null===m)throw"Error creating WebGL context.";}catch(b){console.error(b)}Sa=m.getExtension("OES_texture_float");m.getExtension("OES_texture_float_linear");Wa=m.getExtension("OES_standard_derivatives");ea=m.getExtension("EXT_texture_filter_anisotropic")||m.getExtension("MOZ_EXT_texture_filter_anisotropic")||m.getExtension("WEBKIT_EXT_texture_filter_anisotropic");Ka=m.getExtension("WEBGL_compressed_texture_s3tc")||
m.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||m.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");Sa||console.log("THREE.WebGLRenderer: Float textures not supported.");Wa||console.log("THREE.WebGLRenderer: Standard derivatives not supported.");ea||console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");Ka||console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");void 0===m.getShaderPrecisionFormat&&(m.getShaderPrecisionFormat=function(){return{rangeMin:1,
rangeMax:1,precision:1}})})();m.clearColor(0,0,0,1);m.clearDepth(1);m.clearStencil(0);m.enable(m.DEPTH_TEST);m.depthFunc(m.LEQUAL);m.frontFace(m.CCW);m.cullFace(m.BACK);m.enable(m.CULL_FACE);m.enable(m.BLEND);m.blendEquation(m.FUNC_ADD);m.blendFunc(m.SRC_ALPHA,m.ONE_MINUS_SRC_ALPHA);m.viewport(Oa,Pa,Qa,Aa);m.clearColor(fa.r,fa.g,fa.b,V);this.context=m;var ib=m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS),db=m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS);m.getParameter(m.MAX_TEXTURE_SIZE);var Yb=m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE),
Cb=ea?m.getParameter(ea.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,yb=0<db,ub=yb&&Sa;Ka&&m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);var Zb=m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.HIGH_FLOAT),$b=m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.MEDIUM_FLOAT);m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.LOW_FLOAT);var ac=m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.HIGH_FLOAT),bc=m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.MEDIUM_FLOAT);m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.LOW_FLOAT);m.getShaderPrecisionFormat(m.VERTEX_SHADER,
m.HIGH_INT);m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.MEDIUM_INT);m.getShaderPrecisionFormat(m.VERTEX_SHADER,m.LOW_INT);m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.HIGH_INT);m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.MEDIUM_INT);m.getShaderPrecisionFormat(m.FRAGMENT_SHADER,m.LOW_INT);var sc=0<Zb.precision&&0<ac.precision,Kb=0<$b.precision&&0<bc.precision;"highp"!==Y||sc||(Kb?(Y="mediump",console.warn("WebGLRenderer: highp not supported, using mediump")):(Y="lowp",console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
"mediump"!==Y||Kb||(Y="lowp",console.warn("WebGLRenderer: mediump not supported, using lowp"));this.getContext=function(){return m};this.supportsVertexTextures=function(){return yb};this.supportsFloatTextures=function(){return Sa};this.supportsStandardDerivatives=function(){return Wa};this.supportsCompressedTextureS3TC=function(){return Ka};this.getMaxAnisotropy=function(){return Cb};this.getPrecision=function(){return Y};this.setSize=function(a,b,c){D.width=a*this.devicePixelRatio;D.height=b*this.devicePixelRatio;
1!==this.devicePixelRatio&&!1!==c&&(D.style.width=a+"px",D.style.height=b+"px");this.setViewport(0,0,a,b)};this.setViewport=function(a,b,c,d){Oa=a*this.devicePixelRatio;Pa=b*this.devicePixelRatio;Qa=c*this.devicePixelRatio;Aa=d*this.devicePixelRatio;m.viewport(Oa,Pa,Qa,Aa)};this.setScissor=function(a,b,c,d){m.scissor(a*this.devicePixelRatio,b*this.devicePixelRatio,c*this.devicePixelRatio,d*this.devicePixelRatio)};this.enableScissorTest=function(a){a?m.enable(m.SCISSOR_TEST):m.disable(m.SCISSOR_TEST)};
this.setClearColor=function(a,b){fa.set(a);V=void 0!==b?b:1;m.clearColor(fa.r,fa.g,fa.b,V)};this.setClearColorHex=function(a,b){console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");this.setClearColor(a,b)};this.getClearColor=function(){return fa};this.getClearAlpha=function(){return V};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=m.COLOR_BUFFER_BIT;if(void 0===b||b)d|=m.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=m.STENCIL_BUFFER_BIT;m.clear(d)};this.clearColor=
function(){m.clear(m.COLOR_BUFFER_BIT)};this.clearDepth=function(){m.clear(m.DEPTH_BUFFER_BIT)};this.clearStencil=function(){m.clear(m.STENCIL_BUFFER_BIT)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.updateShadowMap=function(a,b){T=null;va=wa=Ja=Za=Ma=-1;ha=!0;ya=xa=-1;this.shadowMapPlugin.update(a,b)};var Lb=function(a){a=
a.target;a.removeEventListener("dispose",Lb);a.__webglInit=void 0;if(a instanceof THREE.BufferGeometry){var b=a.attributes,c;for(c in b)void 0!==b[c].buffer&&m.deleteBuffer(b[c].buffer);I.info.memory.geometries--}else if(void 0!==a.geometryGroups)for(b in a.geometryGroups){c=a.geometryGroups[b];if(void 0!==c.numMorphTargets)for(var d=0,e=c.numMorphTargets;d<e;d++)m.deleteBuffer(c.__webglMorphTargetsBuffers[d]);if(void 0!==c.numMorphNormals)for(d=0,e=c.numMorphNormals;d<e;d++)m.deleteBuffer(c.__webglMorphNormalsBuffers[d]);
Eb(c)}else Eb(a)},Db=function(a){a=a.target;a.removeEventListener("dispose",Db);a.image&&a.image.__webglTextureCube?m.deleteTexture(a.image.__webglTextureCube):a.__webglInit&&(a.__webglInit=!1,m.deleteTexture(a.__webglTexture));I.info.memory.textures--},Mb=function(a){a=a.target;a.removeEventListener("dispose",Mb);if(a&&a.__webglTexture)if(m.deleteTexture(a.__webglTexture),a instanceof THREE.WebGLRenderTargetCube)for(var b=0;6>b;b++)m.deleteFramebuffer(a.__webglFramebuffer[b]),m.deleteRenderbuffer(a.__webglRenderbuffer[b]);
else m.deleteFramebuffer(a.__webglFramebuffer),m.deleteRenderbuffer(a.__webglRenderbuffer);I.info.memory.textures--},Nb=function(a){a=a.target;a.removeEventListener("dispose",Nb);Fb(a)},Eb=function(a){void 0!==a.__webglVertexBuffer&&m.deleteBuffer(a.__webglVertexBuffer);void 0!==a.__webglNormalBuffer&&m.deleteBuffer(a.__webglNormalBuffer);void 0!==a.__webglTangentBuffer&&m.deleteBuffer(a.__webglTangentBuffer);void 0!==a.__webglColorBuffer&&m.deleteBuffer(a.__webglColorBuffer);void 0!==a.__webglUVBuffer&&
m.deleteBuffer(a.__webglUVBuffer);void 0!==a.__webglUV2Buffer&&m.deleteBuffer(a.__webglUV2Buffer);void 0!==a.__webglSkinIndicesBuffer&&m.deleteBuffer(a.__webglSkinIndicesBuffer);void 0!==a.__webglSkinWeightsBuffer&&m.deleteBuffer(a.__webglSkinWeightsBuffer);void 0!==a.__webglFaceBuffer&&m.deleteBuffer(a.__webglFaceBuffer);void 0!==a.__webglLineBuffer&&m.deleteBuffer(a.__webglLineBuffer);void 0!==a.__webglLineDistanceBuffer&&m.deleteBuffer(a.__webglLineDistanceBuffer);if(void 0!==a.__webglCustomAttributesList)for(var b in a.__webglCustomAttributesList)m.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
I.info.memory.geometries--},Fb=function(a){var b=a.program;if(void 0!==b){a.program=void 0;var c,d,e=!1;a=0;for(c=R.length;a<c;a++)if(d=R[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(!0===e){e=[];a=0;for(c=R.length;a<c;a++)d=R[a],d.program!==b&&e.push(d);R=e;m.deleteProgram(b);I.info.memory.programs--}}};this.renderBufferImmediate=function(a,b,c){a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=m.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&(a.__webglNormalBuffer=
m.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=m.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=m.createBuffer());a.hasPositions&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglVertexBuffer),m.bufferData(m.ARRAY_BUFFER,a.positionArray,m.DYNAMIC_DRAW),m.enableVertexAttribArray(b.attributes.position),m.vertexAttribPointer(b.attributes.position,3,m.FLOAT,!1,0,0));if(a.hasNormals){m.bindBuffer(m.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,
e,f,g,h,k,l,n,p,q,r,s=3*a.count;for(r=0;r<s;r+=9)q=a.normalArray,d=q[r],e=q[r+1],f=q[r+2],g=q[r+3],k=q[r+4],n=q[r+5],h=q[r+6],l=q[r+7],p=q[r+8],d=(d+g+h)/3,e=(e+k+l)/3,f=(f+n+p)/3,q[r]=d,q[r+1]=e,q[r+2]=f,q[r+3]=d,q[r+4]=e,q[r+5]=f,q[r+6]=d,q[r+7]=e,q[r+8]=f}m.bufferData(m.ARRAY_BUFFER,a.normalArray,m.DYNAMIC_DRAW);m.enableVertexAttribArray(b.attributes.normal);m.vertexAttribPointer(b.attributes.normal,3,m.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglUvBuffer),m.bufferData(m.ARRAY_BUFFER,
a.uvArray,m.DYNAMIC_DRAW),m.enableVertexAttribArray(b.attributes.uv),m.vertexAttribPointer(b.attributes.uv,2,m.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(m.bindBuffer(m.ARRAY_BUFFER,a.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,a.colorArray,m.DYNAMIC_DRAW),m.enableVertexAttribArray(b.attributes.color),m.vertexAttribPointer(b.attributes.color,3,m.FLOAT,!1,0,0));m.drawArrays(m.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible){var l,
n,p,q;l=z(a,b,c,d,f);a=l.attributes;b=e.attributes;c=!1;l=16777215*e.id+2*l.id+(d.wireframe?1:0);l!==wa&&(wa=l,c=!0);c&&k();if(f instanceof THREE.Mesh)if(f=b.index){e=e.offsets;1<e.length&&(c=!0);for(var r=0,s=e.length;r<s;r++){var t=e[r].index;if(c){for(n in a)p=a[n],l=b[n],0<=p&&(l?(q=l.itemSize,m.bindBuffer(m.ARRAY_BUFFER,l.buffer),h(p),m.vertexAttribPointer(p,q,m.FLOAT,!1,0,t*q*4)):d.defaultAttributeValues&&(2===d.defaultAttributeValues[n].length?m.vertexAttrib2fv(p,d.defaultAttributeValues[n]):
3===d.defaultAttributeValues[n].length&&m.vertexAttrib3fv(p,d.defaultAttributeValues[n])));m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,f.buffer)}m.drawElements(m.TRIANGLES,e[r].count,m.UNSIGNED_SHORT,2*e[r].start);I.info.render.calls++;I.info.render.vertices+=e[r].count;I.info.render.faces+=e[r].count/3}}else{if(c)for(n in a)"index"!==n&&(p=a[n],l=b[n],0<=p&&(l?(q=l.itemSize,m.bindBuffer(m.ARRAY_BUFFER,l.buffer),h(p),m.vertexAttribPointer(p,q,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[n]&&
(2===d.defaultAttributeValues[n].length?m.vertexAttrib2fv(p,d.defaultAttributeValues[n]):3===d.defaultAttributeValues[n].length&&m.vertexAttrib3fv(p,d.defaultAttributeValues[n]))));d=e.attributes.position;m.drawArrays(m.TRIANGLES,0,d.array.length/3);I.info.render.calls++;I.info.render.vertices+=d.array.length/3;I.info.render.faces+=d.array.length/3/3}else if(f instanceof THREE.ParticleSystem){if(c)for(n in a)p=a[n],l=b[n],0<=p&&(l?(q=l.itemSize,m.bindBuffer(m.ARRAY_BUFFER,l.buffer),h(p),m.vertexAttribPointer(p,
q,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[n]&&(2===d.defaultAttributeValues[n].length?m.vertexAttrib2fv(p,d.defaultAttributeValues[n]):3===d.defaultAttributeValues[n].length&&m.vertexAttrib3fv(p,d.defaultAttributeValues[n])));d=b.position;m.drawArrays(m.POINTS,0,d.array.length/3);I.info.render.calls++;I.info.render.points+=d.array.length/3}else if(f instanceof THREE.Line)if(n=f.type===THREE.LineStrip?m.LINE_STRIP:m.LINES,C(d.linewidth),f=b.index)for(e=e.offsets,1<e.length&&
(c=!0),r=0,s=e.length;r<s;r++)t=e[r].index,c&&(g(d,a,b,t),m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,f.buffer)),m.drawElements(m.LINES,e[r].count,m.UNSIGNED_SHORT,2*e[r].start),I.info.render.calls++,I.info.render.vertices+=e[r].count;else c&&g(d,a,b,0),d=b.position,m.drawArrays(n,0,d.array.length/3),I.info.render.calls++,I.info.render.points+=d.array.length}};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var g,l;c=z(a,b,c,d,f);a=c.attributes;b=!1;c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==
wa&&(wa=c,b=!0);b&&k();if(!d.morphTargets&&0<=a.position)b&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglVertexBuffer),h(a.position),m.vertexAttribPointer(a.position,3,m.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase&&0<=c.position?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[f.morphTargetBase]),h(c.position),m.vertexAttribPointer(c.position,3,m.FLOAT,!1,0,0)):0<=c.position&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglVertexBuffer),h(c.position),m.vertexAttribPointer(c.position,
3,m.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var p=0;l=f.morphTargetForcedOrder;for(g=f.morphTargetInfluences;p<d.numSupportedMorphTargets&&p<l.length;)0<=c["morphTarget"+p]&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[l[p]]),h(c["morphTarget"+p]),m.vertexAttribPointer(c["morphTarget"+p],3,m.FLOAT,!1,0,0)),0<=c["morphNormal"+p]&&d.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[l[p]]),h(c["morphNormal"+p]),m.vertexAttribPointer(c["morphNormal"+p],3,
m.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[p]=g[l[p]],p++}else{l=[];g=f.morphTargetInfluences;var q,r=g.length;for(q=0;q<r;q++)p=g[q],0<p&&l.push([p,q]);l.length>d.numSupportedMorphTargets?(l.sort(n),l.length=d.numSupportedMorphTargets):l.length>d.numSupportedMorphNormals?l.sort(n):0===l.length&&l.push([0,0]);for(p=0;p<d.numSupportedMorphTargets;)l[p]?(q=l[p][1],0<=c["morphTarget"+p]&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[q]),h(c["morphTarget"+p]),m.vertexAttribPointer(c["morphTarget"+
p],3,m.FLOAT,!1,0,0)),0<=c["morphNormal"+p]&&d.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[q]),h(c["morphNormal"+p]),m.vertexAttribPointer(c["morphNormal"+p],3,m.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[p]=g[q]):f.__webglMorphTargetInfluences[p]=0,p++}null!==d.program.uniforms.morphTargetInfluences&&m.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(b){if(e.__webglCustomAttributesList)for(g=0,l=e.__webglCustomAttributesList.length;g<
l;g++)c=e.__webglCustomAttributesList[g],0<=a[c.buffer.belongsToAttribute]&&(m.bindBuffer(m.ARRAY_BUFFER,c.buffer),h(a[c.buffer.belongsToAttribute]),m.vertexAttribPointer(a[c.buffer.belongsToAttribute],c.size,m.FLOAT,!1,0,0));0<=a.color&&(0<f.geometry.colors.length||0<f.geometry.faces.length?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglColorBuffer),h(a.color),m.vertexAttribPointer(a.color,3,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib3fv(a.color,d.defaultAttributeValues.color));0<=a.normal&&
(m.bindBuffer(m.ARRAY_BUFFER,e.__webglNormalBuffer),h(a.normal),m.vertexAttribPointer(a.normal,3,m.FLOAT,!1,0,0));0<=a.tangent&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglTangentBuffer),h(a.tangent),m.vertexAttribPointer(a.tangent,4,m.FLOAT,!1,0,0));0<=a.uv&&(f.geometry.faceVertexUvs[0]?(m.bindBuffer(m.ARRAY_BUFFER,e.__webglUVBuffer),h(a.uv),m.vertexAttribPointer(a.uv,2,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib2fv(a.uv,d.defaultAttributeValues.uv));0<=a.uv2&&(f.geometry.faceVertexUvs[1]?
(m.bindBuffer(m.ARRAY_BUFFER,e.__webglUV2Buffer),h(a.uv2),m.vertexAttribPointer(a.uv2,2,m.FLOAT,!1,0,0)):d.defaultAttributeValues&&m.vertexAttrib2fv(a.uv2,d.defaultAttributeValues.uv2));d.skinning&&0<=a.skinIndex&&0<=a.skinWeight&&(m.bindBuffer(m.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),h(a.skinIndex),m.vertexAttribPointer(a.skinIndex,4,m.FLOAT,!1,0,0),m.bindBuffer(m.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),h(a.skinWeight),m.vertexAttribPointer(a.skinWeight,4,m.FLOAT,!1,0,0));0<=a.lineDistance&&(m.bindBuffer(m.ARRAY_BUFFER,
e.__webglLineDistanceBuffer),h(a.lineDistance),m.vertexAttribPointer(a.lineDistance,1,m.FLOAT,!1,0,0))}f instanceof THREE.Mesh?(d.wireframe?(C(d.wireframeLinewidth),b&&m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),m.drawElements(m.LINES,e.__webglLineCount,m.UNSIGNED_SHORT,0)):(b&&m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,e.__webglFaceBuffer),m.drawElements(m.TRIANGLES,e.__webglFaceCount,m.UNSIGNED_SHORT,0)),I.info.render.calls++,I.info.render.vertices+=e.__webglFaceCount,I.info.render.faces+=
e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?m.LINE_STRIP:m.LINES,C(d.linewidth),m.drawArrays(f,0,e.__webglLineCount),I.info.render.calls++):f instanceof THREE.ParticleSystem&&(m.drawArrays(m.POINTS,0,e.__webglParticleCount),I.info.render.calls++,I.info.render.points+=e.__webglParticleCount)}};this.render=function(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else{var e,f,g,h,k=a.__lights,
n=a.fog;va=-1;ha=!0;!0===a.autoUpdate&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();b.matrixWorldInverse.getInverse(b.matrixWorld);hb.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);ja.setFromMatrix(hb);this.autoUpdateObjects&&this.initWebGLObjects(a);q(this.renderPluginsPre,a,b);I.info.render.calls=0;I.info.render.vertices=0;I.info.render.faces=0;I.info.render.points=0;this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);
h=a.__webglObjects;d=0;for(e=h.length;d<e;d++)if(f=h[d],g=f.object,f.id=d,f.render=!1,g.visible&&(!(g instanceof THREE.Mesh||g instanceof THREE.ParticleSystem)||!g.frustumCulled||ja.intersectsObject(g))){var p=g;p._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,p.matrixWorld);p._normalMatrix.getNormalMatrix(p._modelViewMatrix);var p=f,r=p.object,t=p.buffer,v=r.geometry,r=r.material;r instanceof THREE.MeshFaceMaterial?(r=r.materials[v instanceof THREE.BufferGeometry?0:t.materialIndex],r.transparent?
(p.transparent=r,p.opaque=null):(p.opaque=r,p.transparent=null)):r&&(r.transparent?(p.transparent=r,p.opaque=null):(p.opaque=r,p.transparent=null));f.render=!0;!0===this.sortObjects&&(null!==g.renderDepth?f.z=g.renderDepth:(ua.setFromMatrixPosition(g.matrixWorld),ua.applyProjection(hb),f.z=ua.z))}this.sortObjects&&h.sort(l);h=a.__webglObjectsImmediate;d=0;for(e=h.length;d<e;d++)f=h[d],g=f.object,g.visible&&(g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,g.matrixWorld),g._normalMatrix.getNormalMatrix(g._modelViewMatrix),
g=f.object.material,g.transparent?(f.transparent=g,f.opaque=null):(f.opaque=g,f.transparent=null));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),M(d.polygonOffset,d.polygonOffsetFactor,d.polygonOffsetUnits),s(a.__webglObjects,!1,"",b,k,n,!0,d),u(a.__webglObjectsImmediate,"",b,k,n,!1,d)):(d=null,this.setBlending(THREE.NoBlending),s(a.__webglObjects,!0,"opaque",b,k,n,!1,d),u(a.__webglObjectsImmediate,
"opaque",b,k,n,!1,d),s(a.__webglObjects,!1,"transparent",b,k,n,!0,d),u(a.__webglObjectsImmediate,"transparent",b,k,n,!0,d));q(this.renderPluginsPost,a,b);c&&c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter&&(c instanceof THREE.WebGLRenderTargetCube?(m.bindTexture(m.TEXTURE_CUBE_MAP,c.__webglTexture),m.generateMipmap(m.TEXTURE_CUBE_MAP),m.bindTexture(m.TEXTURE_CUBE_MAP,null)):(m.bindTexture(m.TEXTURE_2D,c.__webglTexture),m.generateMipmap(m.TEXTURE_2D),m.bindTexture(m.TEXTURE_2D,
null)));this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=z(a,b,c,d,e);wa=-1;I.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,m,ja):e.render(function(a){I.renderBufferImmediate(a,f,d)})};this.initWebGLObjects=function(a){a.__webglObjects||(a.__webglObjects=[],a.__webglObjectsImmediate=[],a.__webglSprites=[],a.__webglFlares=[]);for(;a.__objectsAdded.length;)t(a.__objectsAdded[0],a),a.__objectsAdded.splice(0,1);for(;a.__objectsRemoved.length;)r(a.__objectsRemoved[0],
a),a.__objectsRemoved.splice(0,1);for(var b=0,g=a.__webglObjects.length;b<g;b++){var h=a.__webglObjects[b].object;void 0===h.__webglInit&&(void 0!==h.__webglActive&&r(h,a),t(h,a));var k=h,l=k.geometry,p=void 0,q=void 0,s=void 0;if(l instanceof THREE.BufferGeometry){var u=m.DYNAMIC_DRAW,y=!l.dynamic,x=l.attributes,E=void 0,D=void 0;for(E in x)D=x[E],D.needsUpdate&&("index"===E?(m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,D.buffer),m.bufferData(m.ELEMENT_ARRAY_BUFFER,D.array,u)):(m.bindBuffer(m.ARRAY_BUFFER,
D.buffer),m.bufferData(m.ARRAY_BUFFER,D.array,u)),D.needsUpdate=!1),y&&!D.dynamic&&(D.array=null)}else if(k instanceof THREE.Mesh){for(var B=0,A=l.geometryGroupsList.length;B<A;B++)if(p=l.geometryGroupsList[B],s=d(k,p),l.buffersNeedUpdate&&c(p,k),q=s.attributes&&v(s),l.verticesNeedUpdate||l.morphTargetsNeedUpdate||l.elementsNeedUpdate||l.uvsNeedUpdate||l.normalsNeedUpdate||l.colorsNeedUpdate||l.tangentsNeedUpdate||q){var z=p,F=k,C=m.DYNAMIC_DRAW,M=!l.dynamic,H=s;if(z.__inittedArrays){var J=e(H),P=
H.vertexColors?H.vertexColors:!1,I=f(H),N=J===THREE.SmoothShading,G=void 0,R=void 0,Q=void 0,K=void 0,Z=void 0,Y=void 0,S=void 0,V=void 0,U=void 0,da=void 0,va=void 0,T=void 0,ba=void 0,aa=void 0,$=void 0,Ca=void 0,za=void 0,wa=void 0,fa=void 0,ga=void 0,ha=void 0,Ia=void 0,xa=void 0,ja=void 0,la=void 0,ma=void 0,oa=void 0,pa=void 0,ya=void 0,ea=void 0,Ja=void 0,Ea=void 0,Ka=void 0,Ma=void 0,qa=void 0,Oa=void 0,Da=void 0,Ha=void 0,Pa=void 0,Qa=void 0,Aa=0,Ba=0,La=0,Ra=0,Sa=0,jb=0,Ya=0,Na=0,eb=0,ta=
0,Fa=0,O=0,Xa=void 0,kb=z.__vertexArray,Za=z.__uvArray,db=z.__uv2Array,Wa=z.__normalArray,$a=z.__tangentArray,lb=z.__colorArray,ab=z.__skinIndexArray,bb=z.__skinWeightArray,ib=z.__morphTargetsArrays,yb=z.__morphNormalsArrays,ub=z.__webglCustomAttributesList,L=void 0,Ob=z.__faceArray,vb=z.__lineArray,Ta=F.geometry,Db=Ta.elementsNeedUpdate,Cb=Ta.uvsNeedUpdate,Kb=Ta.normalsNeedUpdate,Lb=Ta.tangentsNeedUpdate,Mb=Ta.colorsNeedUpdate,Nb=Ta.morphTargetsNeedUpdate,dc=Ta.vertices,ia=z.faces3,mb=Ta.faces,Eb=
Ta.faceVertexUvs[0],Fb=Ta.faceVertexUvs[1],ec=Ta.skinIndices,Pb=Ta.skinWeights,Qb=Ta.morphTargets,jc=Ta.morphNormals;if(Ta.verticesNeedUpdate){G=0;for(R=ia.length;G<R;G++)K=mb[ia[G]],T=dc[K.a],ba=dc[K.b],aa=dc[K.c],kb[Ba]=T.x,kb[Ba+1]=T.y,kb[Ba+2]=T.z,kb[Ba+3]=ba.x,kb[Ba+4]=ba.y,kb[Ba+5]=ba.z,kb[Ba+6]=aa.x,kb[Ba+7]=aa.y,kb[Ba+8]=aa.z,Ba+=9;m.bindBuffer(m.ARRAY_BUFFER,z.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER,kb,C)}if(Nb)for(qa=0,Oa=Qb.length;qa<Oa;qa++){G=Fa=0;for(R=ia.length;G<R;G++)Pa=
ia[G],K=mb[Pa],T=Qb[qa].vertices[K.a],ba=Qb[qa].vertices[K.b],aa=Qb[qa].vertices[K.c],Da=ib[qa],Da[Fa]=T.x,Da[Fa+1]=T.y,Da[Fa+2]=T.z,Da[Fa+3]=ba.x,Da[Fa+4]=ba.y,Da[Fa+5]=ba.z,Da[Fa+6]=aa.x,Da[Fa+7]=aa.y,Da[Fa+8]=aa.z,H.morphNormals&&(N?(Qa=jc[qa].vertexNormals[Pa],wa=Qa.a,fa=Qa.b,ga=Qa.c):ga=fa=wa=jc[qa].faceNormals[Pa],Ha=yb[qa],Ha[Fa]=wa.x,Ha[Fa+1]=wa.y,Ha[Fa+2]=wa.z,Ha[Fa+3]=fa.x,Ha[Fa+4]=fa.y,Ha[Fa+5]=fa.z,Ha[Fa+6]=ga.x,Ha[Fa+7]=ga.y,Ha[Fa+8]=ga.z),Fa+=9;m.bindBuffer(m.ARRAY_BUFFER,z.__webglMorphTargetsBuffers[qa]);
m.bufferData(m.ARRAY_BUFFER,ib[qa],C);H.morphNormals&&(m.bindBuffer(m.ARRAY_BUFFER,z.__webglMorphNormalsBuffers[qa]),m.bufferData(m.ARRAY_BUFFER,yb[qa],C))}if(Pb.length){G=0;for(R=ia.length;G<R;G++)K=mb[ia[G]],ja=Pb[K.a],la=Pb[K.b],ma=Pb[K.c],bb[ta]=ja.x,bb[ta+1]=ja.y,bb[ta+2]=ja.z,bb[ta+3]=ja.w,bb[ta+4]=la.x,bb[ta+5]=la.y,bb[ta+6]=la.z,bb[ta+7]=la.w,bb[ta+8]=ma.x,bb[ta+9]=ma.y,bb[ta+10]=ma.z,bb[ta+11]=ma.w,oa=ec[K.a],pa=ec[K.b],ya=ec[K.c],ab[ta]=oa.x,ab[ta+1]=oa.y,ab[ta+2]=oa.z,ab[ta+3]=oa.w,ab[ta+
4]=pa.x,ab[ta+5]=pa.y,ab[ta+6]=pa.z,ab[ta+7]=pa.w,ab[ta+8]=ya.x,ab[ta+9]=ya.y,ab[ta+10]=ya.z,ab[ta+11]=ya.w,ta+=12;0<ta&&(m.bindBuffer(m.ARRAY_BUFFER,z.__webglSkinIndicesBuffer),m.bufferData(m.ARRAY_BUFFER,ab,C),m.bindBuffer(m.ARRAY_BUFFER,z.__webglSkinWeightsBuffer),m.bufferData(m.ARRAY_BUFFER,bb,C))}if(Mb&&P){G=0;for(R=ia.length;G<R;G++)K=mb[ia[G]],S=K.vertexColors,V=K.color,3===S.length&&P===THREE.VertexColors?(ha=S[0],Ia=S[1],xa=S[2]):xa=Ia=ha=V,lb[eb]=ha.r,lb[eb+1]=ha.g,lb[eb+2]=ha.b,lb[eb+3]=
Ia.r,lb[eb+4]=Ia.g,lb[eb+5]=Ia.b,lb[eb+6]=xa.r,lb[eb+7]=xa.g,lb[eb+8]=xa.b,eb+=9;0<eb&&(m.bindBuffer(m.ARRAY_BUFFER,z.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,lb,C))}if(Lb&&Ta.hasTangents){G=0;for(R=ia.length;G<R;G++)K=mb[ia[G]],U=K.vertexTangents,$=U[0],Ca=U[1],za=U[2],$a[Ya]=$.x,$a[Ya+1]=$.y,$a[Ya+2]=$.z,$a[Ya+3]=$.w,$a[Ya+4]=Ca.x,$a[Ya+5]=Ca.y,$a[Ya+6]=Ca.z,$a[Ya+7]=Ca.w,$a[Ya+8]=za.x,$a[Ya+9]=za.y,$a[Ya+10]=za.z,$a[Ya+11]=za.w,Ya+=12;m.bindBuffer(m.ARRAY_BUFFER,z.__webglTangentBuffer);
m.bufferData(m.ARRAY_BUFFER,$a,C)}if(Kb&&J){G=0;for(R=ia.length;G<R;G++)if(K=mb[ia[G]],Z=K.vertexNormals,Y=K.normal,3===Z.length&&N)for(ea=0;3>ea;ea++)Ea=Z[ea],Wa[jb]=Ea.x,Wa[jb+1]=Ea.y,Wa[jb+2]=Ea.z,jb+=3;else for(ea=0;3>ea;ea++)Wa[jb]=Y.x,Wa[jb+1]=Y.y,Wa[jb+2]=Y.z,jb+=3;m.bindBuffer(m.ARRAY_BUFFER,z.__webglNormalBuffer);m.bufferData(m.ARRAY_BUFFER,Wa,C)}if(Cb&&Eb&&I){G=0;for(R=ia.length;G<R;G++)if(Q=ia[G],da=Eb[Q],void 0!==da)for(ea=0;3>ea;ea++)Ka=da[ea],Za[La]=Ka.x,Za[La+1]=Ka.y,La+=2;0<La&&(m.bindBuffer(m.ARRAY_BUFFER,
z.__webglUVBuffer),m.bufferData(m.ARRAY_BUFFER,Za,C))}if(Cb&&Fb&&I){G=0;for(R=ia.length;G<R;G++)if(Q=ia[G],va=Fb[Q],void 0!==va)for(ea=0;3>ea;ea++)Ma=va[ea],db[Ra]=Ma.x,db[Ra+1]=Ma.y,Ra+=2;0<Ra&&(m.bindBuffer(m.ARRAY_BUFFER,z.__webglUV2Buffer),m.bufferData(m.ARRAY_BUFFER,db,C))}if(Db){G=0;for(R=ia.length;G<R;G++)Ob[Sa]=Aa,Ob[Sa+1]=Aa+1,Ob[Sa+2]=Aa+2,Sa+=3,vb[Na]=Aa,vb[Na+1]=Aa+1,vb[Na+2]=Aa,vb[Na+3]=Aa+2,vb[Na+4]=Aa+1,vb[Na+5]=Aa+2,Na+=6,Aa+=3;m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,z.__webglFaceBuffer);
m.bufferData(m.ELEMENT_ARRAY_BUFFER,Ob,C);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,z.__webglLineBuffer);m.bufferData(m.ELEMENT_ARRAY_BUFFER,vb,C)}if(ub)for(ea=0,Ja=ub.length;ea<Ja;ea++)if(L=ub[ea],L.__original.needsUpdate){O=0;if(1===L.size)if(void 0===L.boundTo||"vertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)K=mb[ia[G]],L.array[O]=L.value[K.a],L.array[O+1]=L.value[K.b],L.array[O+2]=L.value[K.c],O+=3;else{if("faces"===L.boundTo)for(G=0,R=ia.length;G<R;G++)Xa=L.value[ia[G]],L.array[O]=Xa,L.array[O+
1]=Xa,L.array[O+2]=Xa,O+=3}else if(2===L.size)if(void 0===L.boundTo||"vertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)K=mb[ia[G]],T=L.value[K.a],ba=L.value[K.b],aa=L.value[K.c],L.array[O]=T.x,L.array[O+1]=T.y,L.array[O+2]=ba.x,L.array[O+3]=ba.y,L.array[O+4]=aa.x,L.array[O+5]=aa.y,O+=6;else{if("faces"===L.boundTo)for(G=0,R=ia.length;G<R;G++)aa=ba=T=Xa=L.value[ia[G]],L.array[O]=T.x,L.array[O+1]=T.y,L.array[O+2]=ba.x,L.array[O+3]=ba.y,L.array[O+4]=aa.x,L.array[O+5]=aa.y,O+=6}else if(3===L.size){var sa;
sa="c"===L.type?["r","g","b"]:["x","y","z"];if(void 0===L.boundTo||"vertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)K=mb[ia[G]],T=L.value[K.a],ba=L.value[K.b],aa=L.value[K.c],L.array[O]=T[sa[0]],L.array[O+1]=T[sa[1]],L.array[O+2]=T[sa[2]],L.array[O+3]=ba[sa[0]],L.array[O+4]=ba[sa[1]],L.array[O+5]=ba[sa[2]],L.array[O+6]=aa[sa[0]],L.array[O+7]=aa[sa[1]],L.array[O+8]=aa[sa[2]],O+=9;else if("faces"===L.boundTo)for(G=0,R=ia.length;G<R;G++)aa=ba=T=Xa=L.value[ia[G]],L.array[O]=T[sa[0]],L.array[O+1]=T[sa[1]],
L.array[O+2]=T[sa[2]],L.array[O+3]=ba[sa[0]],L.array[O+4]=ba[sa[1]],L.array[O+5]=ba[sa[2]],L.array[O+6]=aa[sa[0]],L.array[O+7]=aa[sa[1]],L.array[O+8]=aa[sa[2]],O+=9;else if("faceVertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)Xa=L.value[ia[G]],T=Xa[0],ba=Xa[1],aa=Xa[2],L.array[O]=T[sa[0]],L.array[O+1]=T[sa[1]],L.array[O+2]=T[sa[2]],L.array[O+3]=ba[sa[0]],L.array[O+4]=ba[sa[1]],L.array[O+5]=ba[sa[2]],L.array[O+6]=aa[sa[0]],L.array[O+7]=aa[sa[1]],L.array[O+8]=aa[sa[2]],O+=9}else if(4===L.size)if(void 0===
L.boundTo||"vertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)K=mb[ia[G]],T=L.value[K.a],ba=L.value[K.b],aa=L.value[K.c],L.array[O]=T.x,L.array[O+1]=T.y,L.array[O+2]=T.z,L.array[O+3]=T.w,L.array[O+4]=ba.x,L.array[O+5]=ba.y,L.array[O+6]=ba.z,L.array[O+7]=ba.w,L.array[O+8]=aa.x,L.array[O+9]=aa.y,L.array[O+10]=aa.z,L.array[O+11]=aa.w,O+=12;else if("faces"===L.boundTo)for(G=0,R=ia.length;G<R;G++)aa=ba=T=Xa=L.value[ia[G]],L.array[O]=T.x,L.array[O+1]=T.y,L.array[O+2]=T.z,L.array[O+3]=T.w,L.array[O+4]=ba.x,
L.array[O+5]=ba.y,L.array[O+6]=ba.z,L.array[O+7]=ba.w,L.array[O+8]=aa.x,L.array[O+9]=aa.y,L.array[O+10]=aa.z,L.array[O+11]=aa.w,O+=12;else if("faceVertices"===L.boundTo)for(G=0,R=ia.length;G<R;G++)Xa=L.value[ia[G]],T=Xa[0],ba=Xa[1],aa=Xa[2],L.array[O]=T.x,L.array[O+1]=T.y,L.array[O+2]=T.z,L.array[O+3]=T.w,L.array[O+4]=ba.x,L.array[O+5]=ba.y,L.array[O+6]=ba.z,L.array[O+7]=ba.w,L.array[O+8]=aa.x,L.array[O+9]=aa.y,L.array[O+10]=aa.z,L.array[O+11]=aa.w,O+=12;m.bindBuffer(m.ARRAY_BUFFER,L.buffer);m.bufferData(m.ARRAY_BUFFER,
L.array,C)}M&&(delete z.__inittedArrays,delete z.__colorArray,delete z.__normalArray,delete z.__tangentArray,delete z.__uvArray,delete z.__uv2Array,delete z.__faceArray,delete z.__vertexArray,delete z.__lineArray,delete z.__skinIndexArray,delete z.__skinWeightArray)}}l.verticesNeedUpdate=!1;l.morphTargetsNeedUpdate=!1;l.elementsNeedUpdate=!1;l.uvsNeedUpdate=!1;l.normalsNeedUpdate=!1;l.colorsNeedUpdate=!1;l.tangentsNeedUpdate=!1;l.buffersNeedUpdate=!1;s.attributes&&w(s)}else if(k instanceof THREE.Line){s=
d(k,l);q=s.attributes&&v(s);if(l.verticesNeedUpdate||l.colorsNeedUpdate||l.lineDistancesNeedUpdate||q){var cb=l,Rb=m.DYNAMIC_DRAW,Gb=void 0,Hb=void 0,Ib=void 0,Sb=void 0,ra=void 0,Tb=void 0,kc=cb.vertices,lc=cb.colors,mc=cb.lineDistances,Yb=kc.length,Zb=lc.length,$b=mc.length,Ub=cb.__vertexArray,Vb=cb.__colorArray,nc=cb.__lineDistanceArray,ac=cb.colorsNeedUpdate,bc=cb.lineDistancesNeedUpdate,fc=cb.__webglCustomAttributesList,Wb=void 0,oc=void 0,Ga=void 0,Ab=void 0,Ua=void 0,na=void 0;if(cb.verticesNeedUpdate){for(Gb=
0;Gb<Yb;Gb++)Sb=kc[Gb],ra=3*Gb,Ub[ra]=Sb.x,Ub[ra+1]=Sb.y,Ub[ra+2]=Sb.z;m.bindBuffer(m.ARRAY_BUFFER,cb.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER,Ub,Rb)}if(ac){for(Hb=0;Hb<Zb;Hb++)Tb=lc[Hb],ra=3*Hb,Vb[ra]=Tb.r,Vb[ra+1]=Tb.g,Vb[ra+2]=Tb.b;m.bindBuffer(m.ARRAY_BUFFER,cb.__webglColorBuffer);m.bufferData(m.ARRAY_BUFFER,Vb,Rb)}if(bc){for(Ib=0;Ib<$b;Ib++)nc[Ib]=mc[Ib];m.bindBuffer(m.ARRAY_BUFFER,cb.__webglLineDistanceBuffer);m.bufferData(m.ARRAY_BUFFER,nc,Rb)}if(fc)for(Wb=0,oc=fc.length;Wb<oc;Wb++)if(na=
fc[Wb],na.needsUpdate&&(void 0===na.boundTo||"vertices"===na.boundTo)){ra=0;Ab=na.value.length;if(1===na.size)for(Ga=0;Ga<Ab;Ga++)na.array[Ga]=na.value[Ga];else if(2===na.size)for(Ga=0;Ga<Ab;Ga++)Ua=na.value[Ga],na.array[ra]=Ua.x,na.array[ra+1]=Ua.y,ra+=2;else if(3===na.size)if("c"===na.type)for(Ga=0;Ga<Ab;Ga++)Ua=na.value[Ga],na.array[ra]=Ua.r,na.array[ra+1]=Ua.g,na.array[ra+2]=Ua.b,ra+=3;else for(Ga=0;Ga<Ab;Ga++)Ua=na.value[Ga],na.array[ra]=Ua.x,na.array[ra+1]=Ua.y,na.array[ra+2]=Ua.z,ra+=3;else if(4===
na.size)for(Ga=0;Ga<Ab;Ga++)Ua=na.value[Ga],na.array[ra]=Ua.x,na.array[ra+1]=Ua.y,na.array[ra+2]=Ua.z,na.array[ra+3]=Ua.w,ra+=4;m.bindBuffer(m.ARRAY_BUFFER,na.buffer);m.bufferData(m.ARRAY_BUFFER,na.array,Rb)}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;l.lineDistancesNeedUpdate=!1;s.attributes&&w(s)}else if(k instanceof THREE.ParticleSystem){s=d(k,l);q=s.attributes&&v(s);if(l.verticesNeedUpdate||l.colorsNeedUpdate||k.sortParticles||q){var nb=l,gc=m.DYNAMIC_DRAW,Jb=k,Va=void 0,ob=void 0,pb=void 0,
X=void 0,qb=void 0,tb=void 0,Xb=nb.vertices,hc=Xb.length,ic=nb.colors,pc=ic.length,wb=nb.__vertexArray,xb=nb.__colorArray,rb=nb.__sortArray,qc=nb.verticesNeedUpdate,rc=nb.colorsNeedUpdate,sb=nb.__webglCustomAttributesList,fb=void 0,Bb=void 0,ca=void 0,gb=void 0,ka=void 0,W=void 0;if(Jb.sortParticles){zb.copy(hb);zb.multiply(Jb.matrixWorld);for(Va=0;Va<hc;Va++)pb=Xb[Va],ua.copy(pb),ua.applyProjection(zb),rb[Va]=[ua.z,Va];rb.sort(n);for(Va=0;Va<hc;Va++)pb=Xb[rb[Va][1]],X=3*Va,wb[X]=pb.x,wb[X+1]=pb.y,
wb[X+2]=pb.z;for(ob=0;ob<pc;ob++)X=3*ob,tb=ic[rb[ob][1]],xb[X]=tb.r,xb[X+1]=tb.g,xb[X+2]=tb.b;if(sb)for(fb=0,Bb=sb.length;fb<Bb;fb++)if(W=sb[fb],void 0===W.boundTo||"vertices"===W.boundTo)if(X=0,gb=W.value.length,1===W.size)for(ca=0;ca<gb;ca++)qb=rb[ca][1],W.array[ca]=W.value[qb];else if(2===W.size)for(ca=0;ca<gb;ca++)qb=rb[ca][1],ka=W.value[qb],W.array[X]=ka.x,W.array[X+1]=ka.y,X+=2;else if(3===W.size)if("c"===W.type)for(ca=0;ca<gb;ca++)qb=rb[ca][1],ka=W.value[qb],W.array[X]=ka.r,W.array[X+1]=ka.g,
W.array[X+2]=ka.b,X+=3;else for(ca=0;ca<gb;ca++)qb=rb[ca][1],ka=W.value[qb],W.array[X]=ka.x,W.array[X+1]=ka.y,W.array[X+2]=ka.z,X+=3;else if(4===W.size)for(ca=0;ca<gb;ca++)qb=rb[ca][1],ka=W.value[qb],W.array[X]=ka.x,W.array[X+1]=ka.y,W.array[X+2]=ka.z,W.array[X+3]=ka.w,X+=4}else{if(qc)for(Va=0;Va<hc;Va++)pb=Xb[Va],X=3*Va,wb[X]=pb.x,wb[X+1]=pb.y,wb[X+2]=pb.z;if(rc)for(ob=0;ob<pc;ob++)tb=ic[ob],X=3*ob,xb[X]=tb.r,xb[X+1]=tb.g,xb[X+2]=tb.b;if(sb)for(fb=0,Bb=sb.length;fb<Bb;fb++)if(W=sb[fb],W.needsUpdate&&
(void 0===W.boundTo||"vertices"===W.boundTo))if(gb=W.value.length,X=0,1===W.size)for(ca=0;ca<gb;ca++)W.array[ca]=W.value[ca];else if(2===W.size)for(ca=0;ca<gb;ca++)ka=W.value[ca],W.array[X]=ka.x,W.array[X+1]=ka.y,X+=2;else if(3===W.size)if("c"===W.type)for(ca=0;ca<gb;ca++)ka=W.value[ca],W.array[X]=ka.r,W.array[X+1]=ka.g,W.array[X+2]=ka.b,X+=3;else for(ca=0;ca<gb;ca++)ka=W.value[ca],W.array[X]=ka.x,W.array[X+1]=ka.y,W.array[X+2]=ka.z,X+=3;else if(4===W.size)for(ca=0;ca<gb;ca++)ka=W.value[ca],W.array[X]=
ka.x,W.array[X+1]=ka.y,W.array[X+2]=ka.z,W.array[X+3]=ka.w,X+=4}if(qc||Jb.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,nb.__webglVertexBuffer),m.bufferData(m.ARRAY_BUFFER,wb,gc);if(rc||Jb.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,nb.__webglColorBuffer),m.bufferData(m.ARRAY_BUFFER,xb,gc);if(sb)for(fb=0,Bb=sb.length;fb<Bb;fb++)if(W=sb[fb],W.needsUpdate||Jb.sortParticles)m.bindBuffer(m.ARRAY_BUFFER,W.buffer),m.bufferData(m.ARRAY_BUFFER,W.array,gc)}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;s.attributes&&
w(s)}}};this.initMaterial=function(a,b,c,d){var e,f,g,h;a.addEventListener("dispose",Nb);var k,l,p,n,q;a instanceof THREE.MeshDepthMaterial?q="depth":a instanceof THREE.MeshNormalMaterial?q="normal":a instanceof THREE.MeshBasicMaterial?q="basic":a instanceof THREE.MeshLambertMaterial?q="lambert":a instanceof THREE.MeshPhongMaterial?q="phong":a instanceof THREE.LineBasicMaterial?q="basic":a instanceof THREE.LineDashedMaterial?q="dashed":a instanceof THREE.ParticleSystemMaterial&&(q="particle_basic");
if(q){var r=THREE.ShaderLib[q];a.uniforms=THREE.UniformsUtils.clone(r.uniforms);a.vertexShader=r.vertexShader;a.fragmentShader=r.fragmentShader}var s=e=0,t=0,u=r=0;for(f=b.length;u<f;u++)g=b[u],g.onlyShadow||(g instanceof THREE.DirectionalLight&&e++,g instanceof THREE.PointLight&&s++,g instanceof THREE.SpotLight&&t++,g instanceof THREE.HemisphereLight&&r++);f=s;g=t;h=r;t=r=0;for(s=b.length;t<s;t++)u=b[t],u.castShadow&&(u instanceof THREE.SpotLight&&r++,u instanceof THREE.DirectionalLight&&!u.shadowCascade&&
r++);n=r;ub&&d&&d.useVertexTexture?p=1024:(b=m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS),b=Math.floor((b-20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(b=Math.min(d.bones.length,b),b<d.bones.length&&console.warn("WebGLRenderer: too many bones - "+d.bones.length+", this GPU supports just "+b+" (try OpenGL instead of ANGLE)")),p=b);a:{t=a.fragmentShader;s=a.vertexShader;r=a.uniforms;b=a.attributes;u=a.defines;c={map:!!a.map,envMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,
specularMap:!!a.specularMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,skinning:a.skinning,maxBones:p,useVertexTexture:ub&&d&&d.useVertexTexture,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,maxDirLights:e,maxPointLights:f,maxSpotLights:g,maxHemiLights:h,maxShadows:n,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow,shadowMapType:this.shadowMapType,
shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,alphaTest:a.alphaTest,metal:a.metal,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide};d=a.index0AttributeName;var v,w,y;e=[];q?e.push(q):(e.push(t),e.push(s));for(w in u)e.push(w),e.push(u[w]);for(v in c)e.push(v),e.push(c[v]);q=e.join();v=0;for(w=R.length;v<w;v++)if(e=R[v],e.code===q){e.usedTimes++;l=e.program;break a}v="SHADOWMAP_TYPE_BASIC";c.shadowMapType===THREE.PCFShadowMap?
v="SHADOWMAP_TYPE_PCF":c.shadowMapType===THREE.PCFSoftShadowMap&&(v="SHADOWMAP_TYPE_PCF_SOFT");w=[];for(y in u)e=u[y],!1!==e&&(e="#define "+y+" "+e,w.push(e));e=w.join("\n");y=m.createProgram();w=["precision "+Y+" float;","precision "+Y+" int;",e,yb?"#define VERTEX_TEXTURES":"",I.gammaInput?"#define GAMMA_INPUT":"",I.gammaOutput?"#define GAMMA_OUTPUT":"","#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+
c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,"#define MAX_BONES "+c.maxBones,c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.skinning?"#define USE_SKINNING":"",c.useVertexTexture?"#define BONE_TEXTURE":"",c.morphTargets?"#define USE_MORPHTARGETS":"",c.morphNormals?"#define USE_MORPHNORMALS":
"",c.wrapAround?"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+v:"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"",c.sizeAttenuation?"#define USE_SIZEATTENUATION":"","uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n");
v=["precision "+Y+" float;","precision "+Y+" int;",c.bumpMap||c.normalMap?"#extension GL_OES_standard_derivatives : enable":"",e,"#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,c.alphaTest?"#define ALPHATEST "+c.alphaTest:"",I.gammaInput?"#define GAMMA_INPUT":"",I.gammaOutput?"#define GAMMA_OUTPUT":"",c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&
c.fogExp?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.metal?"#define METAL":"",c.wrapAround?"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+v:
"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"","uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n");w=K("vertex",w+s);v=K("fragment",v+t);m.attachShader(y,w);m.attachShader(y,v);void 0!==d?m.bindAttribLocation(y,0,d):m.bindAttribLocation(y,0,"position");m.linkProgram(y);m.getProgramParameter(y,m.LINK_STATUS)||(console.error("Could not initialise shader\nVALIDATE_STATUS: "+m.getProgramParameter(y,m.VALIDATE_STATUS)+", gl error ["+
m.getError()+"]"),console.error("Program Info Log: "+m.getProgramInfoLog(y)));m.deleteShader(v);m.deleteShader(w);y.uniforms={};y.attributes={};var x;v="viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" ");c.useVertexTexture?(v.push("boneTexture"),v.push("boneTextureWidth"),v.push("boneTextureHeight")):v.push("boneGlobalMatrices");for(x in r)v.push(x);x=v;v=0;for(w=x.length;v<w;v++)r=x[v],y.uniforms[r]=m.getUniformLocation(y,r);v="position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
for(x=0;x<c.maxMorphTargets;x++)v.push("morphTarget"+x);for(x=0;x<c.maxMorphNormals;x++)v.push("morphNormal"+x);for(l in b)v.push(l);l=v;x=0;for(b=l.length;x<b;x++)v=l[x],y.attributes[v]=m.getAttribLocation(y,v);y.id=Z++;R.push({program:y,code:q,usedTimes:1});I.info.memory.programs=R.length;l=y}a.program=l;x=a.program.attributes;if(a.morphTargets)for(a.numSupportedMorphTargets=0,b="morphTarget",l=0;l<this.maxMorphTargets;l++)y=b+l,0<=x[y]&&a.numSupportedMorphTargets++;if(a.morphNormals)for(a.numSupportedMorphNormals=
0,b="morphNormal",l=0;l<this.maxMorphNormals;l++)y=b+l,0<=x[y]&&a.numSupportedMorphNormals++;a.uniformsList=[];for(k in a.uniforms)a.uniformsList.push([a.uniforms[k],k])};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?m.disable(m.CULL_FACE):(b===THREE.FrontFaceDirectionCW?m.frontFace(m.CW):m.frontFace(m.CCW),a===THREE.CullFaceBack?m.cullFace(m.BACK):a===THREE.CullFaceFront?m.cullFace(m.FRONT):m.cullFace(m.FRONT_AND_BACK),m.enable(m.CULL_FACE))};this.setMaterialFaces=function(a){var b=a.side===
THREE.DoubleSide;a=a.side===THREE.BackSide;xa!==b&&(b?m.disable(m.CULL_FACE):m.enable(m.CULL_FACE),xa=b);ya!==a&&(a?m.frontFace(m.CW):m.frontFace(m.CCW),ya=a)};this.setDepthTest=function(a){Za!==a&&(a?m.enable(m.DEPTH_TEST):m.disable(m.DEPTH_TEST),Za=a)};this.setDepthWrite=function(a){Ja!==a&&(m.depthMask(a),Ja=a)};this.setBlending=function(a,b,c,d){a!==Ma&&(a===THREE.NoBlending?m.disable(m.BLEND):a===THREE.AdditiveBlending?(m.enable(m.BLEND),m.blendEquation(m.FUNC_ADD),m.blendFunc(m.SRC_ALPHA,m.ONE)):
a===THREE.SubtractiveBlending?(m.enable(m.BLEND),m.blendEquation(m.FUNC_ADD),m.blendFunc(m.ZERO,m.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?(m.enable(m.BLEND),m.blendEquation(m.FUNC_ADD),m.blendFunc(m.ZERO,m.SRC_COLOR)):a===THREE.CustomBlending?m.enable(m.BLEND):(m.enable(m.BLEND),m.blendEquationSeparate(m.FUNC_ADD,m.FUNC_ADD),m.blendFuncSeparate(m.SRC_ALPHA,m.ONE_MINUS_SRC_ALPHA,m.ONE,m.ONE_MINUS_SRC_ALPHA)),Ma=a);if(a===THREE.CustomBlending){if(b!==Da&&(m.blendEquation(B(b)),Da=b),c!==Ha||
d!==Na)m.blendFunc(B(c),B(d)),Ha=c,Na=d}else Na=Ha=Da=null};this.setTexture=function(a,b){if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.addEventListener("dispose",Db),a.__webglTexture=m.createTexture(),I.info.memory.textures++);m.activeTexture(m.TEXTURE0+b);m.bindTexture(m.TEXTURE_2D,a.__webglTexture);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL,a.flipY);m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha);m.pixelStorei(m.UNPACK_ALIGNMENT,a.unpackAlignment);var c=a.image,d=THREE.Math.isPowerOfTwo(c.width)&&
THREE.Math.isPowerOfTwo(c.height),e=B(a.format),f=B(a.type);x(m.TEXTURE_2D,a,d);var g=a.mipmaps;if(a instanceof THREE.DataTexture)if(0<g.length&&d){for(var h=0,k=g.length;h<k;h++)c=g[h],m.texImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);a.generateMipmaps=!1}else m.texImage2D(m.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data);else if(a instanceof THREE.CompressedTexture)for(h=0,k=g.length;h<k;h++)c=g[h],a.format!==THREE.RGBAFormat?m.compressedTexImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,c.data):
m.texImage2D(m.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);else if(0<g.length&&d){h=0;for(k=g.length;h<k;h++)c=g[h],m.texImage2D(m.TEXTURE_2D,h,e,e,f,c);a.generateMipmaps=!1}else m.texImage2D(m.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&m.generateMipmap(m.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else m.activeTexture(m.TEXTURE0+b),m.bindTexture(m.TEXTURE_2D,a.__webglTexture)};this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===
a.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=!0);a.addEventListener("dispose",Mb);a.__webglTexture=m.createTexture();I.info.memory.textures++;var c=THREE.Math.isPowerOfTwo(a.width)&&THREE.Math.isPowerOfTwo(a.height),d=B(a.format),e=B(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];m.bindTexture(m.TEXTURE_CUBE_MAP,a.__webglTexture);x(m.TEXTURE_CUBE_MAP,a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=m.createFramebuffer();a.__webglRenderbuffer[f]=m.createRenderbuffer();
m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var g=a,h=m.TEXTURE_CUBE_MAP_POSITIVE_X+f;m.bindFramebuffer(m.FRAMEBUFFER,a.__webglFramebuffer[f]);m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,h,g.__webglTexture,0);N(a.__webglRenderbuffer[f],a)}c&&m.generateMipmap(m.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=m.createFramebuffer(),a.__webglRenderbuffer=a.shareDepthFrom?a.shareDepthFrom.__webglRenderbuffer:m.createRenderbuffer(),m.bindTexture(m.TEXTURE_2D,a.__webglTexture),
x(m.TEXTURE_2D,a,c),m.texImage2D(m.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=m.TEXTURE_2D,m.bindFramebuffer(m.FRAMEBUFFER,a.__webglFramebuffer),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,d,a.__webglTexture,0),a.shareDepthFrom?a.depthBuffer&&!a.stencilBuffer?m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,a.__webglRenderbuffer):a.depthBuffer&&a.stencilBuffer&&m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_STENCIL_ATTACHMENT,m.RENDERBUFFER,a.__webglRenderbuffer):
N(a.__webglRenderbuffer,a),c&&m.generateMipmap(m.TEXTURE_2D);b?m.bindTexture(m.TEXTURE_CUBE_MAP,null):m.bindTexture(m.TEXTURE_2D,null);m.bindRenderbuffer(m.RENDERBUFFER,null);m.bindFramebuffer(m.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=Qa,a=Aa,d=Oa,e=Pa);b!==Ia&&(m.bindFramebuffer(m.FRAMEBUFFER,b),m.viewport(d,e,c,a),Ia=b);Ra=c;Ba=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);
this.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:
THREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};
THREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;a.shareDepthFrom=this.shareDepthFrom;
return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.RenderableVertex=function(){this.position=new THREE.Vector3;this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};THREE.RenderableFace3=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.centroidModel=new THREE.Vector3;this.normalModel=new THREE.Vector3;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsLength=0;this.material=this.color=null;this.uvs=[[]];this.z=0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};THREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};THREE.GeometryUtils={merge:function(a,b,c){var d,e,f=a.vertices.length,g=b instanceof THREE.Mesh?b.geometry:b,h=a.vertices,k=g.vertices,l=a.faces,n=g.faces;a=a.faceVertexUvs[0];g=g.faceVertexUvs[0];void 0===c&&(c=0);b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,e=(new THREE.Matrix3).getNormalMatrix(d));b=0;for(var q=k.length;b<q;b++){var s=k[b].clone();d&&s.applyMatrix4(d);h.push(s)}b=0;for(q=n.length;b<q;b++){var s=n[b],u,t,p=s.vertexNormals,v=s.vertexColors;u=new THREE.Face3(s.a+
f,s.b+f,s.c+f);u.normal.copy(s.normal);e&&u.normal.applyMatrix3(e).normalize();h=0;for(k=p.length;h<k;h++)t=p[h].clone(),e&&t.applyMatrix3(e).normalize(),u.vertexNormals.push(t);u.color.copy(s.color);h=0;for(k=v.length;h<k;h++)t=v[h],u.vertexColors.push(t.clone());u.materialIndex=s.materialIndex+c;u.centroid.copy(s.centroid);d&&u.centroid.applyMatrix4(d);l.push(u)}b=0;for(q=g.length;b<q;b++){c=g[b];d=[];h=0;for(k=c.length;h<k;h++)d.push(new THREE.Vector2(c[h].x,c[h].y));a.push(d)}},randomPointInTriangle:function(){var a=
new THREE.Vector3;return function(b,c,d){var e=new THREE.Vector3,f=THREE.Math.random16(),g=THREE.Math.random16();1<f+g&&(f=1-f,g=1-g);var h=1-f-g;e.copy(b);e.multiplyScalar(f);a.copy(c);a.multiplyScalar(g);e.add(a);a.copy(d);a.multiplyScalar(h);e.add(a);return e}}(),randomPointInFace:function(a,b,c){return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a],b.vertices[a.b],b.vertices[a.c])},randomPointsInGeometry:function(a,b){function c(a){function b(c,d){if(d<c)return c;var e=c+Math.floor((d-
c)/2);return l[e]>a?b(c,e-1):l[e]<a?b(e+1,d):e}return b(0,l.length-1)}var d,e,f=a.faces,g=a.vertices,h=f.length,k=0,l=[],n,q,s;for(e=0;e<h;e++)d=f[e],n=g[d.a],q=g[d.b],s=g[d.c],d._area=THREE.GeometryUtils.triangleArea(n,q,s),k+=d._area,l[e]=k;d=[];for(e=0;e<b;e++)g=THREE.Math.random16()*k,g=c(g),d[e]=THREE.GeometryUtils.randomPointInFace(f[g],a,!0);return d},triangleArea:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){a.subVectors(d,c);b.subVectors(e,c);a.cross(b);return 0.5*
a.length()}}(),center:function(a){a.computeBoundingBox();var b=a.boundingBox,c=new THREE.Vector3;c.addVectors(b.min,b.max);c.multiplyScalar(-0.5);a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z));a.computeBoundingBox();return c},triangulateQuads:function(a){var b,c,d,e,f=[],g=[];b=0;for(c=a.faceVertexUvs.length;b<c;b++)g[b]=[];b=0;for(c=a.faces.length;b<c;b++)for(f.push(a.faces[b]),d=0,e=a.faceVertexUvs.length;d<e;d++)g[d].push(a.faceVertexUvs[d][b]);a.faces=f;a.faceVertexUvs=g;a.computeCentroids();
a.computeFaceNormals();a.computeVertexNormals();a.hasTangents&&a.computeTangents()}};THREE.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c,d){d=new THREE.ImageLoader;d.crossOrigin=this.crossOrigin;var e=new THREE.Texture(void 0,b);b=d.load(a,function(){e.needsUpdate=!0;c&&c(e)});e.image=b;e.sourceFile=a;return e},loadCompressedTexture:function(a,b,c,d){var e=new THREE.CompressedTexture;e.mapping=b;var f=new XMLHttpRequest;f.onload=function(){var a=THREE.ImageUtils.parseDDS(f.response,!0);e.format=a.format;e.mipmaps=a.mipmaps;e.image.width=a.width;e.image.height=a.height;
e.generateMipmaps=!1;e.needsUpdate=!0;c&&c(e)};f.onerror=d;f.open("GET",a,!0);f.responseType="arraybuffer";f.send(null);return e},loadTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.Texture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;b=0;for(var g=a.length;b<g;++b){var h=new Image;e[b]=h;h.onload=function(){e.loadCount+=1;6===e.loadCount&&(f.needsUpdate=!0,c&&c(f))};h.onerror=d;h.crossOrigin=this.crossOrigin;h.src=a[b]}return f},loadCompressedTextureCube:function(a,b,c,d){var e=
[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;b=function(a,b){return function(){var d=THREE.ImageUtils.parseDDS(a.response,!0);b.format=d.format;b.mipmaps=d.mipmaps;b.width=d.width;b.height=d.height;e.loadCount+=1;6===e.loadCount&&(f.format=d.format,f.needsUpdate=!0,c&&c(f))}};if(a instanceof Array)for(var g=0,h=a.length;g<h;++g){var k={};e[g]=k;var l=new XMLHttpRequest;l.onload=b(l,k);l.onerror=d;k=a[g];l.open("GET",k,!0);l.responseType=
"arraybuffer";l.send(null)}else l=new XMLHttpRequest,l.onload=function(){var a=THREE.ImageUtils.parseDDS(l.response,!0);if(a.isCubemap){for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var g=0;g<a.mipmapCount;g++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+g]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}f.format=a.format;f.needsUpdate=!0;c&&c(f)}},l.onerror=d,l.open("GET",a,!0),l.responseType="arraybuffer",l.send(null);return f},loadDDSTexture:function(a,
b,c,d){var e=[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;var g=new XMLHttpRequest;g.onload=function(){var a=THREE.ImageUtils.parseDDS(g.response,!0);if(a.isCubemap)for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var n=0;n<a.mipmapCount;n++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+n]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}else f.image.width=a.width,f.image.height=a.height,
f.mipmaps=a.mipmaps;f.format=a.format;f.needsUpdate=!0;c&&c(f)};g.onerror=d;g.open("GET",a,!0);g.responseType="arraybuffer";g.send(null);return f},parseDDS:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}function d(a,b,c,d){var e=c*d*4;a=new Uint8Array(a,b,e);for(var e=new Uint8Array(e),f=b=0,g=0;g<d;g++)for(var h=0;h<c;h++){var k=a[f];f++;var l=a[f];f++;var n=a[f];f++;var q=a[f];f++;e[b]=n;b++;e[b]=l;b++;e[b]=k;b++;e[b]=q;b++}return e}
var e={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},f=c("DXT1"),g=c("DXT3"),h=c("DXT5"),k=new Int32Array(a,0,31);if(542327876!==k[0])return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"),e;if(!k[20]&4)return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"),e;var l=k[21],n=!1;switch(l){case f:f=8;e.format=THREE.RGB_S3TC_DXT1_Format;break;case g:f=16;e.format=THREE.RGBA_S3TC_DXT3_Format;break;case h:f=16;e.format=THREE.RGBA_S3TC_DXT5_Format;
break;default:if(32==k[22]&&k[23]&16711680&&k[24]&65280&&k[25]&255&&k[26]&4278190080)n=!0,f=64,e.format=THREE.RGBAFormat;else return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ",String.fromCharCode(l&255,l>>8&255,l>>16&255,l>>24&255)),e}e.mipmapCount=1;k[2]&131072&&!1!==b&&(e.mipmapCount=Math.max(1,k[7]));e.isCubemap=k[28]&512?!0:!1;e.width=k[4];e.height=k[3];for(var k=k[1]+4,g=e.width,h=e.height,l=e.isCubemap?6:1,q=0;q<l;q++){for(var s=0;s<e.mipmapCount;s++){if(n)var u=d(a,k,
g,h),t=u.length;else t=Math.max(4,g)/4*Math.max(4,h)/4*f,u=new Uint8Array(a,k,t);e.mipmaps.push({data:u,width:g,height:h});k+=t;g=Math.max(0.5*g,1);h=Math.max(0.5*h,1)}g=e.width;h=e.height}return e},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]};b|=1;var d=a.width,e=a.height,f=document.createElement("canvas");f.width=d;f.height=e;var g=f.getContext("2d");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,k=g.createImageData(d,
e),l=k.data,n=0;n<d;n++)for(var q=0;q<e;q++){var s=0>q-1?0:q-1,u=q+1>e-1?e-1:q+1,t=0>n-1?0:n-1,p=n+1>d-1?d-1:n+1,v=[],w=[0,0,h[4*(q*d+n)]/255*b];v.push([-1,0,h[4*(q*d+t)]/255*b]);v.push([-1,-1,h[4*(s*d+t)]/255*b]);v.push([0,-1,h[4*(s*d+n)]/255*b]);v.push([1,-1,h[4*(s*d+p)]/255*b]);v.push([1,0,h[4*(q*d+p)]/255*b]);v.push([1,1,h[4*(u*d+p)]/255*b]);v.push([0,1,h[4*(u*d+n)]/255*b]);v.push([-1,1,h[4*(u*d+t)]/255*b]);s=[];t=v.length;for(u=0;u<t;u++){var p=v[u],r=v[(u+1)%t],p=[p[0]-w[0],p[1]-w[1],p[2]-w[2]],
r=[r[0]-w[0],r[1]-w[1],r[2]-w[2]];s.push(c([p[1]*r[2]-p[2]*r[1],p[2]*r[0]-p[0]*r[2],p[0]*r[1]-p[1]*r[0]]))}v=[0,0,0];for(u=0;u<s.length;u++)v[0]+=s[u][0],v[1]+=s[u][1],v[2]+=s[u][2];v[0]/=s.length;v[1]/=s.length;v[2]/=s.length;w=4*(q*d+n);l[w]=(v[0]+1)/2*255|0;l[w+1]=(v[1]+1)/2*255|0;l[w+2]=255*v[2]|0;l[w+3]=255}g.putImageData(k,0,0);return f},generateDataTexture:function(a,b,c){var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g);c=Math.floor(255*c.b);for(var h=0;h<d;h++)e[3*
h]=f,e[3*h+1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};THREE.FontUtils={faces:{},face:"helvetiker",weight:"normal",style:"normal",size:150,divisions:10,getFace:function(){return this.faces[this.face][this.weight][this.style]},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=a},drawText:function(a){var b=this.getFace(),c=this.size/b.resolution,d=0,e=
String(a).split(""),f=e.length,g=[];for(a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,k,l,n,q,s,u,t,p,v,w=b.glyphs[a]||b.glyphs["?"];if(w){if(w.o)for(b=w._cachedOutline||(w._cachedOutline=w.o.split(" ")),l=b.length,a=0;a<l;)switch(k=b[a++],k){case "m":k=b[a++]*c+d;n=b[a++]*c;e.moveTo(k,n);break;case "l":k=b[a++]*c+d;n=b[a++]*c;e.lineTo(k,n);break;case "q":k=b[a++]*
c+d;n=b[a++]*c;u=b[a++]*c+d;t=b[a++]*c;e.quadraticCurveTo(u,t,k,n);if(g=f[f.length-1])for(q=g.x,s=g.y,g=1,h=this.divisions;g<=h;g++){var r=g/h;THREE.Shape.Utils.b2(r,q,u,k);THREE.Shape.Utils.b2(r,s,t,n)}break;case "b":if(k=b[a++]*c+d,n=b[a++]*c,u=b[a++]*c+d,t=b[a++]*-c,p=b[a++]*c+d,v=b[a++]*-c,e.bezierCurveTo(k,n,u,t,p,v),g=f[f.length-1])for(q=g.x,s=g.y,g=1,h=this.divisions;g<=h;g++)r=g/h,THREE.Shape.Utils.b3(r,q,u,p,k),THREE.Shape.Utils.b3(r,s,t,v,n)}return{offset:w.ha*c,path:e}}}};
THREE.FontUtils.generateShapes=function(a,b){b=b||{};var c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:"helvetiker",e=void 0!==b.weight?b.weight:"normal",f=void 0!==b.style?b.style:"normal";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};
(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e+=a[f].x*a[g].y-a[g].x*a[f].y;return 0.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],g=[],h=[],k,l,n;if(0<b(a))for(l=0;l<e;l++)g[l]=l;else for(l=0;l<e;l++)g[l]=e-1-l;var q=2*e;for(l=e-1;2<e;){if(0>=q--){console.log("Warning, unable to triangulate polygon!");break}k=l;e<=k&&(k=0);l=k+1;e<=l&&(l=0);n=l+1;e<=n&&(n=0);var s;a:{var u=s=void 0,t=void 0,p=void 0,v=void 0,w=void 0,r=void 0,y=void 0,E=
void 0,u=a[g[k]].x,t=a[g[k]].y,p=a[g[l]].x,v=a[g[l]].y,w=a[g[n]].x,r=a[g[n]].y;if(1E-10>(p-u)*(r-t)-(v-t)*(w-u))s=!1;else{var z=void 0,P=void 0,J=void 0,A=void 0,C=void 0,M=void 0,H=void 0,K=void 0,x=void 0,N=void 0,x=K=H=E=y=void 0,z=w-p,P=r-v,J=u-w,A=t-r,C=p-u,M=v-t;for(s=0;s<e;s++)if(y=a[g[s]].x,E=a[g[s]].y,!(y===u&&E===t||y===p&&E===v||y===w&&E===r)&&(H=y-u,K=E-t,x=y-p,N=E-v,y-=w,E-=r,x=z*N-P*x,H=C*K-M*H,K=J*E-A*y,-1E-10<=x&&-1E-10<=K&&-1E-10<=H)){s=!1;break a}s=!0}}if(s){f.push([a[g[k]],a[g[l]],
a[g[n]]]);h.push([g[k],g[l],g[n]]);k=l;for(n=l+1;n<e;k++,n++)g[k]=g[n];e--;q=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(a){console.log("Warning, getPoint() not implemented!");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};THREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};
THREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};THREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b};
THREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=!0;this.getLengths()};THREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-1,k;g<=h;)if(d=Math.floor(g+(h-g)/2),k=c[d]-f,0>k)g=d+1;else if(0<k)h=d-1;else{h=d;break}d=h;if(c[d]==f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)};THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()};
THREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};
THREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a,b,c,d,e){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){a=0.5*(c-a);d=0.5*(d-b);var f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};
THREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=!1};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};THREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};
THREE.CurvePath.prototype.getPoint=function(a){var b=a*this.getLength(),c=this.getCurveLengths();for(a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],b=1-b/a.getLength(),a.getPointAt(b);a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};
THREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a};
THREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,g;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var h,k,l,n,q=a[0]instanceof THREE.Vector3;n=q?new THREE.Vector3:new THREE.Vector2;k=0;for(l=a.length;k<l;k++)h=a[k],h.x>b?b=h.x:h.x<e&&(e=h.x),h.y>c?c=h.y:h.y<f&&(f=h.y),q&&(h.z>d?d=h.z:h.z<g&&(g=h.z)),n.add(h);a={minX:e,minY:f,maxX:b,maxY:c,centroid:n.divideScalar(l)};q&&(a.maxZ=d,a.minZ=g);return a};
THREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};
THREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};
THREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,g,h,k;d=0;for(e=a.length;d<e;d++)f=a[d],g=f.x,h=f.y,k=g/c.maxX,k=b.getUtoTmapping(k,g),g=b.getPoint(k),k=b.getTangent(k),k.set(-k.y,k.x).multiplyScalar(h),f.x=g.x+k.x,f.y=g.y+k.y;return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),
this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:"moveTo",LINE_TO:"lineTo",QUADRATIC_CURVE_TO:"quadraticCurveTo",BEZIER_CURVE_TO:"bezierCurveTo",CSPLINE_THRU:"splineThru",ARC:"arc",ELLIPSE:"ellipse"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};
THREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};
THREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};
THREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var g=Array.prototype.slice.call(arguments),h=this.actions[this.actions.length-1].args,h=new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length-2],h[h.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(h);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:g})};
THREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-1],c,d,e,f)};
THREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,g){var h=this.actions[this.actions.length-1].args;this.absellipse(a+h[h.length-2],b+h[h.length-1],c,d,e,f,g)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,g){var h=Array.prototype.slice.call(arguments),k=new THREE.EllipseCurve(a,b,c,d,e,f,g);this.curves.push(k);k=k.getPoint(1);h.push(k.x);h.push(k.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:h})};
THREE.Path.prototype.getSpacedPoints=function(a,b){a||(a=40);for(var c=[],d=0;d<a;d++)c.push(this.getPoint(d/a));return c};
THREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints)return console.log("tata"),this.getSpacedPoints(a,b);a=a||12;var c=[],d,e,f,g,h,k,l,n,q,s,u,t,p;d=0;for(e=this.actions.length;d<e;d++)switch(f=this.actions[d],g=f.action,f=f.args,g){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:h=f[2];k=f[3];q=f[0];s=f[1];0<c.length?(g=c[c.length-1],u=g.x,
t=g.y):(g=this.actions[d-1].args,u=g[g.length-2],t=g[g.length-1]);for(f=1;f<=a;f++)p=f/a,g=THREE.Shape.Utils.b2(p,u,q,h),p=THREE.Shape.Utils.b2(p,t,s,k),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.BEZIER_CURVE_TO:h=f[4];k=f[5];q=f[0];s=f[1];l=f[2];n=f[3];0<c.length?(g=c[c.length-1],u=g.x,t=g.y):(g=this.actions[d-1].args,u=g[g.length-2],t=g[g.length-1]);for(f=1;f<=a;f++)p=f/a,g=THREE.Shape.Utils.b3(p,u,q,l,h),p=THREE.Shape.Utils.b3(p,t,s,n,k),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.CSPLINE_THRU:g=
this.actions[d-1].args;p=[new THREE.Vector2(g[g.length-2],g[g.length-1])];g=a*f[0].length;p=p.concat(f[0]);p=new THREE.SplineCurve(p);for(f=1;f<=g;f++)c.push(p.getPointAt(f/g));break;case THREE.PathActions.ARC:h=f[0];k=f[1];s=f[2];l=f[3];g=f[4];q=!!f[5];u=g-l;t=2*a;for(f=1;f<=t;f++)p=f/t,q||(p=1-p),p=l+p*u,g=h+s*Math.cos(p),p=k+s*Math.sin(p),c.push(new THREE.Vector2(g,p));break;case THREE.PathActions.ELLIPSE:for(h=f[0],k=f[1],s=f[2],n=f[3],l=f[4],g=f[5],q=!!f[6],u=g-l,t=2*a,f=1;f<=t;f++)p=f/t,q||
(p=1-p),p=l+p*u,g=h+s*Math.cos(p),p=k+n*Math.sin(p),c.push(new THREE.Vector2(g,p))}d=c[c.length-1];1E-10>Math.abs(d.x-c[0].x)&&1E-10>Math.abs(d.y-c[0].y)&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};
THREE.Path.prototype.toShapes=function(a){function b(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,l=h.y-g.y;if(1E-10<Math.abs(l)){if(0>l&&(g=b[f],k=-k,h=b[e],l=-l),!(a.y<g.y||a.y>h.y))if(a.y==g.y){if(a.x==g.x)return!0}else{e=l*(a.x-g.x)-k*(a.y-g.y);if(0==e)return!0;0>e||(d=!d)}}else if(a.y==g.y&&(h.x<=a.x&&a.x<=g.x||g.x<=a.x&&a.x<=h.x))return!0}return d}var c,d,e,f,g=[],h=new THREE.Path;c=0;for(d=this.actions.length;c<d;c++)e=this.actions[c],f=e.args,e=e.action,e==
THREE.PathActions.MOVE_TO&&0!=h.actions.length&&(g.push(h),h=new THREE.Path),h[e].apply(h,f);0!=h.actions.length&&g.push(h);if(0==g.length)return[];var k,l,n;f=[];if(1==g.length)return l=g[0],n=new THREE.Shape,n.actions=l.actions,n.curves=l.curves,f.push(n),f;var q=!THREE.Shape.Utils.isClockWise(g[0].getPoints()),q=a?!q:q;n=[];h=[];e=[];var s=0,u;h[s]=void 0;e[s]=[];c=0;for(d=g.length;c<d;c++)l=g[c],u=l.getPoints(),k=THREE.Shape.Utils.isClockWise(u),(k=a?!k:k)?(!q&&h[s]&&s++,h[s]={s:new THREE.Shape,
p:u},h[s].s.actions=l.actions,h[s].s.curves=l.curves,q&&s++,e[s]=[]):e[s].push({h:l,p:u[0]});if(1<h.length){c=!1;d=[];a=0;for(g=h.length;a<g;a++)n[a]=[];a=0;for(g=h.length;a<g;a++)for(l=e[a],k=0;k<l.length;k++){q=l[k];s=!0;for(u=0;u<h.length;u++)b(q.p,h[u].p)&&(a!=u&&d.push({froms:a,tos:u,hole:k}),s?(s=!1,n[u].push(q)):c=!0);s&&n[a].push(q)}0<d.length&&(c||(e=n))}c=0;for(d=h.length;c<d;c++)for(n=h[c].s,f.push(n),a=e[c],g=0,l=a.length;g<l;g++)n.holes.push(a[g].h);return f};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};THREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};
THREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};THREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};
THREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};
THREE.Shape.Utils={triangulateShape:function(a,b){function c(a,b,c){return a.x!=b.x?a.x<b.x?a.x<=c.x&&c.x<=b.x:b.x<=c.x&&c.x<=a.x:a.y<b.y?a.y<=c.y&&c.y<=b.y:b.y<=c.y&&c.y<=a.y}function d(a,b,d,e,f){var g=b.x-a.x,h=b.y-a.y,k=e.x-d.x,l=e.y-d.y,n=a.x-d.x,q=a.y-d.y,J=h*k-g*l,A=h*n-g*q;if(1E-10<Math.abs(J)){if(0<J){if(0>A||A>J)return[];k=l*n-k*q;if(0>k||k>J)return[]}else{if(0<A||A<J)return[];k=l*n-k*q;if(0<k||k<J)return[]}if(0==k)return!f||0!=A&&A!=J?[a]:[];if(k==J)return!f||0!=A&&A!=J?[b]:[];if(0==A)return[d];
if(A==J)return[e];f=k/J;return[{x:a.x+f*g,y:a.y+f*h}]}if(0!=A||l*n!=k*q)return[];h=0==g&&0==h;k=0==k&&0==l;if(h&&k)return a.x!=d.x||a.y!=d.y?[]:[a];if(h)return c(d,e,a)?[a]:[];if(k)return c(a,b,d)?[d]:[];0!=g?(a.x<b.x?(g=a,k=a.x,h=b,a=b.x):(g=b,k=b.x,h=a,a=a.x),d.x<e.x?(b=d,J=d.x,l=e,d=e.x):(b=e,J=e.x,l=d,d=d.x)):(a.y<b.y?(g=a,k=a.y,h=b,a=b.y):(g=b,k=b.y,h=a,a=a.y),d.y<e.y?(b=d,J=d.y,l=e,d=e.y):(b=e,J=e.y,l=d,d=d.y));return k<=J?a<J?[]:a==J?f?[]:[b]:a<=d?[b,h]:[b,l]:k>d?[]:k==d?f?[]:[g]:a<=d?[g,h]:
[g,l]}function e(a,b,c,d){var e=b.x-a.x,f=b.y-a.y;b=c.x-a.x;c=c.y-a.y;var g=d.x-a.x;d=d.y-a.y;a=e*c-f*b;e=e*d-f*g;return 1E-10<Math.abs(a)?(b=g*c-d*b,0<a?0<=e&&0<=b:0<=e||0<=b):0<e}var f,g,h,k,l,n={};h=a.concat();for(f in b)Array.prototype.push.apply(h,b[f]);f=0;for(g=h.length;f<g;f++)l=h[f].x+":"+h[f].y,void 0!==n[l]&&console.log("Duplicate point",l),n[l]=f;f=function(a,b){function c(a,b){var d=h.length-1,f=a-1;0>f&&(f=d);var g=a+1;g>d&&(g=0);d=e(h[a],h[f],h[g],k[b]);if(!d)return!1;d=k.length-1;
f=b-1;0>f&&(f=d);g=b+1;g>d&&(g=0);return(d=e(k[b],k[f],k[g],h[a]))?!0:!1}function f(a,b){var c,e;for(c=0;c<h.length;c++)if(e=c+1,e%=h.length,e=d(a,b,h[c],h[e],!0),0<e.length)return!0;return!1}function g(a,c){var e,f,h,k;for(e=0;e<l.length;e++)for(f=b[l[e]],h=0;h<f.length;h++)if(k=h+1,k%=f.length,k=d(a,c,f[h],f[k],!0),0<k.length)return!0;return!1}var h=a.concat(),k,l=[],n,q,P,J,A,C,M,H=[],K,x;for(J in b)l.push(J);for(var N=2*l.length;0<l.length;){N--;if(0>N){console.log("Infinite Loop! Holes left:"+
l.length+", Probably Hole outside Shape!");break}for(q=0;q<h.length;q++){P=h[q];n=-1;for(J=0;J<l.length;J++)if(A=l[J],M=P.x+":"+P.y+":"+A,void 0===H[M]){k=b[A];for(A=0;A<k.length;A++)if(C=k[A],c(q,A)&&!f(P,C)&&!g(P,C)){n=A;l.splice(J,1);A=h.slice(0,q+1);C=h.slice(q);K=k.slice(n);x=k.slice(0,n+1);h=A.concat(K).concat(x).concat(C);break}if(0<=n)break;H[M]=!0}if(0<=n)break}}return h}(a,b);var q=THREE.FontUtils.Triangulate(f,!1);f=0;for(g=q.length;f<g;f++)for(k=q[f],h=0;3>h;h++)l=k[h].x+":"+k[h].y,l=
n[l],void 0!==l&&(k[h]=l);return q.concat()},isClockWise:function(a){return 0>THREE.FontUtils.Triangulate.area(a)},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,
b)+this.b3p1(a,c)+this.b3p2(a,d)+this.b3p3(a,e)}};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(a){return this.v2.clone().sub(this.v1).normalize()};THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};
THREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};
THREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.SplineCurve=function(a){this.points=void 0==a?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e-=a;c[0]=0==a?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};THREE.EllipseCurve=function(a,b,c,d,e,f,g){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint=function(a){var b;b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});THREE.SplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;a*=d.length-1;e=Math.floor(a);a-=e;c[0]=0==e?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],g=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,g.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,g.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,g.z,c.z,a);return b});THREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e-=a;a+=0<a?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length;c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,
d[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});THREE.AnimationHandler=function(){var a=[],b={},c={update:function(b){for(var c=0;c<a.length;c++)a[c].update(b)},addToUpdate:function(b){-1===a.indexOf(b)&&a.push(b)},removeFromUpdate:function(b){b=a.indexOf(b);-1!==b&&a.splice(b,1)},add:function(a){void 0!==b[a.name]&&console.log("THREE.AnimationHandler.add: Warning! "+a.name+" already exists in library. Overwriting.");b[a.name]=a;if(!0!==a.initialized){for(var c=0;c<a.hierarchy.length;c++){for(var d=0;d<a.hierarchy[c].keys.length;d++)if(0>a.hierarchy[c].keys[d].time&&
(a.hierarchy[c].keys[d].time=0),void 0!==a.hierarchy[c].keys[d].rot&&!(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)){var h=a.hierarchy[c].keys[d].rot;a.hierarchy[c].keys[d].rot=new THREE.Quaternion(h[0],h[1],h[2],h[3])}if(a.hierarchy[c].keys.length&&void 0!==a.hierarchy[c].keys[0].morphTargets){h={};for(d=0;d<a.hierarchy[c].keys.length;d++)for(var k=0;k<a.hierarchy[c].keys[d].morphTargets.length;k++){var l=a.hierarchy[c].keys[d].morphTargets[k];h[l]=-1}a.hierarchy[c].usedMorphTargets=h;
for(d=0;d<a.hierarchy[c].keys.length;d++){var n={};for(l in h){for(k=0;k<a.hierarchy[c].keys[d].morphTargets.length;k++)if(a.hierarchy[c].keys[d].morphTargets[k]===l){n[l]=a.hierarchy[c].keys[d].morphTargetsInfluences[k];break}k===a.hierarchy[c].keys[d].morphTargets.length&&(n[l]=0)}a.hierarchy[c].keys[d].morphTargetsInfluences=n}}for(d=1;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].time===a.hierarchy[c].keys[d-1].time&&(a.hierarchy[c].keys.splice(d,1),d--);for(d=0;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].index=
d}a.initialized=!0}},get:function(a){if("string"===typeof a){if(b[a])return b[a];console.log("THREE.AnimationHandler.get: Couldn't find animation "+a);return null}},parse:function(a){var b=[];if(a instanceof THREE.SkinnedMesh)for(var c=0;c<a.bones.length;c++)b.push(a.bones[c]);else d(a,b);return b}},d=function(a,b){b.push(a);for(var c=0;c<a.children.length;c++)d(a.children[c],b)};c.LINEAR=0;c.CATMULLROM=1;c.CATMULLROM_FORWARD=2;return c}();THREE.Animation=function(a,b){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=this.isPaused=!0;this.interpolationType=THREE.AnimationHandler.LINEAR;this.points=[];this.target=new THREE.Vector3};THREE.Animation.prototype.play=function(a){this.currentTime=void 0!==a?a:0;!1===this.isPlaying&&(this.isPlaying=!0,this.reset(),this.update(0));this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};
THREE.Animation.prototype.pause=function(){!0===this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};THREE.Animation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this)};
THREE.Animation.prototype.reset=function(){for(var a=0,b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a];c.matrixAutoUpdate=!0;void 0===c.animationCache&&(c.animationCache={},c.animationCache.prevKey={pos:0,rot:0,scl:0},c.animationCache.nextKey={pos:0,rot:0,scl:0},c.animationCache.originalMatrix=c instanceof THREE.Bone?c.skinMatrix:c.matrix);var d=c.animationCache.prevKey,c=c.animationCache.nextKey;d.pos=this.data.hierarchy[a].keys[0];d.rot=this.data.hierarchy[a].keys[0];d.scl=this.data.hierarchy[a].keys[0];
c.pos=this.getNextKeyWith("pos",a,1);c.rot=this.getNextKeyWith("rot",a,1);c.scl=this.getNextKeyWith("scl",a,1)}};
THREE.Animation.prototype.update=function(a){if(!1!==this.isPlaying){this.currentTime+=a*this.timeScale;var b;a=["pos","rot","scl"];var c=this.data.length;!0===this.loop&&this.currentTime>c&&(this.currentTime%=c,this.reset());this.currentTime=Math.min(this.currentTime,c);for(var d=0,e=this.hierarchy.length;d<e;d++)for(var f=this.hierarchy[d],g=f.animationCache,h=0;3>h;h++){b=a[h];var k=g.prevKey[b],l=g.nextKey[b];if(l.time<=this.currentTime){k=this.data.hierarchy[d].keys[0];for(l=this.getNextKeyWith(b,
d,1);l.time<this.currentTime&&l.index>k.index;)k=l,l=this.getNextKeyWith(b,d,l.index+1);g.prevKey[b]=k;g.nextKey[b]=l}f.matrixAutoUpdate=!0;f.matrixWorldNeedsUpdate=!0;var n=(this.currentTime-k.time)/(l.time-k.time),q=k[b],s=l[b];0>n&&(n=0);1<n&&(n=1);if("pos"===b)if(b=f.position,this.interpolationType===THREE.AnimationHandler.LINEAR)b.x=q[0]+(s[0]-q[0])*n,b.y=q[1]+(s[1]-q[1])*n,b.z=q[2]+(s[2]-q[2])*n;else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)this.points[0]=
this.getPrevKeyWith("pos",d,k.index-1).pos,this.points[1]=q,this.points[2]=s,this.points[3]=this.getNextKeyWith("pos",d,l.index+1).pos,n=0.33*n+0.33,k=this.interpolateCatmullRom(this.points,n),b.x=k[0],b.y=k[1],b.z=k[2],this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(n=this.interpolateCatmullRom(this.points,1.01*n),this.target.set(n[0],n[1],n[2]),this.target.sub(b),this.target.y=0,this.target.normalize(),b=Math.atan2(this.target.x,this.target.z),f.rotation.set(0,b,0))}else"rot"===
b?THREE.Quaternion.slerp(q,s,f.quaternion,n):"scl"===b&&(b=f.scale,b.x=q[0]+(s[0]-q[0])*n,b.y=q[1]+(s[1]-q[1])*n,b.z=q[2]+(s[2]-q[2])*n)}!1===this.loop&&this.currentTime>c&&this.stop()}};
THREE.Animation.prototype.interpolateCatmullRom=function(a,b){var c=[],d=[],e,f,g,h,k,l;e=(a.length-1)*b;f=Math.floor(e);e-=f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>a.length-2?f:f+1;c[3]=f>a.length-3?f:f+2;f=a[c[0]];h=a[c[1]];k=a[c[2]];l=a[c[3]];c=e*e;g=e*c;d[0]=this.interpolate(f[0],h[0],k[0],l[0],e,c,g);d[1]=this.interpolate(f[1],h[1],k[1],l[1],e,c,g);d[2]=this.interpolate(f[2],h[2],k[2],l[2],e,c,g);return d};
THREE.Animation.prototype.interpolate=function(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b};THREE.Animation.prototype.getNextKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};
THREE.Animation.prototype.getPrevKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};THREE.KeyFrameAnimation=function(a,b){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=0.001;this.isPlaying=!1;this.loop=this.isPaused=!0;for(var c=0,d=this.hierarchy.length;c<d;c++){var e=this.data.hierarchy[c].sids,f=this.hierarchy[c];if(this.data.hierarchy[c].keys.length&&e){for(var g=0;g<e.length;g++){var h=e[g],k=this.getNextKeyWith(h,c,0);k&&k.apply(h)}f.matrixAutoUpdate=!1;this.data.hierarchy[c].node.updateMatrix();
f.matrixWorldNeedsUpdate=!0}}};
THREE.KeyFrameAnimation.prototype.play=function(a){this.currentTime=void 0!==a?a:0;if(!1===this.isPlaying){this.isPlaying=!0;var b=this.hierarchy.length,c,d;for(a=0;a<b;a++)c=this.hierarchy[a],d=this.data.hierarchy[a],void 0===d.animationCache&&(d.animationCache={},d.animationCache.prevKey=null,d.animationCache.nextKey=null,d.animationCache.originalMatrix=c instanceof THREE.Bone?c.skinMatrix:c.matrix),c=this.data.hierarchy[a].keys,c.length&&(d.animationCache.prevKey=c[0],d.animationCache.nextKey=
c[1],this.startTime=Math.min(c[0].time,this.startTime),this.endTime=Math.max(c[c.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.KeyFrameAnimation.prototype.pause=function(){this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};
THREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;b instanceof THREE.Bone?(d.copy(b.skinMatrix),b.skinMatrix=d):(d.copy(b.matrix),b.matrix=d);delete c.animationCache}}};
THREE.KeyFrameAnimation.prototype.update=function(a){if(!1!==this.isPlaying){this.currentTime+=a*this.timeScale;a=this.data.length;!0===this.loop&&this.currentTime>a&&(this.currentTime%=a);this.currentTime=Math.min(this.currentTime,a);a=0;for(var b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a],d=this.data.hierarchy[a],e=d.keys,d=d.animationCache;if(e.length){var f=d.prevKey,g=d.nextKey;if(g.time<=this.currentTime){for(;g.time<this.currentTime&&g.index>f.index;)f=g,g=e[f.index+1];d.prevKey=
f;d.nextKey=g}g.time>=this.currentTime?f.interpolate(g,this.currentTime):f.interpolate(g,g.time);this.data.hierarchy[a].node.updateMatrix();c.matrixWorldNeedsUpdate=!0}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.MorphAnimation=function(a){this.mesh=a;this.frames=a.morphTargetInfluences.length;this.currentTime=0;this.duration=1E3;this.loop=!0;this.isPlaying=!1};
THREE.MorphAnimation.prototype={play:function(){this.isPlaying=!0},pause:function(){this.isPlaying=!1},update:function(){var a=0,b=0;return function(c){if(!1!==this.isPlaying){this.currentTime+=c;!0===this.loop&&this.currentTime>this.duration&&(this.currentTime%=this.duration);this.currentTime=Math.min(this.currentTime,this.duration);c=this.duration/this.frames;var d=Math.floor(this.currentTime/c);d!=b&&(this.mesh.morphTargetInfluences[a]=0,this.mesh.morphTargetInfluences[b]=1,this.mesh.morphTargetInfluences[d]=
0,a=b,b=d);this.mesh.morphTargetInfluences[d]=this.currentTime%c/c;this.mesh.morphTargetInfluences[a]=1-this.mesh.morphTargetInfluences[d]}}}()};THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,
1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var k=new THREE.PerspectiveCamera(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new THREE.Vector3(0,0,-1));this.add(k);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,s=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=
2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=s;c.activeCubeFace=5;a.render(b,k,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CombinedCamera=function(a,b,c,d,e,f,g){THREE.Camera.call(this);this.fov=c;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2;this.cameraO=new THREE.OrthographicCamera(a/-2,a/2,b/2,b/-2,f,g);this.cameraP=new THREE.PerspectiveCamera(c,a/b,d,e);this.zoom=1;this.toPerspective()};THREE.CombinedCamera.prototype=Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective=function(){this.near=this.cameraP.near;this.far=this.cameraP.far;this.cameraP.fov=this.fov/this.zoom;this.cameraP.updateProjectionMatrix();this.projectionMatrix=this.cameraP.projectionMatrix;this.inPerspectiveMode=!0;this.inOrthographicMode=!1};
THREE.CombinedCamera.prototype.toOrthographic=function(){var a=this.cameraP.aspect,b=(this.cameraP.near+this.cameraP.far)/2,b=Math.tan(this.fov/2)*b,a=2*b*a/2,b=b/this.zoom,a=a/this.zoom;this.cameraO.left=-a;this.cameraO.right=a;this.cameraO.top=b;this.cameraO.bottom=-b;this.cameraO.updateProjectionMatrix();this.near=this.cameraO.near;this.far=this.cameraO.far;this.projectionMatrix=this.cameraO.projectionMatrix;this.inPerspectiveMode=!1;this.inOrthographicMode=!0};
THREE.CombinedCamera.prototype.setSize=function(a,b){this.cameraP.aspect=a/b;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2};THREE.CombinedCamera.prototype.setFov=function(a){this.fov=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.updateProjectionMatrix=function(){this.inPerspectiveMode?this.toPerspective():(this.toPerspective(),this.toOrthographic())};
THREE.CombinedCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);var c=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.setFov(c);return c};THREE.CombinedCamera.prototype.setZoom=function(a){this.zoom=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.toFrontView=function(){this.rotation.x=0;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};
THREE.CombinedCamera.prototype.toBackView=function(){this.rotation.x=0;this.rotation.y=Math.PI;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toLeftView=function(){this.rotation.x=0;this.rotation.y=-Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toRightView=function(){this.rotation.x=0;this.rotation.y=Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};
THREE.CombinedCamera.prototype.toTopView=function(){this.rotation.x=-Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toBottomView=function(){this.rotation.x=Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.BoxGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,p){var v,w=h.widthSegments,r=h.heightSegments,y=e/2,E=f/2,z=h.vertices.length;if("x"===a&&"y"===b||"y"===a&&"x"===b)v="z";else if("x"===a&&"z"===b||"z"===a&&"x"===b)v="y",r=h.depthSegments;else if("z"===a&&"y"===b||"y"===a&&"z"===b)v="x",w=h.depthSegments;var P=w+1,J=r+1,A=e/w,C=f/r,M=new THREE.Vector3;M[v]=0<g?1:-1;for(e=0;e<J;e++)for(f=0;f<P;f++){var H=new THREE.Vector3;H[a]=(f*A-y)*c;H[b]=(e*C-E)*d;H[v]=g;h.vertices.push(H)}for(e=
0;e<r;e++)for(f=0;f<w;f++)E=f+P*e,a=f+P*(e+1),b=f+1+P*(e+1),c=f+1+P*e,d=new THREE.Vector2(f/w,1-e/r),g=new THREE.Vector2(f/w,1-(e+1)/r),v=new THREE.Vector2((f+1)/w,1-(e+1)/r),y=new THREE.Vector2((f+1)/w,1-e/r),E=new THREE.Face3(E+z,a+z,c+z),E.normal.copy(M),E.vertexNormals.push(M.clone(),M.clone(),M.clone()),E.materialIndex=p,h.faces.push(E),h.faceVertexUvs[0].push([d,g,y]),E=new THREE.Face3(a+z,b+z,c+z),E.normal.copy(M),E.vertexNormals.push(M.clone(),M.clone(),M.clone()),E.materialIndex=p,h.faces.push(E),
h.faceVertexUvs[0].push([g.clone(),v,y.clone()])}THREE.Geometry.call(this);var h=this;this.width=a;this.height=b;this.depth=c;this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;a=this.width/2;b=this.height/2;c=this.depth/2;g("z","y",-1,-1,this.depth,this.height,a,0);g("z","y",1,-1,this.depth,this.height,-a,1);g("x","z",1,1,this.width,this.depth,b,2);g("x","z",1,-1,this.width,this.depth,-b,3);g("x","y",1,-1,this.width,this.height,c,4);g("x","y",-1,-1,this.width,this.height,-c,
5);this.computeCentroids();this.mergeVertices()};THREE.BoxGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.radius=a=a||50;this.segments=b=void 0!==b?Math.max(3,b):8;this.thetaStart=c=void 0!==c?c:0;this.thetaLength=d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var g=new THREE.Vector2(0.5,0.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3,k=c+e/b*d;h.x=a*Math.cos(k);h.y=a*Math.sin(k);this.vertices.push(h);f.push(new THREE.Vector2((h.x/a+1)/2,(h.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=b;e++)this.faces.push(new THREE.Face3(e,
e+1,0,[c.clone(),c.clone(),c.clone()])),this.faceVertexUvs[0].push([f[e].clone(),f[e+1].clone(),g.clone()]);this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=THREE.BoxGeometry;THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.radiusTop=a=void 0!==a?a:20;this.radiusBottom=b=void 0!==b?b:20;this.height=c=void 0!==c?c:100;this.radialSegments=d=d||8;this.heightSegments=e=e||1;this.openEnded=f=void 0!==f?f:!1;var g=c/2,h,k,l=[],n=[];for(k=0;k<=e;k++){var q=[],s=[],u=k/e,t=u*(b-a)+a;for(h=0;h<=d;h++){var p=h/d,v=new THREE.Vector3;v.x=t*Math.sin(p*Math.PI*2);v.y=-u*c+g;v.z=t*Math.cos(p*Math.PI*2);this.vertices.push(v);q.push(this.vertices.length-1);s.push(new THREE.Vector2(p,
1-u))}l.push(q);n.push(s)}c=(b-a)/c;for(h=0;h<d;h++)for(0!==a?(q=this.vertices[l[0][h]].clone(),s=this.vertices[l[0][h+1]].clone()):(q=this.vertices[l[1][h]].clone(),s=this.vertices[l[1][h+1]].clone()),q.setY(Math.sqrt(q.x*q.x+q.z*q.z)*c).normalize(),s.setY(Math.sqrt(s.x*s.x+s.z*s.z)*c).normalize(),k=0;k<e;k++){var u=l[k][h],t=l[k+1][h],p=l[k+1][h+1],v=l[k][h+1],w=q.clone(),r=q.clone(),y=s.clone(),E=s.clone(),z=n[k][h].clone(),P=n[k+1][h].clone(),J=n[k+1][h+1].clone(),A=n[k][h+1].clone();this.faces.push(new THREE.Face3(u,
t,v,[w,r,E]));this.faceVertexUvs[0].push([z,P,A]);this.faces.push(new THREE.Face3(t,p,v,[r.clone(),y,E.clone()]));this.faceVertexUvs[0].push([P.clone(),J,A.clone()])}if(!1===f&&0<a)for(this.vertices.push(new THREE.Vector3(0,g,0)),h=0;h<d;h++)u=l[0][h],t=l[0][h+1],p=this.vertices.length-1,w=new THREE.Vector3(0,1,0),r=new THREE.Vector3(0,1,0),y=new THREE.Vector3(0,1,0),z=n[0][h].clone(),P=n[0][h+1].clone(),J=new THREE.Vector2(P.x,0),this.faces.push(new THREE.Face3(u,t,p,[w,r,y])),this.faceVertexUvs[0].push([z,
P,J]);if(!1===f&&0<b)for(this.vertices.push(new THREE.Vector3(0,-g,0)),h=0;h<d;h++)u=l[k][h+1],t=l[k][h],p=this.vertices.length-1,w=new THREE.Vector3(0,-1,0),r=new THREE.Vector3(0,-1,0),y=new THREE.Vector3(0,-1,0),z=n[k][h+1].clone(),P=n[k][h].clone(),J=new THREE.Vector2(P.x,1),this.faces.push(new THREE.Face3(u,t,p,[w,r,y])),this.faceVertexUvs[0].push([z,P,J]);this.computeCentroids();this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry=function(a,b){"undefined"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.shapebb=a[a.length-1].getBoundingBox(),this.addShapeList(a,b),this.computeCentroids(),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};
THREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log("die");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.Math.sign,e=1,e=a.x-b.x,f=a.y-b.y,g=c.x-a.x,h=c.y-a.y,k=e*e+f*f;if(1E-10<Math.abs(e*h-f*g)){var l=Math.sqrt(k),d=Math.sqrt(g*g+h*h),k=b.x-f/l;b=b.y+e/l;g=((c.x-h/d-k)*h-(c.y+g/d-b)*g)/(e*h-f*g);c=k+e*g-a.x;a=b+f*g-a.y;e=c*c+a*a;if(2>=e)return new THREE.Vector2(c,a);e=Math.sqrt(e/2)}else a=!1,1E-10<e?1E-10<g&&(a=!0):-1E-10>e?-1E-10>g&&
(a=!0):d(f)==d(h)&&(a=!0),a?(c=-f,a=e,e=Math.sqrt(k)):(c=e,a=f,e=Math.sqrt(k/2));return new THREE.Vector2(c/e,a/e)}function e(c,d){var e,f;for(Q=c.length;0<=--Q;){e=Q;f=Q-1;0>f&&(f=c.length-1);for(var g=0,h=u+2*n,g=0;g<h;g++){var k=la*g,l=la*(g+1),p=d+e+k,k=d+f+k,q=d+f+l,l=d+e+l,s=c,t=g,v=h,w=e,x=f,p=p+K,k=k+K,q=q+K,l=l+K;H.faces.push(new THREE.Face3(p,k,l,null,null,r));H.faces.push(new THREE.Face3(k,q,l,null,null,r));p=y.generateSideWallUV(H,a,s,b,p,k,q,l,t,v,w,x);H.faceVertexUvs[0].push([p[0],p[1],
p[3]]);H.faceVertexUvs[0].push([p[1],p[2],p[3]])}}}function f(a,b,c){H.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c+=K;d+=K;e+=K;H.faces.push(new THREE.Face3(c,d,e,null,null,w));c=f?y.generateBottomUV(H,a,b,c,d,e):y.generateTopUV(H,a,b,c,d,e);H.faceVertexUvs[0].push(c)}var h=void 0!==b.amount?b.amount:100,k=void 0!==b.bevelThickness?b.bevelThickness:6,l=void 0!==b.bevelSize?b.bevelSize:k-2,n=void 0!==b.bevelSegments?b.bevelSegments:3,q=void 0!==b.bevelEnabled?b.bevelEnabled:!0,s=
void 0!==b.curveSegments?b.curveSegments:12,u=void 0!==b.steps?b.steps:1,t=b.extrudePath,p,v=!1,w=b.material,r=b.extrudeMaterial,y=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,E,z,P,J;t&&(p=t.getSpacedPoints(u),v=!0,q=!1,E=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(t,u,!1),z=new THREE.Vector3,P=new THREE.Vector3,J=new THREE.Vector3);q||(l=k=n=0);var A,C,M,H=this,K=this.vertices.length,t=a.extractPoints(s),s=t.shape,x=t.holes;if(t=!THREE.Shape.Utils.isClockWise(s)){s=
s.reverse();C=0;for(M=x.length;C<M;C++)A=x[C],THREE.Shape.Utils.isClockWise(A)&&(x[C]=A.reverse());t=!1}var N=THREE.Shape.Utils.triangulateShape(s,x),F=s;C=0;for(M=x.length;C<M;C++)A=x[C],s=s.concat(A);var B,D,G,Y,S,la=s.length,U,oa=N.length,t=[],Q=0;G=F.length;B=G-1;for(D=Q+1;Q<G;Q++,B++,D++)B===G&&(B=0),D===G&&(D=0),t[Q]=d(F[Q],F[B],F[D]);var fa=[],V,I=t.concat();C=0;for(M=x.length;C<M;C++){A=x[C];V=[];Q=0;G=A.length;B=G-1;for(D=Q+1;Q<G;Q++,B++,D++)B===G&&(B=0),D===G&&(D=0),V[Q]=d(A[Q],A[B],A[D]);
fa.push(V);I=I.concat(V)}for(B=0;B<n;B++){G=B/n;Y=k*(1-G);D=l*Math.sin(G*Math.PI/2);Q=0;for(G=F.length;Q<G;Q++)S=c(F[Q],t[Q],D),f(S.x,S.y,-Y);C=0;for(M=x.length;C<M;C++)for(A=x[C],V=fa[C],Q=0,G=A.length;Q<G;Q++)S=c(A[Q],V[Q],D),f(S.x,S.y,-Y)}D=l;for(Q=0;Q<la;Q++)S=q?c(s[Q],I[Q],D):s[Q],v?(P.copy(E.normals[0]).multiplyScalar(S.x),z.copy(E.binormals[0]).multiplyScalar(S.y),J.copy(p[0]).add(P).add(z),f(J.x,J.y,J.z)):f(S.x,S.y,0);for(G=1;G<=u;G++)for(Q=0;Q<la;Q++)S=q?c(s[Q],I[Q],D):s[Q],v?(P.copy(E.normals[G]).multiplyScalar(S.x),
z.copy(E.binormals[G]).multiplyScalar(S.y),J.copy(p[G]).add(P).add(z),f(J.x,J.y,J.z)):f(S.x,S.y,h/u*G);for(B=n-1;0<=B;B--){G=B/n;Y=k*(1-G);D=l*Math.sin(G*Math.PI/2);Q=0;for(G=F.length;Q<G;Q++)S=c(F[Q],t[Q],D),f(S.x,S.y,h+Y);C=0;for(M=x.length;C<M;C++)for(A=x[C],V=fa[C],Q=0,G=A.length;Q<G;Q++)S=c(A[Q],V[Q],D),v?f(S.x,S.y+p[u-1].y,p[u-1].x+Y):f(S.x,S.y,h+Y)}(function(){if(q){var a;a=0*la;for(Q=0;Q<oa;Q++)U=N[Q],g(U[2]+a,U[1]+a,U[0]+a,!0);a=u+2*n;a*=la;for(Q=0;Q<oa;Q++)U=N[Q],g(U[0]+a,U[1]+a,U[2]+a,
!1)}else{for(Q=0;Q<oa;Q++)U=N[Q],g(U[2],U[1],U[0],!0);for(Q=0;Q<oa;Q++)U=N[Q],g(U[0]+la*u,U[1]+la*u,U[2]+la*u,!1)}})();(function(){var a=0;e(F,a);a+=F.length;C=0;for(M=x.length;C<M;C++)A=x[C],e(A,a),a+=A.length})()};
THREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h,k,l,n,q){b=a.vertices[e].x;c=a.vertices[e].y;e=a.vertices[e].z;d=a.vertices[f].x;k=a.vertices[f].y;f=a.vertices[f].z;l=a.vertices[g].x;
n=a.vertices[g].y;g=a.vertices[g].z;q=a.vertices[h].x;var s=a.vertices[h].y;a=a.vertices[h].z;return 0.01>Math.abs(c-k)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(l,1-g),new THREE.Vector2(q,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(k,1-f),new THREE.Vector2(n,1-g),new THREE.Vector2(s,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;
THREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};
THREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var k=e.shape,l=e.holes;if(!THREE.Shape.Utils.isClockWise(k))for(k=k.reverse(),e=0,f=l.length;e<f;e++)g=l[e],THREE.Shape.Utils.isClockWise(g)&&(l[e]=g.reverse());var n=THREE.Shape.Utils.triangulateShape(k,l);e=0;for(f=l.length;e<f;e++)g=l[e],
k=k.concat(g);l=k.length;f=n.length;for(e=0;e<l;e++)g=k[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)l=n[e],k=l[0]+h,g=l[1]+h,l=l[2]+h,this.faces.push(new THREE.Face3(k,g,l,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,k,g,l))};THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);b=b||12;c=c||0;d=d||2*Math.PI;for(var e=1/(a.length-1),f=1/b,g=0,h=b;g<=h;g++)for(var k=c+g*f*d,l=Math.cos(k),n=Math.sin(k),k=0,q=a.length;k<q;k++){var s=a[k],u=new THREE.Vector3;u.x=l*s.x-n*s.y;u.y=n*s.x+l*s.y;u.z=s.z;this.vertices.push(u)}c=a.length;g=0;for(h=b;g<h;g++)for(k=0,q=a.length-1;k<q;k++){b=n=k+c*g;d=n+c;var l=n+1+c,n=n+1,s=g*f,u=k*e,t=s+f,p=u+e;this.faces.push(new THREE.Face3(b,d,n));this.faceVertexUvs[0].push([new THREE.Vector2(s,
u),new THREE.Vector2(t,u),new THREE.Vector2(s,p)]);this.faces.push(new THREE.Face3(d,l,n));this.faceVertexUvs[0].push([new THREE.Vector2(t,u),new THREE.Vector2(t,p),new THREE.Vector2(s,p)])}this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.width=a;this.height=b;this.widthSegments=c||1;this.heightSegments=d||1;var e=a/2,f=b/2;c=this.widthSegments;d=this.heightSegments;var g=c+1,h=d+1,k=this.width/c,l=this.height/d,n=new THREE.Vector3(0,0,1);for(a=0;a<h;a++)for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*k-e,-(a*l-f),0));for(a=0;a<d;a++)for(b=0;b<c;b++){var q=b+g*a,e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,k=new THREE.Vector2(b/c,1-a/d),l=new THREE.Vector2(b/c,1-(a+
1)/d),s=new THREE.Vector2((b+1)/c,1-(a+1)/d),u=new THREE.Vector2((b+1)/c,1-a/d),q=new THREE.Face3(q,e,h);q.normal.copy(n);q.vertexNormals.push(n.clone(),n.clone(),n.clone());this.faces.push(q);this.faceVertexUvs[0].push([k,l,u]);q=new THREE.Face3(e,f,h);q.normal.copy(n);q.vertexNormals.push(n.clone(),n.clone(),n.clone());this.faces.push(q);this.faceVertexUvs[0].push([l.clone(),s,u.clone()])}this.computeCentroids()};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);a=a||0;b=b||50;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(3,d):8;var g,h=[],k=a,l=(b-a)/d;for(a=0;a<=d;a++){for(g=0;g<=c;g++){var n=new THREE.Vector3,q=e+g/c*f;n.x=k*Math.cos(q);n.y=k*Math.sin(q);this.vertices.push(n);h.push(new THREE.Vector2((n.x/b+1)/2,(n.y/b+1)/2))}k+=l}b=new THREE.Vector3(0,0,1);for(a=0;a<d;a++)for(e=a*c,g=0;g<=c;g++)q=g+e,f=q+a,l=q+c+a,n=q+c+1+a,this.faces.push(new THREE.Face3(f,
l,n,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[l].clone(),h[n].clone()]),f=q+a,l=q+c+1+a,n=q+1+a,this.faces.push(new THREE.Face3(f,l,n,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[l].clone(),h[n].clone()]);this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,k)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.radius=a=a||50;this.widthSegments=b=Math.max(3,Math.floor(b)||8);this.heightSegments=c=Math.max(2,Math.floor(c)||6);this.phiStart=d=void 0!==d?d:0;this.phiLength=e=void 0!==e?e:2*Math.PI;this.thetaStart=f=void 0!==f?f:0;this.thetaLength=g=void 0!==g?g:Math.PI;var h,k,l=[],n=[];for(k=0;k<=c;k++){var q=[],s=[];for(h=0;h<=b;h++){var u=h/b,t=k/c,p=new THREE.Vector3;p.x=-a*Math.cos(d+u*e)*Math.sin(f+t*g);p.y=a*Math.cos(f+t*g);
p.z=a*Math.sin(d+u*e)*Math.sin(f+t*g);this.vertices.push(p);q.push(this.vertices.length-1);s.push(new THREE.Vector2(u,1-t))}l.push(q);n.push(s)}for(k=0;k<this.heightSegments;k++)for(h=0;h<this.widthSegments;h++){b=l[k][h+1];c=l[k][h];d=l[k+1][h];e=l[k+1][h+1];f=this.vertices[b].clone().normalize();g=this.vertices[c].clone().normalize();var q=this.vertices[d].clone().normalize(),s=this.vertices[e].clone().normalize(),u=n[k][h+1].clone(),t=n[k][h].clone(),p=n[k+1][h].clone(),v=n[k+1][h+1].clone();Math.abs(this.vertices[b].y)===
this.radius?(u.x=(u.x+t.x)/2,this.faces.push(new THREE.Face3(b,d,e,[f,q,s])),this.faceVertexUvs[0].push([u,p,v])):Math.abs(this.vertices[d].y)===this.radius?(p.x=(p.x+v.x)/2,this.faces.push(new THREE.Face3(b,c,d,[f,g,q])),this.faceVertexUvs[0].push([u,t,p])):(this.faces.push(new THREE.Face3(b,c,e,[f,g,s])),this.faceVertexUvs[0].push([u,t,v]),this.faces.push(new THREE.Face3(c,d,e,[g.clone(),q,s.clone()])),this.faceVertexUvs[0].push([t.clone(),p,v.clone()]))}this.computeCentroids();this.computeFaceNormals();
this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){b=b||{};var c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||8;this.tubularSegments=d||6;this.arc=e||2*Math.PI;e=new THREE.Vector3;a=[];b=[];for(c=0;c<=this.radialSegments;c++)for(d=0;d<=this.tubularSegments;d++){var f=d/this.tubularSegments*this.arc,g=c/this.radialSegments*Math.PI*2;e.x=this.radius*Math.cos(f);e.y=this.radius*Math.sin(f);var h=new THREE.Vector3;h.x=(this.radius+this.tube*Math.cos(g))*Math.cos(f);h.y=(this.radius+this.tube*
Math.cos(g))*Math.sin(f);h.z=this.tube*Math.sin(g);this.vertices.push(h);a.push(new THREE.Vector2(d/this.tubularSegments,c/this.radialSegments));b.push(h.clone().sub(e).normalize())}for(c=1;c<=this.radialSegments;c++)for(d=1;d<=this.tubularSegments;d++){e=(this.tubularSegments+1)*c+d-1;var f=(this.tubularSegments+1)*(c-1)+d-1,g=(this.tubularSegments+1)*(c-1)+d,h=(this.tubularSegments+1)*c+d,k=new THREE.Face3(e,f,h,[b[e].clone(),b[f].clone(),b[h].clone()]);this.faces.push(k);this.faceVertexUvs[0].push([a[e].clone(),
a[f].clone(),a[h].clone()]);k=new THREE.Face3(f,g,h,[b[f].clone(),b[g].clone(),b[h].clone()]);this.faces.push(k);this.faceVertexUvs[0].push([a[f].clone(),a[g].clone(),a[h].clone()])}this.computeCentroids();this.computeFaceNormals()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){function h(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a);a*=b/c;b=Math.cos(a);f*=d*(2+b)*0.5;g=d*(2+b)*g*0.5;d=e*d*Math.sin(a)*0.5;return new THREE.Vector3(f,g,d)}THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||64;this.tubularSegments=d||8;this.p=e||2;this.q=f||3;this.heightScale=g||1;this.grid=Array(this.radialSegments);c=new THREE.Vector3;d=new THREE.Vector3;e=new THREE.Vector3;for(a=0;a<this.radialSegments;++a)for(this.grid[a]=
Array(this.tubularSegments),b=a/this.radialSegments*2*this.p*Math.PI,f=h(b,this.q,this.p,this.radius,this.heightScale),b=h(b+0.01,this.q,this.p,this.radius,this.heightScale),c.subVectors(b,f),d.addVectors(b,f),e.crossVectors(c,d),d.crossVectors(e,c),e.normalize(),d.normalize(),b=0;b<this.tubularSegments;++b){var k=b/this.tubularSegments*2*Math.PI;g=-this.tube*Math.cos(k);var k=this.tube*Math.sin(k),l=new THREE.Vector3;l.x=f.x+g*d.x+k*e.x;l.y=f.y+g*d.y+k*e.y;l.z=f.z+g*d.z+k*e.z;this.grid[a][b]=this.vertices.push(l)-
1}for(a=0;a<this.radialSegments;++a)for(b=0;b<this.tubularSegments;++b){e=(a+1)%this.radialSegments;f=(b+1)%this.tubularSegments;c=this.grid[a][b];d=this.grid[e][b];e=this.grid[e][f];f=this.grid[a][f];g=new THREE.Vector2(a/this.radialSegments,b/this.tubularSegments);var k=new THREE.Vector2((a+1)/this.radialSegments,b/this.tubularSegments),l=new THREE.Vector2((a+1)/this.radialSegments,(b+1)/this.tubularSegments),n=new THREE.Vector2(a/this.radialSegments,(b+1)/this.tubularSegments);this.faces.push(new THREE.Face3(c,
d,f));this.faceVertexUvs[0].push([g,k,n]);this.faces.push(new THREE.Face3(d,e,f));this.faceVertexUvs[0].push([k.clone(),l,n.clone()])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TubeGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.path=a;this.segments=b||64;this.radius=c||1;this.radialSegments=d||8;this.closed=e||!1;this.grid=[];var f,g;d=this.segments+1;var h,k,l;e=new THREE.Vector3;var n,q;b=new THREE.TubeGeometry.FrenetFrames(this.path,this.segments,this.closed);n=b.normals;q=b.binormals;this.tangents=b.tangents;this.normals=n;this.binormals=q;for(b=0;b<d;b++)for(this.grid[b]=[],c=b/(d-1),l=a.getPointAt(c),f=n[b],g=q[b],c=0;c<this.radialSegments;c++)h=
c/this.radialSegments*2*Math.PI,k=-this.radius*Math.cos(h),h=this.radius*Math.sin(h),e.copy(l),e.x+=k*f.x+h*g.x,e.y+=k*f.y+h*g.y,e.z+=k*f.z+h*g.z,this.grid[b][c]=this.vertices.push(new THREE.Vector3(e.x,e.y,e.z))-1;for(b=0;b<this.segments;b++)for(c=0;c<this.radialSegments;c++)e=this.closed?(b+1)%this.segments:b+1,n=(c+1)%this.radialSegments,a=this.grid[b][c],d=this.grid[e][c],e=this.grid[e][n],n=this.grid[b][n],q=new THREE.Vector2(b/this.segments,c/this.radialSegments),f=new THREE.Vector2((b+1)/this.segments,
c/this.radialSegments),g=new THREE.Vector2((b+1)/this.segments,(c+1)/this.radialSegments),k=new THREE.Vector2(b/this.segments,(c+1)/this.radialSegments),this.faces.push(new THREE.Face3(a,d,n)),this.faceVertexUvs[0].push([q,f,k]),this.faces.push(new THREE.Face3(d,e,n)),this.faceVertexUvs[0].push([f.clone(),g,k.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],g=[],h=new THREE.Vector3,k=new THREE.Matrix4;b+=1;var l,n,q;this.tangents=e;this.normals=f;this.binormals=g;for(l=0;l<b;l++)n=l/(b-1),e[l]=a.getTangentAt(n),e[l].normalize();f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;l=Math.abs(e[0].x);n=Math.abs(e[0].y);q=Math.abs(e[0].z);l<=a&&(a=l,d.set(1,0,0));n<=a&&(a=n,d.set(0,1,0));q<=a&&d.set(0,0,1);h.crossVectors(e[0],
d).normalize();f[0].crossVectors(e[0],h);g[0].crossVectors(e[0],f[0]);for(l=1;l<b;l++)f[l]=f[l-1].clone(),g[l]=g[l-1].clone(),h.crossVectors(e[l-1],e[l]),1E-4<h.length()&&(h.normalize(),d=Math.acos(THREE.Math.clamp(e[l-1].dot(e[l]),-1,1)),f[l].applyMatrix4(k.makeRotationAxis(h,d))),g[l].crossVectors(e[l],f[l]);if(c)for(d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1)),d/=b-1,0<e[0].dot(h.crossVectors(f[0],f[b-1]))&&(d=-d),l=1;l<b;l++)f[l].applyMatrix4(k.makeRotationAxis(e[l],d*l)),g[l].crossVectors(e[l],
f[l])};THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=k.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+0.5;a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+0.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c){var d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);d.centroid.add(a).add(b).add(c).divideScalar(3);k.faces.push(d);d=d.centroid;d=Math.atan2(d.z,-d.x);k.faceVertexUvs[0].push([h(a.uv,a,d),h(b.uv,b,d),h(c.uv,
c,d)])}function g(a,b){var c=Math.pow(2,b);Math.pow(4,b);for(var d=e(k.vertices[a.a]),g=e(k.vertices[a.b]),h=e(k.vertices[a.c]),l=[],n=0;n<=c;n++){l[n]=[];for(var q=e(d.clone().lerp(h,n/c)),s=e(g.clone().lerp(h,n/c)),t=c-n,u=0;u<=t;u++)l[n][u]=0==u&&n==c?q:e(q.clone().lerp(s,u/t))}for(n=0;n<c;n++)for(u=0;u<2*(c-n)-1;u++)d=Math.floor(u/2),0==u%2?f(l[n][d+1],l[n+1][d],l[n][d]):f(l[n][d+1],l[n+1][d+1],l[n+1][d])}function h(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/
2/Math.PI+0.5,a.y));return a.clone()}THREE.Geometry.call(this);c=c||1;d=d||0;for(var k=this,l=0,n=a.length;l<n;l++)e(new THREE.Vector3(a[l][0],a[l][1],a[l][2]));a=this.vertices;for(var q=[],l=0,n=b.length;l<n;l++){var s=a[b[l][0]],u=a[b[l][1]],t=a[b[l][2]];q[l]=new THREE.Face3(s.index,u.index,t.index,[s.clone(),u.clone(),t.clone()])}l=0;for(n=q.length;l<n;l++)g(q[l],d);l=0;for(n=this.faceVertexUvs[0].length;l<n;l++)b=this.faceVertexUvs[0][l],d=b[0].x,a=b[1].x,q=b[2].x,s=Math.max(d,Math.max(a,q)),
u=Math.min(d,Math.min(a,q)),0.9<s&&0.1>u&&(0.2>d&&(b[0].x+=1),0.2>a&&(b[1].x+=1),0.2>q&&(b[2].x+=1));l=0;for(n=this.vertices.length;l<n;l++)this.vertices[l].multiplyScalar(c);this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.IcosahedronGeometry=function(a,b){this.radius=a;this.detail=b;var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[[-1,c,0],[1,c,0],[-1,-c,0],[1,-c,0],[0,-1,c],[0,1,c],[0,-1,-c],[0,1,-c],[c,0,-1],[c,0,1],[-c,0,-1],[-c,0,1]],[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],[[2,1,0],[0,3,2],[1,3,0],[2,3,1]],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],g,h,k,l,n=b+1;for(g=0;g<=c;g++)for(l=g/c,h=0;h<=b;h++)k=h/b,k=a(k,l),d.push(k);var q,s,u,t;for(g=0;g<c;g++)for(h=0;h<b;h++)a=g*n+h,d=g*n+h+1,l=(g+1)*n+h+1,k=(g+1)*n+h,q=new THREE.Vector2(h/b,g/c),s=new THREE.Vector2((h+1)/b,g/c),u=new THREE.Vector2((h+1)/b,(g+1)/c),t=new THREE.Vector2(h/b,(g+1)/c),e.push(new THREE.Face3(a,d,k)),f.push([q,s,t]),e.push(new THREE.Face3(d,l,k)),
f.push([s.clone(),u,t.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.AxisHelper=function(a){a=a||1;var b=new THREE.Geometry;b.vertices.push(new THREE.Vector3,new THREE.Vector3(a,0,0),new THREE.Vector3,new THREE.Vector3(0,a,0),new THREE.Vector3,new THREE.Vector3(0,0,a));b.colors.push(new THREE.Color(16711680),new THREE.Color(16755200),new THREE.Color(65280),new THREE.Color(11206400),new THREE.Color(255),new THREE.Color(43775));a=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,b,a,THREE.LinePieces)};
THREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);THREE.ArrowHelper=function(a,b,c,d,e,f){THREE.Object3D.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);void 0===e&&(e=0.2*c);void 0===f&&(f=0.2*e);this.position=b;b=new THREE.Geometry;b.vertices.push(new THREE.Vector3(0,0,0));b.vertices.push(new THREE.Vector3(0,1,0));this.line=new THREE.Line(b,new THREE.LineBasicMaterial({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);b=new THREE.CylinderGeometry(0,0.5,1,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));this.cone=
new THREE.Mesh(b,new THREE.MeshBasicMaterial({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);this.setLength(c,e,f)};THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){0.99999<c.y?this.quaternion.set(0,0,0,1):-0.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();
THREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=0.2*a);void 0===c&&(c=0.2*b);this.line.scale.set(1,a,1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.setHex(a);this.cone.material.color.setHex(a)};THREE.BoxHelper=function(a){var b=[new THREE.Vector3(1,1,1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,-1,-1)];this.vertices=b;var c=new THREE.Geometry;c.vertices.push(b[0],b[1],b[1],b[2],b[2],b[3],b[3],b[0],b[4],b[5],b[5],b[6],b[6],b[7],b[7],b[4],b[0],b[4],b[1],b[5],b[2],b[6],b[3],b[7]);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);
void 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.vertices;d[0].set(b.x,b.y,b.z);d[1].set(c.x,b.y,b.z);d[2].set(c.x,c.y,b.z);d[3].set(b.x,c.y,b.z);d[4].set(b.x,b.y,c.z);d[5].set(c.x,b.y,c.z);d[6].set(c.x,c.y,c.z);d[7].set(b.x,c.y,c.z);this.geometry.computeBoundingSphere();this.geometry.verticesNeedUpdate=!0;this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b("n1","n2",16755200);b("n2","n4",16755200);b("n4","n3",16755200);b("n3","n1",16755200);b("f1","f2",16755200);b("f2","f4",16755200);b("f4","f3",16755200);b("f3","f1",16755200);b("n1","f1",16755200);
b("n2","f2",16755200);b("n3","f3",16755200);b("n4","f4",16755200);b("p","n1",16711680);b("p","n2",16711680);b("p","n3",16711680);b("p","n4",16711680);b("u1","u2",43775);b("u2","u3",43775);b("u3","u1",43775);b("c","t",16777215);b("p","c",3355443);b("cn1","cn2",3355443);b("cn3","cn4",3355443);b("cf1","cf2",3355443);b("cf3","cf4",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};
THREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,g,h,k){a.set(g,h,k);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d)for(g=0,h=d.length;g<h;g++)e.geometry.vertices[d[g]].copy(a)}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d("c",0,0,-1);d("t",0,0,1);d("n1",-1,-1,-1);d("n2",1,-1,-1);d("n3",-1,1,-1);d("n4",1,1,-1);d("f1",-1,-1,1);d("f2",1,-1,1);d("f3",-1,1,1);d("f4",1,1,1);d("u1",0.7,
1.1,-1);d("u2",-0.7,1.1,-1);d("u3",0,2,-1);d("cf1",-1,0,1);d("cf2",1,0,1);d("cf3",0,-1,1);d("cf4",0,1,1);d("cn1",-1,0,-1);d("cn2",1,0,-1);d("cn3",0,-1,-1);d("cn4",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;b=b||1;var c=new THREE.PlaneGeometry(b,b),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Mesh(c,d);this.add(this.lightPlane);c=new THREE.Geometry;c.vertices.push(new THREE.Vector3);c.vertices.push(new THREE.Vector3);d=new THREE.LineBasicMaterial({fog:!1});
d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};
THREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();THREE.EdgesHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=["a","b","c"],h=new THREE.BufferGeometry,k=a.geometry.clone();k.mergeVertices();k.computeFaceNormals();for(var l=k.vertices,k=k.faces,n=0,q=0,s=k.length;q<s;q++)for(var u=k[q],t=0;3>t;t++){d[0]=u[g[t]];d[1]=u[g[(t+1)%3]];d.sort(f);var p=d.toString();void 0===e[p]?(e[p]={vert1:d[0],vert2:d[1],face1:q,face2:void 0},n++):e[p].face2=q}h.addAttribute("position",Float32Array,2*n,3);d=h.attributes.position.array;
f=0;for(p in e)if(g=e[p],void 0===g.face2||0.9999>k[g.face1].normal.dot(k[g.face2].normal))n=l[g.vert1],d[f++]=n.x,d[f++]=n.y,d[f++]=n.z,n=l[g.vert2],d[f++]=n.x,d[f++]=n.y,d[f++]=n.z;THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.EdgesHelper.prototype=Object.create(THREE.Line.prototype);THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=new THREE.Geometry;c=0;for(var e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);a=this.geometry.vertices;for(var d=this.object.geometry.faces,e=this.object.matrixWorld,f=0,g=d.length;f<g;f++){var h=d[f];b.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);var k=2*f;a[k].copy(h.centroid).applyMatrix4(e);a[k+1].addVectors(a[k],b)}this.geometry.verticesNeedUpdate=
!0;return this}}();THREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};THREE.HemisphereLightHelper=function(a,b,c,d){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];a=new THREE.SphereGeometry(b,4,2);a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));for(b=0;8>b;b++)a.faces[b].color=this.colors[4>b?0:1];b=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(a,b);this.add(this.lightSphere);
this.update()};THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};
THREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};
THREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:16711680;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexNormals.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};
THREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=["a","b","c","d"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,l=f.length;k<l;k++)for(var n=f[k],q=0,s=n.vertexNormals.length;q<s;q++){var u=n.vertexNormals[q];d[h].copy(e[n[a[q]]]).applyMatrix4(g);b.copy(u).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
b.add(d[h]);h+=1;d[h].copy(b);h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:255;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexTangents.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=["a","b","c","d"];this.object.updateMatrixWorld(!0);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,l=f.length;k<l;k++)for(var n=f[k],q=0,s=n.vertexTangents.length;q<s;q++){var u=n.vertexTangents[q];d[h].copy(e[n[a[q]]]).applyMatrix4(g);b.copy(u).transformDirection(g).multiplyScalar(this.size);b.add(d[h]);h+=1;d[h].copy(b);
h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=["a","b","c"],h=new THREE.BufferGeometry;if(a.geometry instanceof THREE.Geometry){for(var k=a.geometry.vertices,l=a.geometry.faces,n=0,q=new Uint32Array(6*l.length),s=0,u=l.length;s<u;s++)for(var t=l[s],p=0;3>p;p++){d[0]=t[g[p]];d[1]=t[g[(p+1)%3]];d.sort(f);var v=d.toString();void 0===e[v]&&(q[2*n]=d[0],q[2*n+1]=d[1],e[v]=!0,n++)}h.addAttribute("position",Float32Array,2*n,3);d=h.attributes.position.array;
s=0;for(u=n;s<u;s++)for(p=0;2>p;p++)n=k[q[2*s+p]],g=6*s+3*p,d[g+0]=n.x,d[g+1]=n.y,d[g+2]=n.z}else if(a.geometry instanceof THREE.BufferGeometry&&void 0!==a.geometry.attributes.index){for(var k=a.geometry.attributes.position.array,u=a.geometry.attributes.index.array,l=a.geometry.offsets,n=0,q=new Uint32Array(2*u.length),t=0,w=l.length;t<w;++t)for(var p=l[t].start,v=l[t].count,g=l[t].index,s=p,r=p+v;s<r;s+=3)for(p=0;3>p;p++)d[0]=g+u[s+p],d[1]=g+u[s+(p+1)%3],d.sort(f),v=d.toString(),void 0===e[v]&&(q[2*
n]=d[0],q[2*n+1]=d[1],e[v]=!0,n++);h.addAttribute("position",Float32Array,2*n,3);d=h.attributes.position.array;s=0;for(u=n;s<u;s++)for(p=0;2>p;p++)g=6*s+3*p,n=3*q[2*s+p],d[g+0]=k[n],d[g+1]=k[n+1],d[g+2]=k[n+2]}else if(a.geometry instanceof THREE.BufferGeometry)for(k=a.geometry.attributes.position.array,n=k.length/3,q=n/3,h.addAttribute("position",Float32Array,2*n,3),d=h.attributes.position.array,s=0,u=q;s<u;s++)for(p=0;3>p;p++)g=18*s+6*p,q=9*s+3*p,d[g+0]=k[q],d[g+1]=k[q+1],d[g+2]=k[q+2],n=9*s+(p+
1)%3*3,d[g+3]=k[n],d[g+4]=k[n+1],d[g+5]=k[n+2];THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(a){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};THREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add=function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};
THREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=c.x*Math.PI*0.25,c.rotation+=0.25*(c.wantedRotation-c.rotation)};THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation("__default",0,c-1,c/1);this.setAnimationWeight("__default",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};
THREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)(\d+)/,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&1<h.length){var k=h[1];d[k]||(d[k]={start:Infinity,end:-Infinity});h=d[k];f<h.start&&(h.start=f);f>h.end&&(h.end=f);c||(c=k)}}for(k in d)h=d[k],this.createAnimation(k,h.start,h.end,a);this.firstAnimation=c};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};
THREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};
THREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn("animation["+a+"] undefined")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};
THREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),g=d.weight;
f!==d.currentFrame&&(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*g,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*g;this.morphTargetInfluences[d.lastFrame]=(1-e)*g}}};THREE.LensFlarePlugin=function(){function a(a,c){var d=b.createProgram(),e=b.createShader(b.FRAGMENT_SHADER),f=b.createShader(b.VERTEX_SHADER),g="precision "+c+" float;\n";b.shaderSource(e,g+a.fragmentShader);b.shaderSource(f,g+a.vertexShader);b.compileShader(e);b.compileShader(f);b.attachShader(d,e);b.attachShader(d,f);b.linkProgram(d);return d}var b,c,d,e,f,g,h,k,l,n,q,s,u;this.init=function(t){b=t.context;c=t;d=t.getPrecision();e=new Float32Array(16);f=new Uint16Array(6);t=0;e[t++]=-1;e[t++]=-1;
e[t++]=0;e[t++]=0;e[t++]=1;e[t++]=-1;e[t++]=1;e[t++]=0;e[t++]=1;e[t++]=1;e[t++]=1;e[t++]=1;e[t++]=-1;e[t++]=1;e[t++]=0;e[t++]=1;t=0;f[t++]=0;f[t++]=1;f[t++]=2;f[t++]=0;f[t++]=2;f[t++]=3;g=b.createBuffer();h=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,g);b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.bufferData(b.ELEMENT_ARRAY_BUFFER,f,b.STATIC_DRAW);k=b.createTexture();l=b.createTexture();b.bindTexture(b.TEXTURE_2D,k);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,
0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);b.bindTexture(b.TEXTURE_2D,l);b.texImage2D(b.TEXTURE_2D,0,b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);
b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);0>=b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS)?(n=!1,q=a(THREE.ShaderFlares.lensFlare,d)):(n=!0,q=a(THREE.ShaderFlares.lensFlareVertexTexture,d));s={};u={};s.vertex=b.getAttribLocation(q,"position");s.uv=b.getAttribLocation(q,"uv");u.renderType=b.getUniformLocation(q,"renderType");u.map=b.getUniformLocation(q,"map");u.occlusionMap=b.getUniformLocation(q,"occlusionMap");u.opacity=
b.getUniformLocation(q,"opacity");u.color=b.getUniformLocation(q,"color");u.scale=b.getUniformLocation(q,"scale");u.rotation=b.getUniformLocation(q,"rotation");u.screenPosition=b.getUniformLocation(q,"screenPosition")};this.render=function(a,d,e,f){a=a.__webglFlares;var r=a.length;if(r){var y=new THREE.Vector3,E=f/e,z=0.5*e,P=0.5*f,J=16/f,A=new THREE.Vector2(J*E,J),C=new THREE.Vector3(1,1,0),M=new THREE.Vector2(1,1),H=u,J=s;b.useProgram(q);b.enableVertexAttribArray(s.vertex);b.enableVertexAttribArray(s.uv);
b.uniform1i(H.occlusionMap,0);b.uniform1i(H.map,1);b.bindBuffer(b.ARRAY_BUFFER,g);b.vertexAttribPointer(J.vertex,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(J.uv,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.disable(b.CULL_FACE);b.depthMask(!1);var K,x,N,F,B;for(K=0;K<r;K++)if(J=16/f,A.set(J*E,J),F=a[K],y.set(F.matrixWorld.elements[12],F.matrixWorld.elements[13],F.matrixWorld.elements[14]),y.applyMatrix4(d.matrixWorldInverse),y.applyProjection(d.projectionMatrix),C.copy(y),M.x=C.x*z+z,
M.y=C.y*P+P,n||0<M.x&&M.x<e&&0<M.y&&M.y<f)for(b.activeTexture(b.TEXTURE1),b.bindTexture(b.TEXTURE_2D,k),b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,M.x-8,M.y-8,16,16,0),b.uniform1i(H.renderType,0),b.uniform2f(H.scale,A.x,A.y),b.uniform3f(H.screenPosition,C.x,C.y,C.z),b.disable(b.BLEND),b.enable(b.DEPTH_TEST),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0),b.activeTexture(b.TEXTURE0),b.bindTexture(b.TEXTURE_2D,l),b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,M.x-8,M.y-8,16,16,0),b.uniform1i(H.renderType,1),b.disable(b.DEPTH_TEST),
b.activeTexture(b.TEXTURE1),b.bindTexture(b.TEXTURE_2D,k),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0),F.positionScreen.copy(C),F.customUpdateCallback?F.customUpdateCallback(F):F.updateLensFlares(),b.uniform1i(H.renderType,2),b.enable(b.BLEND),x=0,N=F.lensFlares.length;x<N;x++)B=F.lensFlares[x],0.001<B.opacity&&0.001<B.scale&&(C.x=B.x,C.y=B.y,C.z=B.z,J=B.size*B.scale/f,A.x=J*E,A.y=J,b.uniform3f(H.screenPosition,C.x,C.y,C.z),b.uniform2f(H.scale,A.x,A.y),b.uniform1f(H.rotation,B.rotation),b.uniform1f(H.opacity,
B.opacity),b.uniform3f(H.color,B.color.r,B.color.g,B.color.b),c.setBlending(B.blending,B.blendEquation,B.blendSrc,B.blendDst),c.setTexture(B.texture,1),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0));b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(!0)}}};THREE.ShadowMapPlugin=function(){var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4,k=new THREE.Vector3,l=new THREE.Vector3,n=new THREE.Vector3;this.init=function(g){a=g.context;b=g;g=THREE.ShaderLib.depthRGBA;var h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,
vertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,c){b.shadowMapEnabled&&b.shadowMapAutoUpdate&&this.update(a,c)};this.update=function(q,s){var u,t,p,v,w,r,y,E,z,P=[];v=0;a.clearColor(1,1,1,1);a.disable(a.BLEND);a.enable(a.CULL_FACE);a.frontFace(a.CCW);b.shadowMapCullFace===THREE.CullFaceFront?
a.cullFace(a.FRONT):a.cullFace(a.BACK);b.setDepthTest(!0);u=0;for(t=q.__lights.length;u<t;u++)if(p=q.__lights[u],p.castShadow)if(p instanceof THREE.DirectionalLight&&p.shadowCascade)for(w=0;w<p.shadowCascadeCount;w++){var J;if(p.shadowCascadeArray[w])J=p.shadowCascadeArray[w];else{z=p;y=w;J=new THREE.DirectionalLight;J.isVirtual=!0;J.onlyShadow=!0;J.castShadow=!0;J.shadowCameraNear=z.shadowCameraNear;J.shadowCameraFar=z.shadowCameraFar;J.shadowCameraLeft=z.shadowCameraLeft;J.shadowCameraRight=z.shadowCameraRight;
J.shadowCameraBottom=z.shadowCameraBottom;J.shadowCameraTop=z.shadowCameraTop;J.shadowCameraVisible=z.shadowCameraVisible;J.shadowDarkness=z.shadowDarkness;J.shadowBias=z.shadowCascadeBias[y];J.shadowMapWidth=z.shadowCascadeWidth[y];J.shadowMapHeight=z.shadowCascadeHeight[y];J.pointsWorld=[];J.pointsFrustum=[];E=J.pointsWorld;r=J.pointsFrustum;for(var A=0;8>A;A++)E[A]=new THREE.Vector3,r[A]=new THREE.Vector3;E=z.shadowCascadeNearZ[y];z=z.shadowCascadeFarZ[y];r[0].set(-1,-1,E);r[1].set(1,-1,E);r[2].set(-1,
1,E);r[3].set(1,1,E);r[4].set(-1,-1,z);r[5].set(1,-1,z);r[6].set(-1,1,z);r[7].set(1,1,z);J.originalCamera=s;r=new THREE.Gyroscope;r.position=p.shadowCascadeOffset;r.add(J);r.add(J.target);s.add(r);p.shadowCascadeArray[w]=J;console.log("Created virtualLight",J)}y=p;E=w;z=y.shadowCascadeArray[E];z.position.copy(y.position);z.target.position.copy(y.target.position);z.lookAt(z.target);z.shadowCameraVisible=y.shadowCameraVisible;z.shadowDarkness=y.shadowDarkness;z.shadowBias=y.shadowCascadeBias[E];r=y.shadowCascadeNearZ[E];
y=y.shadowCascadeFarZ[E];z=z.pointsFrustum;z[0].z=r;z[1].z=r;z[2].z=r;z[3].z=r;z[4].z=y;z[5].z=y;z[6].z=y;z[7].z=y;P[v]=J;v++}else P[v]=p,v++;u=0;for(t=P.length;u<t;u++){p=P[u];p.shadowMap||(w=THREE.LinearFilter,b.shadowMapType===THREE.PCFSoftShadowMap&&(w=THREE.NearestFilter),p.shadowMap=new THREE.WebGLRenderTarget(p.shadowMapWidth,p.shadowMapHeight,{minFilter:w,magFilter:w,format:THREE.RGBAFormat}),p.shadowMapSize=new THREE.Vector2(p.shadowMapWidth,p.shadowMapHeight),p.shadowMatrix=new THREE.Matrix4);
if(!p.shadowCamera){if(p instanceof THREE.SpotLight)p.shadowCamera=new THREE.PerspectiveCamera(p.shadowCameraFov,p.shadowMapWidth/p.shadowMapHeight,p.shadowCameraNear,p.shadowCameraFar);else if(p instanceof THREE.DirectionalLight)p.shadowCamera=new THREE.OrthographicCamera(p.shadowCameraLeft,p.shadowCameraRight,p.shadowCameraTop,p.shadowCameraBottom,p.shadowCameraNear,p.shadowCameraFar);else{console.error("Unsupported light type for shadow");continue}q.add(p.shadowCamera);!0===q.autoUpdate&&q.updateMatrixWorld()}p.shadowCameraVisible&&
!p.cameraHelper&&(p.cameraHelper=new THREE.CameraHelper(p.shadowCamera),p.shadowCamera.add(p.cameraHelper));if(p.isVirtual&&J.originalCamera==s){w=s;v=p.shadowCamera;r=p.pointsFrustum;z=p.pointsWorld;k.set(Infinity,Infinity,Infinity);l.set(-Infinity,-Infinity,-Infinity);for(y=0;8>y;y++)E=z[y],E.copy(r[y]),THREE.ShadowMapPlugin.__projector.unprojectVector(E,w),E.applyMatrix4(v.matrixWorldInverse),E.x<k.x&&(k.x=E.x),E.x>l.x&&(l.x=E.x),E.y<k.y&&(k.y=E.y),E.y>l.y&&(l.y=E.y),E.z<k.z&&(k.z=E.z),E.z>l.z&&
(l.z=E.z);v.left=k.x;v.right=l.x;v.top=l.y;v.bottom=k.y;v.updateProjectionMatrix()}v=p.shadowMap;r=p.shadowMatrix;w=p.shadowCamera;w.position.setFromMatrixPosition(p.matrixWorld);n.setFromMatrixPosition(p.target.matrixWorld);w.lookAt(n);w.updateMatrixWorld();w.matrixWorldInverse.getInverse(w.matrixWorld);p.cameraHelper&&(p.cameraHelper.visible=p.shadowCameraVisible);p.shadowCameraVisible&&p.cameraHelper.update();r.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);r.multiply(w.projectionMatrix);r.multiply(w.matrixWorldInverse);
h.multiplyMatrices(w.projectionMatrix,w.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(v);b.clear();z=q.__webglObjects;p=0;for(v=z.length;p<v;p++)y=z[p],r=y.object,y.render=!1,!r.visible||!r.castShadow||(r instanceof THREE.Mesh||r instanceof THREE.ParticleSystem)&&r.frustumCulled&&!g.intersectsObject(r)||(r._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse,r.matrixWorld),y.render=!0);p=0;for(v=z.length;p<v;p++)y=z[p],y.render&&(r=y.object,y=y.buffer,A=r.material instanceof THREE.MeshFaceMaterial?
r.material.materials[0]:r.material,E=void 0!==r.geometry.morphTargets&&0<r.geometry.morphTargets.length&&A.morphTargets,A=r instanceof THREE.SkinnedMesh&&A.skinning,E=r.customDepthMaterial?r.customDepthMaterial:A?E?f:e:E?d:c,y instanceof THREE.BufferGeometry?b.renderBufferDirect(w,q.__lights,null,E,y,r):b.renderBuffer(w,q.__lights,null,E,y,r));z=q.__webglObjectsImmediate;p=0;for(v=z.length;p<v;p++)y=z[p],r=y.object,r.visible&&r.castShadow&&(r._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse,
r.matrixWorld),b.renderImmediateObject(w,q.__lights,null,c,r))}u=b.getClearColor();t=b.getClearAlpha();a.clearColor(u.r,u.g,u.b,t);a.enable(a.BLEND);b.shadowMapCullFace===THREE.CullFaceFront&&a.cullFace(a.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;THREE.SpritePlugin=function(){var a,b,c,d,e,f,g,h,k,l,n,q,s,u,t,p,v;function w(a,b){return a.z!==b.z?b.z-a.z:b.id-a.id}var r,y,E,z,P,J,A,C;this.init=function(w){r=w.context;y=w;z=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);P=new Uint16Array([0,1,2,0,2,3]);J=r.createBuffer();A=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,J);r.bufferData(r.ARRAY_BUFFER,z,r.STATIC_DRAW);r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,A);r.bufferData(r.ELEMENT_ARRAY_BUFFER,P,r.STATIC_DRAW);w=r.createProgram();
var H=r.createShader(r.VERTEX_SHADER),K=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(H,["precision "+y.getPrecision()+" float;","uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
r.shaderSource(K,["precision "+y.getPrecision()+" float;","uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
r.compileShader(H);r.compileShader(K);r.attachShader(w,H);r.attachShader(w,K);r.linkProgram(w);C=w;p=r.getAttribLocation(C,"position");v=r.getAttribLocation(C,"uv");a=r.getUniformLocation(C,"uvOffset");b=r.getUniformLocation(C,"uvScale");c=r.getUniformLocation(C,"rotation");d=r.getUniformLocation(C,"scale");e=r.getUniformLocation(C,"color");f=r.getUniformLocation(C,"map");g=r.getUniformLocation(C,"opacity");h=r.getUniformLocation(C,"modelViewMatrix");k=r.getUniformLocation(C,"projectionMatrix");l=
r.getUniformLocation(C,"fogType");n=r.getUniformLocation(C,"fogDensity");q=r.getUniformLocation(C,"fogNear");s=r.getUniformLocation(C,"fogFar");u=r.getUniformLocation(C,"fogColor");t=r.getUniformLocation(C,"alphaTest");w=document.createElement("canvas");w.width=8;w.height=8;H=w.getContext("2d");H.fillStyle="#ffffff";H.fillRect(0,0,w.width,w.height);E=new THREE.Texture(w);E.needsUpdate=!0};this.render=function(z,H,K,x){K=z.__webglSprites;if(x=K.length){r.useProgram(C);r.enableVertexAttribArray(p);
r.enableVertexAttribArray(v);r.disable(r.CULL_FACE);r.enable(r.BLEND);r.bindBuffer(r.ARRAY_BUFFER,J);r.vertexAttribPointer(p,2,r.FLOAT,!1,16,0);r.vertexAttribPointer(v,2,r.FLOAT,!1,16,8);r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,A);r.uniformMatrix4fv(k,!1,H.projectionMatrix.elements);r.activeTexture(r.TEXTURE0);r.uniform1i(f,0);var N=0,F=0,B=z.fog;B?(r.uniform3f(u,B.color.r,B.color.g,B.color.b),B instanceof THREE.Fog?(r.uniform1f(q,B.near),r.uniform1f(s,B.far),r.uniform1i(l,1),F=N=1):B instanceof THREE.FogExp2&&
(r.uniform1f(n,B.density),r.uniform1i(l,2),F=N=2)):(r.uniform1i(l,0),F=N=0);for(var D,G=[],B=0;B<x;B++)D=K[B],!1!==D.visible&&(D._modelViewMatrix.multiplyMatrices(H.matrixWorldInverse,D.matrixWorld),D.z=-D._modelViewMatrix.elements[14]);K.sort(w);for(B=0;B<x;B++)D=K[B],!1!==D.visible&&(H=D.material,r.uniform1f(t,H.alphaTest),r.uniformMatrix4fv(h,!1,D._modelViewMatrix.elements),G[0]=D.scale.x,G[1]=D.scale.y,D=z.fog&&H.fog?F:0,N!==D&&(r.uniform1i(l,D),N=D),null!==H.map?(r.uniform2f(a,H.map.offset.x,
H.map.offset.y),r.uniform2f(b,H.map.repeat.x,H.map.repeat.y)):(r.uniform2f(a,0,0),r.uniform2f(b,1,1)),r.uniform1f(g,H.opacity),r.uniform3f(e,H.color.r,H.color.g,H.color.b),r.uniform1f(c,H.rotation),r.uniform2fv(d,G),y.setBlending(H.blending,H.blendEquation,H.blendSrc,H.blendDst),y.setDepthTest(H.depthTest),y.setDepthWrite(H.depthWrite),H.map&&H.map.image&&H.map.image.width?y.setTexture(H.map,0):y.setTexture(E,0),r.drawElements(r.TRIANGLES,6,r.UNSIGNED_SHORT,0));r.enable(r.CULL_FACE)}}};THREE.DepthPassPlugin=function(){this.enabled=!1;this.renderTarget=null;var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4;this.init=function(g){a=g.context;b=g;g=THREE.ShaderLib.depthRGBA;var h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,
vertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,b){this.enabled&&this.update(a,b)};this.update=function(k,l){var n,q,s,u,t,p;a.clearColor(1,1,1,1);a.disable(a.BLEND);b.setDepthTest(!0);!0===k.autoUpdate&&k.updateMatrixWorld();l.matrixWorldInverse.getInverse(l.matrixWorld);h.multiplyMatrices(l.projectionMatrix,
l.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(this.renderTarget);b.clear();p=k.__webglObjects;n=0;for(q=p.length;n<q;n++)s=p[n],t=s.object,s.render=!1,!t.visible||(t instanceof THREE.Mesh||t instanceof THREE.ParticleSystem)&&t.frustumCulled&&!g.intersectsObject(t)||(t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse,t.matrixWorld),s.render=!0);var v;n=0;for(q=p.length;n<q;n++)s=p[n],s.render&&(t=s.object,s=s.buffer,t instanceof THREE.ParticleSystem&&!t.customDepthMaterial||((v=
t.material instanceof THREE.MeshFaceMaterial?t.material.materials[0]:t.material)&&b.setMaterialFaces(t.material),u=0<t.geometry.morphTargets.length&&v.morphTargets,v=t instanceof THREE.SkinnedMesh&&v.skinning,u=t.customDepthMaterial?t.customDepthMaterial:v?u?f:e:u?d:c,s instanceof THREE.BufferGeometry?b.renderBufferDirect(l,k.__lights,null,u,s,t):b.renderBuffer(l,k.__lights,null,u,s,t)));p=k.__webglObjectsImmediate;n=0;for(q=p.length;n<q;n++)s=p[n],t=s.object,t.visible&&(t._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse,
t.matrixWorld),b.renderImmediateObject(l,k.__lights,null,c,t));n=b.getClearColor();q=b.getClearAlpha();a.clearColor(n.r,n.g,n.b,q);a.enable(a.BLEND)}};THREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"},lensFlare:{vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}};
// stats.js - http://github.com/mrdoob/stats.js
var Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement("div");f.id="stats";f.addEventListener("mousedown",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText="width:80px;opacity:0.9;cursor:pointer";var a=document.createElement("div");a.id="fps";a.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002";f.appendChild(a);var i=document.createElement("div");i.id="fpsText";i.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
i.innerHTML="FPS";a.appendChild(i);var c=document.createElement("div");c.id="fpsGraph";c.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff";for(a.appendChild(c);74>c.children.length;){var j=document.createElement("span");j.style.cssText="width:1px;height:30px;float:left;background-color:#113";c.appendChild(j)}var d=document.createElement("div");d.id="ms";d.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";f.appendChild(d);var k=document.createElement("div");
k.id="msText";k.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";k.innerHTML="MS";d.appendChild(k);var e=document.createElement("div");e.id="msGraph";e.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0";for(d.appendChild(e);74>e.children.length;)j=document.createElement("span"),j.style.cssText="width:1px;height:30px;float:left;background-color:#131",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=
"block";d.style.display="none";break;case 1:a.style.display="none",d.style.display="block"}};return{REVISION:11,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+" MS ("+n+"-"+o+")";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+"px";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+" FPS ("+p+"-"+q+")",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=
a+"px",m=b,r=0);return b},update:function(){l=this.end()}}};
/**
 * @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com
 * @author Tony Parisi / http://www.tonyparisi.com/ 
 */

THREE.ColladaLoader = function () {

	var COLLADA = null;
	var scene = null;
	var daeScene;

	var readyCallbackFunc = null;

	var sources = {};
	var images = {};
	var animations = {};
	var controllers = {};
	var geometries = {};
	var materials = {};
	var effects = {};
	var cameras = {};
	var lights = {};

	var animData;
	var visualScenes;
	var baseUrl;
	var morphs;
	var skins;

	var flip_uv = true;
	var preferredShading = THREE.SmoothShading;

	var options = {
		// Force Geometry to always be centered at the local origin of the
		// containing Mesh.
		centerGeometry: false,

		// Axis conversion is done for geometries, animations, and controllers.
		// If we ever pull cameras or lights out of the COLLADA file, they'll
		// need extra work.
		convertUpAxis: false,

		subdivideFaces: true,

		upAxis: 'Y',

		// For reflective or refractive materials we'll use this cubemap
		defaultEnvMap: null

	};

	var colladaUnit = 1.0;
	var colladaUp = 'Y';
	var upConversion = null;

	function load ( url, readyCallback, progressCallback ) {

		var length = 0;

		if ( document.implementation && document.implementation.createDocument ) {

			var request = new XMLHttpRequest();

			request.onreadystatechange = function() {

				if( request.readyState == 4 ) {

					if( request.status == 0 || request.status == 200 ) {


						if ( request.responseXML ) {

							readyCallbackFunc = readyCallback;
							parse( request.responseXML, undefined, url );

						} else if ( request.responseText ) {

							readyCallbackFunc = readyCallback;
							var xmlParser = new DOMParser();
							var responseXML = xmlParser.parseFromString( request.responseText, "application/xml" );
							parse( responseXML, undefined, url );

						} else {

							console.error( "ColladaLoader: Empty or non-existing file (" + url + ")" );

						}

					}

				} else if ( request.readyState == 3 ) {

					if ( progressCallback ) {

						if ( length == 0 ) {

							length = request.getResponseHeader( "Content-Length" );

						}

						progressCallback( { total: length, loaded: request.responseText.length } );

					}

				}

			}

			request.open( "GET", url, true );
			request.send( null );

		} else {

			alert( "Don't know how to parse XML!" );

		}

	}

	function parse( doc, callBack, url ) {

		COLLADA = doc;
		callBack = callBack || readyCallbackFunc;

		if ( url !== undefined ) {

			var parts = url.split( '/' );
			parts.pop();
			baseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

		}

		parseAsset();
		setUpConversion();
		images = parseLib( "library_images image", _Image, "image" );
		materials = parseLib( "library_materials material", Material, "material" );
		effects = parseLib( "library_effects effect", Effect, "effect" );
		geometries = parseLib( "library_geometries geometry", Geometry, "geometry" );
		cameras = parseLib( "library_cameras camera", Camera, "camera" );
		lights = parseLib( "library_lights light", Light, "light" );
		controllers = parseLib( "library_controllers controller", Controller, "controller" );
		animations = parseLib( "library_animations animation", Animation, "animation" );
		visualScenes = parseLib( "library_visual_scenes visual_scene", VisualScene, "visual_scene" );
		
		morphs = [];
		skins = [];

		daeScene = parseScene();
		scene = new THREE.Object3D();

		for ( var i = 0; i < daeScene.nodes.length; i ++ ) {

			scene.add( createSceneGraph( daeScene.nodes[ i ] ) );

		}

		// unit conversion
		scene.scale.multiplyScalar( colladaUnit );

		createAnimations();

		var result = {

			scene: scene,
			morphs: morphs,
			skins: skins,
			animations: animData,
			dae: {
				images: images,
				materials: materials,
				cameras: cameras,
				lights: lights,
				effects: effects,
				geometries: geometries,
				controllers: controllers,
				animations: animations,
				visualScenes: visualScenes,
				scene: daeScene
			}

		};

		if ( callBack ) {

			callBack( result );

		}

		return result;

	}

	function setPreferredShading ( shading ) {

		preferredShading = shading;

	}

	function parseAsset () {

		var elements = COLLADA.querySelectorAll('asset');

		var element = elements[0];

		if ( element && element.childNodes ) {

			for ( var i = 0; i < element.childNodes.length; i ++ ) {

				var child = element.childNodes[ i ];

				switch ( child.nodeName ) {

					case 'unit':

						var meter = child.getAttribute( 'meter' );

						if ( meter ) {

							colladaUnit = parseFloat( meter );

						}

						break;

					case 'up_axis':

						colladaUp = child.textContent.charAt(0);
						break;

				}

			}

		}

	}

	function parseLib ( q, classSpec, prefix ) {

		var elements = COLLADA.querySelectorAll(q);

		var lib = {};

		var i = 0;

		var elementsLength = elements.length;

		for ( var j = 0; j < elementsLength; j ++ ) {

			var element = elements[j];
			var daeElement = ( new classSpec() ).parse( element );

			if ( !daeElement.id || daeElement.id.length == 0 ) daeElement.id = prefix + ( i ++ );
			lib[ daeElement.id ] = daeElement;

		}

		return lib;

	}

	function parseScene() {
	
		var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];
		
		if ( sceneElement ) {

			var url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );
			return visualScenes[ url.length > 0 ? url : 'visual_scene0' ];

		} else {

			return null;

		}

	}

	function createAnimations() {

		animData = [];

		// fill in the keys
		recurseHierarchy( scene );

	}

	function recurseHierarchy( node ) {

		var n = daeScene.getChildById( node.name, true ),
			newData = null;

		if ( n && n.keys ) {

			newData = {
				fps: 60,
				hierarchy: [ {
					node: n,
					keys: n.keys,
					sids: n.sids
				} ],
				node: node,
				name: 'animation_' + node.name,
				length: 0
			};

			animData.push(newData);

			for ( var i = 0, il = n.keys.length; i < il; i++ ) {

				newData.length = Math.max( newData.length, n.keys[i].time );

			}

		} else  {

			newData = {
				hierarchy: [ {
					keys: [],
					sids: []
				} ]
			}

		}

		for ( var i = 0, il = node.children.length; i < il; i++ ) {

			var d = recurseHierarchy( node.children[i] );

			for ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {

				newData.hierarchy.push( {
					keys: [],
					sids: []
				} );

			}

		}

		return newData;

	}

	function calcAnimationBounds () {

		var start = 1000000;
		var end = -start;
		var frames = 0;
		var ID;
		for ( var id in animations ) {

			var animation = animations[ id ];
			ID = ID || animation.id; 
			for ( var i = 0; i < animation.sampler.length; i ++ ) {

				var sampler = animation.sampler[ i ];
				
				sampler.create();

				start = Math.min( start, sampler.startTime );
				end = Math.max( end, sampler.endTime );
				frames = Math.max( frames, sampler.input.length );

			}

		}

		return { start:start, end:end, frames:frames,ID:ID };

	}

	function createMorph ( geometry, ctrl ) {

		var morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;

		if ( !morphCtrl || !morphCtrl.morph ) {

			console.log("could not find morph controller!");
			return;

		}

		var morph = morphCtrl.morph;

		for ( var i = 0; i < morph.targets.length; i ++ ) {

			var target_id = morph.targets[ i ];
			var daeGeometry = geometries[ target_id ];

			if ( !daeGeometry.mesh ||
				 !daeGeometry.mesh.primitives ||
				 !daeGeometry.mesh.primitives.length ) {
				 continue;
			}

			var target = daeGeometry.mesh.primitives[ 0 ].geometry;

			if ( target.vertices.length === geometry.vertices.length ) {

				geometry.morphTargets.push( { name: "target_1", vertices: target.vertices } );

			}

		}

		geometry.morphTargets.push( { name: "target_Z", vertices: geometry.vertices } );

	};

	function createSkin ( geometry, ctrl, applyBindShape ) {

		var skinCtrl = controllers[ ctrl.url ];

		if ( !skinCtrl || !skinCtrl.skin ) {

			console.log( "could not find skin controller!" );
			return;

		}

		if ( !ctrl.skeleton || !ctrl.skeleton.length ) {

			console.log( "could not find the skeleton for the skin!" );
			return;

		}

		var skin = skinCtrl.skin;
		var skeleton = daeScene.getChildById( ctrl.skeleton[ 0 ] );
		var hierarchy = [];

		applyBindShape = applyBindShape !== undefined ? applyBindShape : true;

		var bones = [];
		geometry.skinWeights = [];
		geometry.skinIndices = [];

		//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );
		//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );

		/*
		geometry.animation = {
			name: 'take_001',
			fps: 30,
			length: 2,
			JIT: true,
			hierarchy: hierarchy
		};
		*/

		if ( applyBindShape ) {

			for ( var i = 0; i < geometry.vertices.length; i ++ ) {

				geometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );

			}

		}

	}

	function setupSkeleton ( node, bones, frame, parent ) {

		node.world = node.world || new THREE.Matrix4();
		node.localworld = node.localworld || new THREE.Matrix4();
		node.world.copy( node.matrix );
		node.localworld.copy( node.matrix );

		if ( node.channels && node.channels.length ) {

			var channel = node.channels[ 0 ];
			var m = channel.sampler.output[ frame ];

			if ( m instanceof THREE.Matrix4 ) {

				node.world.copy( m );
				node.localworld.copy(m);
				if(frame == 0)
					node.matrix.copy(m);
			}

		}

		if ( parent ) {

			node.world.multiplyMatrices( parent, node.world );

		}

		bones.push( node );

		for ( var i = 0; i < node.nodes.length; i ++ ) {

			setupSkeleton( node.nodes[ i ], bones, frame, node.world );

		}

	}

	function setupSkinningMatrices ( bones, skin ) {

		// FIXME: this is dumb...
		
		for ( var i = 0; i < bones.length; i ++ ) {
		
			var bone = bones[ i ];
			var found = -1;

			if ( bone.type != 'JOINT' ) continue;

			for ( var j = 0; j < skin.joints.length; j ++ ) {

				if ( bone.sid == skin.joints[ j ] ) {

					found = j;
					break;

				}

			}

			if ( found >= 0 ) {

				var inv = skin.invBindMatrices[ found ];

				bone.invBindMatrix = inv;
				bone.skinningMatrix = new THREE.Matrix4();
				bone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)
				bone.animatrix = new THREE.Matrix4();

				bone.animatrix.copy(bone.localworld);
				bone.weights = [];

				for ( var j = 0; j < skin.weights.length; j ++ ) {
					
					for (var k = 0; k < skin.weights[ j ].length; k ++ ) {

						var w = skin.weights[ j ][ k ];

						if ( w.joint == found ) {

							bone.weights.push( w );

						}

					}

				}

			} else {

				console.warn( "ColladaLoader: Could not find joint '" + bone.sid + "'." );

				bone.skinningMatrix = new THREE.Matrix4();
				bone.weights = [];

			}
		}

	}

	//Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix
	function flattenSkeleton(skeleton) {

		var list = [];
		var walk = function(parentid, node, list) {

			var bone = {};
			bone.name = node.sid;
			bone.parent = parentid;
			bone.matrix = node.matrix;
			var data = [new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3()];
			bone.matrix.decompose(data[0],data[1],data[2]);
							
			bone.pos = [data[0].x,data[0].y,data[0].z];
							
			bone.scl = [data[2].x,data[2].y,data[2].z];
			bone.rotq = [data[1].x,data[1].y,data[1].z,data[1].w];
			list.push(bone);

			for(var i in node.nodes) {

				walk(node.sid,node.nodes[i],list);

			}

		};

		walk(-1,skeleton,list);
		return list;

	}

	//Move the vertices into the pose that is proper for the start of the animation
	function skinToBindPose(geometry,skeleton,skinController) {

		var bones = [];
		setupSkeleton( skeleton, bones, -1 );
		setupSkinningMatrices( bones, skinController.skin );
		v = new THREE.Vector3();
		var skinned = [];

		for(var i =0; i < geometry.vertices.length; i++) {

			skinned.push(new THREE.Vector3());

		}

		for ( i = 0; i < bones.length; i ++ ) {

			if ( bones[ i ].type != 'JOINT' ) continue;

			for ( j = 0; j < bones[ i ].weights.length; j ++ ) {

				w = bones[ i ].weights[ j ];
				vidx = w.index;
				weight = w.weight;

				o = geometry.vertices[vidx];
				s = skinned[vidx];
				
				v.x = o.x;
				v.y = o.y;
				v.z = o.z;

				v.applyMatrix4( bones[i].skinningMatrix );

				s.x += (v.x * weight);
				s.y += (v.y * weight);
				s.z += (v.z * weight);
			}

		}

		for(var i =0; i < geometry.vertices.length; i++) {

			geometry.vertices[i] = skinned[i];

		}

	}

	function applySkin ( geometry, instanceCtrl, frame ) {

		// TODO: get this from the renderer or options
		var maxbones = 30;
		
		var skinController = controllers[ instanceCtrl.url ];

		frame = frame !== undefined ? frame : 40;

		if ( !skinController || !skinController.skin ) {

			console.log( 'ColladaLoader: Could not find skin controller.' );
			return;

		}

		if ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {

			console.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );
			return;

		}

		var animationBounds = calcAnimationBounds();
		var skeleton = daeScene.getChildById( instanceCtrl.skeleton[0], true ) ||
					   daeScene.getChildBySid( instanceCtrl.skeleton[0], true );
		
		//flatten the skeleton into a list of bones
		var bonelist = flattenSkeleton(skeleton);
		var joints = skinController.skin.joints;

		//sort that list so that the order reflects the order in the joint list
		var sortedbones = [];
		for(var i = 0; i < joints.length; i++) {

			for(var j =0; j < bonelist.length; j++) {

				if(bonelist[j].name == joints[i]) {

					sortedbones[i] = bonelist[j];

				}

			}

		}

		//hook up the parents by index instead of name
		for(var i = 0; i < sortedbones.length; i++) {

			for(var j =0; j < sortedbones.length; j++) {

				if(sortedbones[i].parent == sortedbones[j].name) {

					sortedbones[i].parent = j;

				}

			}

		}


		var i, j, w, vidx, weight;
		var v = new THREE.Vector3(), o, s;

		// move vertices to bind shape
		for ( i = 0; i < geometry.vertices.length; i ++ ) {
					geometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );
		}

		var skinIndices = [];
		var skinWeights = [];
		var weights = skinController.skin.weights;

		//hook up the skin weights
		// TODO -  this might be a good place to choose greatest 4 weights
		for(var i =0; i < weights.length; i++) {

			var indicies = new THREE.Vector4(weights[i][0]?weights[i][0].joint:0,weights[i][1]?weights[i][1].joint:0,weights[i][2]?weights[i][2].joint:0,weights[i][3]?weights[i][3].joint:0);
			var weight = new THREE.Vector4(weights[i][0]?weights[i][0].weight:0,weights[i][1]?weights[i][1].weight:0,weights[i][2]?weights[i][2].weight:0,weights[i][3]?weights[i][3].weight:0);
			
			skinIndices.push(indicies);
			skinWeights.push(weight);

		}

		geometry.skinIndices = skinIndices;
		geometry.skinWeights = skinWeights;
		geometry.bones = sortedbones;
		// process animation, or simply pose the rig if no animation
		
		//create an animation for the animated bones
		//NOTE: this has no effect when using morphtargets
		var animationdata = {"name":animationBounds.ID,"fps":30,"length":animationBounds.frames/30,"hierarchy":[]};

		for(var j =0; j < sortedbones.length; j++) {

			animationdata.hierarchy.push({parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[]});

		}

		//if using hardware skinning, move the vertices into the binding pose
		if(sortedbones.length < maxbones) {

			skinToBindPose(geometry,skeleton,skinController);

		}

		for ( frame = 0; frame < animationBounds.frames; frame ++ ) {

			var bones = [];
			var skinned = [];
			// process the frame and setup the rig with a fresh
			// transform, possibly from the bone's animation channel(s)

			setupSkeleton( skeleton, bones, frame );
			setupSkinningMatrices( bones, skinController.skin );

			//if using hardware skinning, just hook up the animiation data
			if(sortedbones.length < maxbones) {

				for(var i = 0; i < bones.length; i ++) {

					for(var j = 0; j < animationdata.hierarchy.length; j ++) {

						if(animationdata.hierarchy[j].name == bones[i].sid) {

							var key = {};
							key.time = (frame/30);
							key.matrix = bones[i].animatrix;
							
							if(frame == 0)
								bones[i].matrix = key.matrix;
							
							var data = [new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3()];
							key.matrix.decompose(data[0],data[1],data[2]);
							
							key.pos = [data[0].x,data[0].y,data[0].z];
							
							key.scl = [data[2].x,data[2].y,data[2].z];
							key.rot = data[1];

							animationdata.hierarchy[j].keys.push(key);

						}

					}

				}

				geometry.animation = animationdata;

			} else {

				// otherwise, process the animation into morphtargets
				
				for ( i = 0; i < geometry.vertices.length; i++ ) {

					skinned.push( new THREE.Vector3() );

				}

				for ( i = 0; i < bones.length; i ++ ) {

					if ( bones[ i ].type != 'JOINT' ) continue;

					for ( j = 0; j < bones[ i ].weights.length; j ++ ) {

						w = bones[ i ].weights[ j ];
						vidx = w.index;
						weight = w.weight;

						o = geometry.vertices[vidx];
						s = skinned[vidx];

						v.x = o.x;
						v.y = o.y;
						v.z = o.z;

						v.applyMatrix4( bones[i].skinningMatrix );

						s.x += (v.x * weight);
						s.y += (v.y * weight);
						s.z += (v.z * weight);

					}

				}

			geometry.morphTargets.push( { name: "target_" + frame, vertices: skinned } );

			}

		}

	};

	function createSceneGraph ( node, parent ) {

		var obj = new THREE.Object3D();
		var skinned = false;
		var skinController;
		var morphController;
		var i, j;

		// FIXME: controllers

		for ( i = 0; i < node.controllers.length; i ++ ) {

			var controller = controllers[ node.controllers[ i ].url ];

			switch ( controller.type ) {

				case 'skin':

					if ( geometries[ controller.skin.source ] ) {

						var inst_geom = new InstanceGeometry();

						inst_geom.url = controller.skin.source;
						inst_geom.instance_material = node.controllers[ i ].instance_material;

						node.geometries.push( inst_geom );
						skinned = true;
						skinController = node.controllers[ i ];

					} else if ( controllers[ controller.skin.source ] ) {

						// urgh: controller can be chained
						// handle the most basic case...

						var second = controllers[ controller.skin.source ];
						morphController = second;
					//	skinController = node.controllers[i];

						if ( second.morph && geometries[ second.morph.source ] ) {

							var inst_geom = new InstanceGeometry();

							inst_geom.url = second.morph.source;
							inst_geom.instance_material = node.controllers[ i ].instance_material;

							node.geometries.push( inst_geom );

						}

					}

					break;

				case 'morph':

					if ( geometries[ controller.morph.source ] ) {

						var inst_geom = new InstanceGeometry();

						inst_geom.url = controller.morph.source;
						inst_geom.instance_material = node.controllers[ i ].instance_material;

						node.geometries.push( inst_geom );
						morphController = node.controllers[ i ];

					}

					console.log( 'ColladaLoader: Morph-controller partially supported.' );

				default:
					break;

			}

		}

		// geometries

		var double_sided_materials = {};

		for ( i = 0; i < node.geometries.length; i ++ ) {

			var instance_geometry = node.geometries[i];
			var instance_materials = instance_geometry.instance_material;
			var geometry = geometries[ instance_geometry.url ];
			var used_materials = {};
			var used_materials_array = [];
			var num_materials = 0;
			var first_material;

			if ( geometry ) {

				if ( !geometry.mesh || !geometry.mesh.primitives )
					continue;

				if ( obj.name.length == 0 ) {

					obj.name = geometry.id;

				}

				// collect used fx for this geometry-instance

				if ( instance_materials ) {

					for ( j = 0; j < instance_materials.length; j ++ ) {

						var instance_material = instance_materials[ j ];
						var mat = materials[ instance_material.target ];
						var effect_id = mat.instance_effect.url;
						var shader = effects[ effect_id ].shader;
						var material3js = shader.material;

						if ( geometry.doubleSided ) {

							if ( !( instance_material.symbol in double_sided_materials ) ) {

								var _copied_material = material3js.clone();
								_copied_material.side = THREE.DoubleSide;
								double_sided_materials[ instance_material.symbol ] = _copied_material;

							}

							material3js = double_sided_materials[ instance_material.symbol ];

						}

						material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
						used_materials[ instance_material.symbol ] = num_materials;
						used_materials_array.push( material3js );
						first_material = material3js;
						first_material.name = mat.name == null || mat.name === '' ? mat.id : mat.name;
						num_materials ++;

					}

				}

				var mesh;
				var material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, shading: THREE.FlatShading, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );
				var geom = geometry.mesh.geometry3js;

				if ( num_materials > 1 ) {

					material = new THREE.MeshFaceMaterial( used_materials_array );

					for ( j = 0; j < geom.faces.length; j ++ ) {

						var face = geom.faces[ j ];
						face.materialIndex = used_materials[ face.daeMaterial ]

					}

				}

				if ( skinController !== undefined ) {

					
					applySkin( geom, skinController );

					if(geom.morphTargets.length > 0) {

						material.morphTargets = true;
						material.skinning = false;

					} else {

						material.morphTargets = false;
						material.skinning = true;

					}				
					

					mesh = new THREE.SkinnedMesh( geom, material, false );


					//mesh.skeleton = skinController.skeleton;
					//mesh.skinController = controllers[ skinController.url ];
					//mesh.skinInstanceController = skinController;
					mesh.name = 'skin_' + skins.length;

					
					
					//mesh.animationHandle.setKey(0);
					skins.push( mesh );

				} else if ( morphController !== undefined ) {

					createMorph( geom, morphController );

					material.morphTargets = true;

					mesh = new THREE.Mesh( geom, material );
					mesh.name = 'morph_' + morphs.length;

					morphs.push( mesh );

				} else {

					mesh = new THREE.Mesh( geom, material );
					// mesh.geom.name = geometry.id;

				}

				// N.B.: TP says this is not a great default behavior. It's a nice
				// optimization to flatten the hierarchy but this should be done
				// only if requested by the user via a flag. For now I undid it
				// and fixed the character animation example that uses it
				// node.geometries.length > 1 ? obj.add( mesh ) : obj = mesh;
				obj.add(mesh);
			}

		}

		for ( i = 0; i < node.cameras.length; i ++ ) {

			var instance_camera = node.cameras[i];
			var cparams = cameras[instance_camera.url];

			var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio), 
					parseFloat(cparams.znear), parseFloat(cparams.zfar));

			obj.add(cam);
		}

		for ( i = 0; i < node.lights.length; i ++ ) {

			var light = null;
			var instance_light = node.lights[i];
			var lparams = lights[instance_light.url];

			if ( lparams && lparams.technique ) {

				var color = lparams.color.getHex();
				var intensity = lparams.intensity;
				var distance = 0;
				var angle = lparams.falloff_angle;
				var exponent; // Intentionally undefined, don't know what this is yet

				switch ( lparams.technique ) {

					case 'directional':

						light = new THREE.DirectionalLight( color, intensity, distance );
						light.position.set(0, 0, 1);
						break;

					case 'point':

						light = new THREE.PointLight( color, intensity, distance );
						break;

					case 'spot':

						light = new THREE.SpotLight( color, intensity, distance, angle, exponent );
						light.position.set(0, 0, 1);
						break;

					case 'ambient':

						light = new THREE.AmbientLight( color );
						break;

				}

			}

			if (light) {
				obj.add(light);
			}
		}

		obj.name = node.name || node.id || "";
		obj.layer = node.layer || "";
		obj.matrix = node.matrix;
		obj.matrix.decompose( obj.position, obj.quaternion, obj.scale );

		if ( options.centerGeometry && obj.geometry ) {

			var delta = THREE.GeometryUtils.center( obj.geometry );
			delta.multiply( obj.scale );
			delta.applyQuaternion( obj.quaternion );

			obj.position.sub( delta );

		}

		for ( i = 0; i < node.nodes.length; i ++ ) {

			obj.add( createSceneGraph( node.nodes[i], node ) );

		}

		return obj;

	};

	function getJointId( skin, id ) {

		for ( var i = 0; i < skin.joints.length; i ++ ) {

			if ( skin.joints[ i ] == id ) {

				return i;

			}

		}

	};

	function getLibraryNode( id ) {

        var nodes = COLLADA.querySelectorAll('library_nodes node');

        for ( var i = 0; i < nodes.length; i++ ) {

            var attObj = nodes[i].attributes.getNamedItem('id');
            if ( attObj && attObj.value === id ) {
                return nodes[i];
        }
        }

        return undefined;

	};

	function getChannelsForNode (node ) {

		var channels = [];
		var startTime = 1000000;
		var endTime = -1000000;

		for ( var id in animations ) {

			var animation = animations[id];

			for ( var i = 0; i < animation.channel.length; i ++ ) {

				var channel = animation.channel[i];
				var sampler = animation.sampler[i];
				var id = channel.target.split('/')[0];

				if ( sampler && id == node.id ) {

					sampler.create();
					channel.sampler = sampler;
					startTime = Math.min(startTime, sampler.startTime);
					endTime = Math.max(endTime, sampler.endTime);
					channels.push(channel);

				}

			}

		}

		if ( channels.length ) {

			node.startTime = startTime;
			node.endTime = endTime;

		}

		return channels;

	};

	function calcFrameDuration( node ) {

		var minT = 10000000;

		for ( var i = 0; i < node.channels.length; i ++ ) {

			var sampler = node.channels[i].sampler;

			for ( var j = 0; j < sampler.input.length - 1; j ++ ) {

				var t0 = sampler.input[ j ];
				var t1 = sampler.input[ j + 1 ];
				minT = Math.min( minT, t1 - t0 );

			}
		}

		return minT;

	};

	function calcMatrixAt( node, t ) {

		var animated = {};

		var i, j;

		for ( i = 0; i < node.channels.length; i ++ ) {

			var channel = node.channels[ i ];
			animated[ channel.sid ] = channel;

		}

		var matrix = new THREE.Matrix4();

		for ( i = 0; i < node.transforms.length; i ++ ) {

			var transform = node.transforms[ i ];
			var channel = animated[ transform.sid ];

			if ( channel !== undefined ) {

				var sampler = channel.sampler;
				var value;

				for ( j = 0; j < sampler.input.length - 1; j ++ ) {

					if ( sampler.input[ j + 1 ] > t ) {

						value = sampler.output[ j ];
						//console.log(value.flatten)
						break;

					}

				}

				if ( value !== undefined ) {

					if ( value instanceof THREE.Matrix4 ) {

						matrix.multiplyMatrices( matrix, value );

					} else {

						// FIXME: handle other types

						matrix.multiplyMatrices( matrix, transform.matrix );

					}

				} else {

					matrix.multiplyMatrices( matrix, transform.matrix );

				}

			} else {

				matrix.multiplyMatrices( matrix, transform.matrix );

			}

		}

		return matrix;

	};

	function bakeAnimations ( node ) {

		if ( node.channels && node.channels.length ) {

			var keys = [],
				sids = [];

			for ( var i = 0, il = node.channels.length; i < il; i++ ) {

				var channel = node.channels[i],
					fullSid = channel.fullSid,
					sampler = channel.sampler,
					input = sampler.input,
					transform = node.getTransformBySid( channel.sid ),
					member;

				if ( channel.arrIndices ) {

					member = [];

					for ( var j = 0, jl = channel.arrIndices.length; j < jl; j++ ) {

						member[ j ] = getConvertedIndex( channel.arrIndices[ j ] );

					}

				} else {

					member = getConvertedMember( channel.member );

				}

				if ( transform ) {

					if ( sids.indexOf( fullSid ) === -1 ) {

						sids.push( fullSid );

					}

					for ( var j = 0, jl = input.length; j < jl; j++ ) {

						var time = input[j],
							data = sampler.getData( transform.type, j ),
							key = findKey( keys, time );

						if ( !key ) {

							key = new Key( time );
							var timeNdx = findTimeNdx( keys, time );
							keys.splice( timeNdx == -1 ? keys.length : timeNdx, 0, key );

						}

						key.addTarget( fullSid, transform, member, data );

					}

				} else {

					console.log( 'Could not find transform "' + channel.sid + '" in node ' + node.id );

				}

			}

			// post process
			for ( var i = 0; i < sids.length; i++ ) {

				var sid = sids[ i ];

				for ( var j = 0; j < keys.length; j++ ) {

					var key = keys[ j ];

					if ( !key.hasTarget( sid ) ) {

						interpolateKeys( keys, key, j, sid );

					}

				}

			}

			node.keys = keys;
			node.sids = sids;

		}

	};

	function findKey ( keys, time) {

		var retVal = null;

		for ( var i = 0, il = keys.length; i < il && retVal == null; i++ ) {

			var key = keys[i];

			if ( key.time === time ) {

				retVal = key;

			} else if ( key.time > time ) {

				break;

			}

		}

		return retVal;

	};

	function findTimeNdx ( keys, time) {

		var ndx = -1;

		for ( var i = 0, il = keys.length; i < il && ndx == -1; i++ ) {

			var key = keys[i];

			if ( key.time >= time ) {

				ndx = i;

			}

		}

		return ndx;

	};

	function interpolateKeys ( keys, key, ndx, fullSid ) {

		var prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx-1 : 0 ),
			nextKey = getNextKeyWith( keys, fullSid, ndx+1 );

		if ( prevKey && nextKey ) {

			var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
				prevTarget = prevKey.getTarget( fullSid ),
				nextData = nextKey.getTarget( fullSid ).data,
				prevData = prevTarget.data,
				data;

			if ( prevTarget.type === 'matrix' ) {

				data = prevData;

			} else if ( prevData.length ) {

				data = [];

				for ( var i = 0; i < prevData.length; ++i ) {

					data[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;

				}

			} else {

				data = prevData + ( nextData - prevData ) * scale;

			}

			key.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );

		}

	};

	// Get next key with given sid

	function getNextKeyWith( keys, fullSid, ndx ) {

		for ( ; ndx < keys.length; ndx++ ) {

			var key = keys[ ndx ];

			if ( key.hasTarget( fullSid ) ) {

				return key;

			}

		}

		return null;

	};

	// Get previous key with given sid

	function getPrevKeyWith( keys, fullSid, ndx ) {

		ndx = ndx >= 0 ? ndx : ndx + keys.length;

		for ( ; ndx >= 0; ndx-- ) {

			var key = keys[ ndx ];

			if ( key.hasTarget( fullSid ) ) {

				return key;

			}

		}

		return null;

	};

	function _Image() {

		this.id = "";
		this.init_from = "";

	};

	_Image.prototype.parse = function(element) {

		this.id = element.getAttribute('id');

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeName == 'init_from' ) {

				this.init_from = child.textContent;

			}

		}

		return this;

	};

	function Controller() {

		this.id = "";
		this.name = "";
		this.type = "";
		this.skin = null;
		this.morph = null;

	};

	Controller.prototype.parse = function( element ) {

		this.id = element.getAttribute('id');
		this.name = element.getAttribute('name');
		this.type = "none";

		for ( var i = 0; i < element.childNodes.length; i++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'skin':

					this.skin = (new Skin()).parse(child);
					this.type = child.nodeName;
					break;

				case 'morph':

					this.morph = (new Morph()).parse(child);
					this.type = child.nodeName;
					break;

				default:
					break;

			}
		}

		return this;

	};

	function Morph() {

		this.method = null;
		this.source = null;
		this.targets = null;
		this.weights = null;

	};

	Morph.prototype.parse = function( element ) {

		var sources = {};
		var inputs = [];
		var i;

		this.method = element.getAttribute( 'method' );
		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );

		for ( i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'source':

					var source = ( new Source() ).parse( child );
					sources[ source.id ] = source;
					break;

				case 'targets':

					inputs = this.parseInputs( child );
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		for ( i = 0; i < inputs.length; i ++ ) {

			var input = inputs[ i ];
			var source = sources[ input.source ];

			switch ( input.semantic ) {

				case 'MORPH_TARGET':

					this.targets = source.read();
					break;

				case 'MORPH_WEIGHT':

					this.weights = source.read();
					break;

				default:
					break;

			}
		}

		return this;

	};

	Morph.prototype.parseInputs = function(element) {

		var inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1) continue;

			switch ( child.nodeName ) {

				case 'input':

					inputs.push( (new Input()).parse(child) );
					break;

				default:
					break;
			}
		}

		return inputs;

	};

	function Skin() {

		this.source = "";
		this.bindShapeMatrix = null;
		this.invBindMatrices = [];
		this.joints = [];
		this.weights = [];

	};

	Skin.prototype.parse = function( element ) {

		var sources = {};
		var joints, weights;

		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
		this.invBindMatrices = [];
		this.joints = [];
		this.weights = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'bind_shape_matrix':

					var f = _floats(child.textContent);
					this.bindShapeMatrix = getConvertedMat4( f );
					break;

				case 'source':

					var src = new Source().parse(child);
					sources[ src.id ] = src;
					break;

				case 'joints':

					joints = child;
					break;

				case 'vertex_weights':

					weights = child;
					break;

				default:

					console.log( child.nodeName );
					break;

			}
		}

		this.parseJoints( joints, sources );
		this.parseWeights( weights, sources );

		return this;

	};

	Skin.prototype.parseJoints = function ( element, sources ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					var input = ( new Input() ).parse( child );
					var source = sources[ input.source ];

					if ( input.semantic == 'JOINT' ) {

						this.joints = source.read();

					} else if ( input.semantic == 'INV_BIND_MATRIX' ) {

						this.invBindMatrices = source.read();

					}

					break;

				default:
					break;
			}

		}

	};

	Skin.prototype.parseWeights = function ( element, sources ) {

		var v, vcount, inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					inputs.push( ( new Input() ).parse( child ) );
					break;

				case 'v':

					v = _ints( child.textContent );
					break;

				case 'vcount':

					vcount = _ints( child.textContent );
					break;

				default:
					break;

			}

		}

		var index = 0;

		for ( var i = 0; i < vcount.length; i ++ ) {

			var numBones = vcount[i];
			var vertex_weights = [];

			for ( var j = 0; j < numBones; j++ ) {

				var influence = {};

				for ( var k = 0; k < inputs.length; k ++ ) {

					var input = inputs[ k ];
					var value = v[ index + input.offset ];

					switch ( input.semantic ) {

						case 'JOINT':

							influence.joint = value;//this.joints[value];
							break;

						case 'WEIGHT':

							influence.weight = sources[ input.source ].data[ value ];
							break;

						default:
							break;

					}

				}

				vertex_weights.push( influence );
				index += inputs.length;
			}

			for ( var j = 0; j < vertex_weights.length; j ++ ) {

				vertex_weights[ j ].index = i;

			}

			this.weights.push( vertex_weights );

		}

	};

	function VisualScene () {

		this.id = "";
		this.name = "";
		this.nodes = [];
		this.scene = new THREE.Object3D();

	};

	VisualScene.prototype.getChildById = function( id, recursive ) {

		for ( var i = 0; i < this.nodes.length; i ++ ) {

			var node = this.nodes[ i ].getChildById( id, recursive );

			if ( node ) {

				return node;

			}

		}

		return null;

	};

	VisualScene.prototype.getChildBySid = function( sid, recursive ) {

		for ( var i = 0; i < this.nodes.length; i ++ ) {

			var node = this.nodes[ i ].getChildBySid( sid, recursive );

			if ( node ) {

				return node;

			}

		}

		return null;

	};

	VisualScene.prototype.parse = function( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );
		this.nodes = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'node':

					this.nodes.push( ( new Node() ).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Node() {

		this.id = "";
		this.name = "";
		this.sid = "";
		this.nodes = [];
		this.controllers = [];
		this.transforms = [];
		this.geometries = [];
		this.channels = [];
		this.matrix = new THREE.Matrix4();

	};

	Node.prototype.getChannelForTransform = function( transformSid ) {

		for ( var i = 0; i < this.channels.length; i ++ ) {

			var channel = this.channels[i];
			var parts = channel.target.split('/');
			var id = parts.shift();
			var sid = parts.shift();
			var dotSyntax = (sid.indexOf(".") >= 0);
			var arrSyntax = (sid.indexOf("(") >= 0);
			var arrIndices;
			var member;

			if ( dotSyntax ) {

				parts = sid.split(".");
				sid = parts.shift();
				member = parts.shift();

			} else if ( arrSyntax ) {

				arrIndices = sid.split("(");
				sid = arrIndices.shift();

				for ( var j = 0; j < arrIndices.length; j ++ ) {

					arrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\)/, '' ) );

				}

			}

			if ( sid == transformSid ) {

				channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
				return channel;

			}

		}

		return null;

	};

	Node.prototype.getChildById = function ( id, recursive ) {

		if ( this.id == id ) {

			return this;

		}

		if ( recursive ) {

			for ( var i = 0; i < this.nodes.length; i ++ ) {

				var n = this.nodes[ i ].getChildById( id, recursive );

				if ( n ) {

					return n;

				}

			}

		}

		return null;

	};

	Node.prototype.getChildBySid = function ( sid, recursive ) {

		if ( this.sid == sid ) {

			return this;

		}

		if ( recursive ) {

			for ( var i = 0; i < this.nodes.length; i ++ ) {

				var n = this.nodes[ i ].getChildBySid( sid, recursive );

				if ( n ) {

					return n;

				}

			}
		}

		return null;

	};

	Node.prototype.getTransformBySid = function ( sid ) {

		for ( var i = 0; i < this.transforms.length; i ++ ) {

			if ( this.transforms[ i ].sid == sid ) return this.transforms[ i ];

		}

		return null;

	};

	Node.prototype.parse = function( element ) {

		var url;

		this.id = element.getAttribute('id');
		this.sid = element.getAttribute('sid');
		this.name = element.getAttribute('name');
		this.type = element.getAttribute('type');
		this.layer = element.getAttribute('layer');

		this.type = this.type == 'JOINT' ? this.type : 'NODE';

		this.nodes = [];
		this.transforms = [];
		this.geometries = [];
		this.cameras = [];
		this.lights = [];
		this.controllers = [];
		this.matrix = new THREE.Matrix4();

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'node':

					this.nodes.push( ( new Node() ).parse( child ) );
					break;

				case 'instance_camera':

					this.cameras.push( ( new InstanceCamera() ).parse( child ) );
					break;

				case 'instance_controller':

					this.controllers.push( ( new InstanceController() ).parse( child ) );
					break;

				case 'instance_geometry':

					this.geometries.push( ( new InstanceGeometry() ).parse( child ) );
					break;

				case 'instance_light':

					this.lights.push( ( new InstanceLight() ).parse( child ) );
					break;

				case 'instance_node':

					url = child.getAttribute( 'url' ).replace( /^#/, '' );
					var iNode = getLibraryNode( url );

					if ( iNode ) {

						this.nodes.push( ( new Node() ).parse( iNode )) ;

					}

					break;

				case 'rotate':
				case 'translate':
				case 'scale':
				case 'matrix':
				case 'lookat':
				case 'skew':

					this.transforms.push( ( new Transform() ).parse( child ) );
					break;

				case 'extra':
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		this.channels = getChannelsForNode( this );
		bakeAnimations( this );

		this.updateMatrix();

		return this;

	};

	Node.prototype.updateMatrix = function () {

		this.matrix.identity();

		for ( var i = 0; i < this.transforms.length; i ++ ) {

			this.transforms[ i ].apply( this.matrix );

		}

	};

	function Transform () {

		this.sid = "";
		this.type = "";
		this.data = [];
		this.obj = null;

	};

	Transform.prototype.parse = function ( element ) {

		this.sid = element.getAttribute( 'sid' );
		this.type = element.nodeName;
		this.data = _floats( element.textContent );
		this.convert();

		return this;

	};

	Transform.prototype.convert = function () {

		switch ( this.type ) {

			case 'matrix':

				this.obj = getConvertedMat4( this.data );
				break;

			case 'rotate':

				this.angle = THREE.Math.degToRad( this.data[3] );

			case 'translate':

				fixCoords( this.data, -1 );
				this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
				break;

			case 'scale':

				fixCoords( this.data, 1 );
				this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
				break;

			default:
				console.log( 'Can not convert Transform of type ' + this.type );
				break;

		}

	};

	Transform.prototype.apply = function () {

		var m1 = new THREE.Matrix4();

		return function ( matrix ) {

			switch ( this.type ) {

				case 'matrix':

					matrix.multiply( this.obj );

					break;

				case 'translate':

					matrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );

					break;

				case 'rotate':

					matrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );

					break;

				case 'scale':

					matrix.scale( this.obj );

					break;

			}

		};

	}();

	Transform.prototype.update = function ( data, member ) {

		var members = [ 'X', 'Y', 'Z', 'ANGLE' ];

		switch ( this.type ) {

			case 'matrix':

				if ( ! member ) {

					this.obj.copy( data );

				} else if ( member.length === 1 ) {

					switch ( member[ 0 ] ) {

						case 0:

							this.obj.n11 = data[ 0 ];
							this.obj.n21 = data[ 1 ];
							this.obj.n31 = data[ 2 ];
							this.obj.n41 = data[ 3 ];

							break;

						case 1:

							this.obj.n12 = data[ 0 ];
							this.obj.n22 = data[ 1 ];
							this.obj.n32 = data[ 2 ];
							this.obj.n42 = data[ 3 ];

							break;

						case 2:

							this.obj.n13 = data[ 0 ];
							this.obj.n23 = data[ 1 ];
							this.obj.n33 = data[ 2 ];
							this.obj.n43 = data[ 3 ];

							break;

						case 3:

							this.obj.n14 = data[ 0 ];
							this.obj.n24 = data[ 1 ];
							this.obj.n34 = data[ 2 ];
							this.obj.n44 = data[ 3 ];

							break;

					}

				} else if ( member.length === 2 ) {

					var propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );
					this.obj[ propName ] = data;

				} else {

					console.log('Incorrect addressing of matrix in transform.');

				}

				break;

			case 'translate':
			case 'scale':

				if ( Object.prototype.toString.call( member ) === '[object Array]' ) {

					member = members[ member[ 0 ] ];

				}

				switch ( member ) {

					case 'X':

						this.obj.x = data;
						break;

					case 'Y':

						this.obj.y = data;
						break;

					case 'Z':

						this.obj.z = data;
						break;

					default:

						this.obj.x = data[ 0 ];
						this.obj.y = data[ 1 ];
						this.obj.z = data[ 2 ];
						break;

				}

				break;

			case 'rotate':

				if ( Object.prototype.toString.call( member ) === '[object Array]' ) {

					member = members[ member[ 0 ] ];

				}

				switch ( member ) {

					case 'X':

						this.obj.x = data;
						break;

					case 'Y':

						this.obj.y = data;
						break;

					case 'Z':

						this.obj.z = data;
						break;

					case 'ANGLE':

						this.angle = THREE.Math.degToRad( data );
						break;

					default:

						this.obj.x = data[ 0 ];
						this.obj.y = data[ 1 ];
						this.obj.z = data[ 2 ];
						this.angle = THREE.Math.degToRad( data[ 3 ] );
						break;

				}
				break;

		}

	};

	function InstanceController() {

		this.url = "";
		this.skeleton = [];
		this.instance_material = [];

	};

	InstanceController.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');
		this.skeleton = [];
		this.instance_material = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType !== 1 ) continue;

			switch ( child.nodeName ) {

				case 'skeleton':

					this.skeleton.push( child.textContent.replace(/^#/, '') );
					break;

				case 'bind_material':
			
					var instances = child.querySelectorAll('instance_material');
					
					for ( var j = 0; j < instances.length; j ++ ){

						var instance = instances[j];
						this.instance_material.push( (new InstanceMaterial()).parse(instance) );
						
					}


					break;

				case 'extra':
					break;

				default:
					break;

			}
		}

		return this;

	};

	function InstanceMaterial () {

		this.symbol = "";
		this.target = "";

	};

	InstanceMaterial.prototype.parse = function ( element ) {

		this.symbol = element.getAttribute('symbol');
		this.target = element.getAttribute('target').replace(/^#/, '');
		return this;

	};

	function InstanceGeometry() {

		this.url = "";
		this.instance_material = [];

	};

	InstanceGeometry.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');
		this.instance_material = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			if ( child.nodeName == 'bind_material' ) {

				var instances = child.querySelectorAll('instance_material');
					
				for ( var j = 0; j < instances.length; j ++ ) {

					var instance = instances[j];
					this.instance_material.push( (new InstanceMaterial()).parse(instance) );

				}

				break;

			}

		}

		return this;

	};

	function Geometry() {

		this.id = "";
		this.mesh = null;

	};

	Geometry.prototype.parse = function ( element ) {

		this.id = element.getAttribute('id');

		extractDoubleSided( this, element );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];

			switch ( child.nodeName ) {

				case 'mesh':

					this.mesh = (new Mesh(this)).parse(child);
					break;

				case 'extra':

					// console.log( child );
					break;

				default:
					break;
			}
		}

		return this;

	};

	function Mesh( geometry ) {

		this.geometry = geometry.id;
		this.primitives = [];
		this.vertices = null;
		this.geometry3js = null;

	};

	Mesh.prototype.parse = function( element ) {

		this.primitives = [];

		var i, j;

		for ( i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'source':

					_source( child );
					break;

				case 'vertices':

					this.vertices = ( new Vertices() ).parse( child );
					break;

				case 'triangles':

					this.primitives.push( ( new Triangles().parse( child ) ) );
					break;

				case 'polygons':

					this.primitives.push( ( new Polygons().parse( child ) ) );
					break;

				case 'polylist':

					this.primitives.push( ( new Polylist().parse( child ) ) );
					break;

				default:
					break;

			}

		}

		this.geometry3js = new THREE.Geometry();

		var vertexData = sources[ this.vertices.input['POSITION'].source ].data;

		for ( i = 0; i < vertexData.length; i += 3 ) {

			this.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );

		}

		for ( i = 0; i < this.primitives.length; i ++ ) {

			var primitive = this.primitives[ i ];
			primitive.setVertices( this.vertices );
			this.handlePrimitive( primitive, this.geometry3js );

		}

		this.geometry3js.computeCentroids();
		this.geometry3js.computeFaceNormals();

		if ( this.geometry3js.calcNormals ) {

			this.geometry3js.computeVertexNormals();
			delete this.geometry3js.calcNormals;

		}

		// this.geometry3js.computeBoundingBox();

		return this;

	};

	Mesh.prototype.handlePrimitive = function( primitive, geom ) {

		var j, k, pList = primitive.p, inputs = primitive.inputs;
		var input, index, idx32;
		var source, numParams;
		var vcIndex = 0, vcount = 3, maxOffset = 0;
		var texture_sets = [];
		
		for ( j = 0; j < inputs.length; j ++ ) {

			input = inputs[ j ];

			var offset = input.offset + 1;
			maxOffset = (maxOffset < offset)? offset : maxOffset;

			switch ( input.semantic ) {

				case 'TEXCOORD':
					texture_sets.push( input.set );
					break;

			}

		}

		for ( var pCount = 0; pCount < pList.length; ++pCount ) {

			var p = pList[ pCount ], i = 0;

			while ( i < p.length ) {

				var vs = [];
				var ns = [];
				var ts = null;
				var cs = [];

				if ( primitive.vcount ) {

					vcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;

				} else {

					vcount = p.length / maxOffset;

				}


				for ( j = 0; j < vcount; j ++ ) {

					for ( k = 0; k < inputs.length; k ++ ) {

						input = inputs[ k ];
						source = sources[ input.source ];

						index = p[ i + ( j * maxOffset ) + input.offset ];
						numParams = source.accessor.params.length;
						idx32 = index * numParams;

						switch ( input.semantic ) {

							case 'VERTEX':

								vs.push( index );

								break;

							case 'NORMAL':

								ns.push( getConvertedVec3( source.data, idx32 ) );

								break;

							case 'TEXCOORD':

								ts = ts || { };
								if ( ts[ input.set ] === undefined ) ts[ input.set ] = [];
								// invert the V
								ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );

								break;

							case 'COLOR':

								cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

								break;

							default:

								break;

						}

					}

				}

				if ( ns.length == 0 ) {

					// check the vertices inputs
					input = this.vertices.input.NORMAL;

					if ( input ) {

						source = sources[ input.source ];
						numParams = source.accessor.params.length;

						for ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {

							ns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );

						}

					} else {

						geom.calcNormals = true;

					}

				}

				if ( !ts ) {

					ts = { };
					// check the vertices inputs
					input = this.vertices.input.TEXCOORD;

					if ( input ) {

						texture_sets.push( input.set );
						source = sources[ input.source ];
						numParams = source.accessor.params.length;

						for ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {

							idx32 = vs[ ndx ] * numParams;
							if ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];
							// invert the V
							ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );

						}

					}

				}

				if ( cs.length == 0 ) {

					// check the vertices inputs
					input = this.vertices.input.COLOR;

					if ( input ) {

						source = sources[ input.source ];
						numParams = source.accessor.params.length;

						for ( var ndx = 0, len = vs.length; ndx < len; ndx++ ) {

							idx32 = vs[ ndx ] * numParams;
							cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

						}

					}

				}

				var face = null, faces = [], uv, uvArr;

				if ( vcount === 3 ) {

					faces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );

				} else if ( vcount === 4 ) {

					faces.push( new THREE.Face3( vs[0], vs[1], vs[3], [ns[0], ns[1], ns[3]], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color() ) );
					
					faces.push( new THREE.Face3( vs[1], vs[2], vs[3], [ns[1], ns[2], ns[3]], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color() ) );

				} else if ( vcount > 4 && options.subdivideFaces ) {

					var clr = cs.length ? cs : new THREE.Color(),
						vec1, vec2, vec3, v1, v2, norm;

					// subdivide into multiple Face3s

					for ( k = 1; k < vcount - 1; ) {

						// FIXME: normals don't seem to be quite right

						faces.push( new THREE.Face3( vs[0], vs[k], vs[k+1], [ ns[0], ns[k++], ns[k] ],  clr ) );

					}

				}

				if ( faces.length ) {

					for ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {

						face = faces[ndx];
						face.daeMaterial = primitive.material;
						geom.faces.push( face );

						for ( k = 0; k < texture_sets.length; k++ ) {

							uv = ts[ texture_sets[k] ];

							if ( vcount > 4 ) {

								// Grab the right UVs for the vertices in this face
								uvArr = [ uv[0], uv[ndx+1], uv[ndx+2] ];

							} else if ( vcount === 4 ) {

								if ( ndx === 0 ) {

									uvArr = [ uv[0], uv[1], uv[3] ];

								} else {

									uvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];

								}

							} else {

								uvArr = [ uv[0], uv[1], uv[2] ];

							}

							if ( geom.faceVertexUvs[k] === undefined ) {

								geom.faceVertexUvs[k] = [];

							}

							geom.faceVertexUvs[k].push( uvArr );

						}

					}

				} else {

					console.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );

				}

				i += maxOffset * vcount;

			}
		}

	};

	function Polygons () {

		this.material = "";
		this.count = 0;
		this.inputs = [];
		this.vcount = null;
		this.p = [];
		this.geometry = new THREE.Geometry();

	};

	Polygons.prototype.setVertices = function ( vertices ) {

		for ( var i = 0; i < this.inputs.length; i ++ ) {

			if ( this.inputs[ i ].source == vertices.id ) {

				this.inputs[ i ].source = vertices.input[ 'POSITION' ].source;

			}

		}

	};

	Polygons.prototype.parse = function ( element ) {

		this.material = element.getAttribute( 'material' );
		this.count = _attr_as_int( element, 'count', 0 );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'input':

					this.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );
					break;

				case 'vcount':

					this.vcount = _ints( child.textContent );
					break;

				case 'p':

					this.p.push( _ints( child.textContent ) );
					break;

				case 'ph':

					console.warn( 'polygon holes not yet supported!' );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Polylist () {

		Polygons.call( this );

		this.vcount = [];

	};

	Polylist.prototype = Object.create( Polygons.prototype );

	function Triangles () {

		Polygons.call( this );

		this.vcount = 3;

	};

	Triangles.prototype = Object.create( Polygons.prototype );

	function Accessor() {

		this.source = "";
		this.count = 0;
		this.stride = 0;
		this.params = [];

	};

	Accessor.prototype.parse = function ( element ) {

		this.params = [];
		this.source = element.getAttribute( 'source' );
		this.count = _attr_as_int( element, 'count', 0 );
		this.stride = _attr_as_int( element, 'stride', 0 );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeName == 'param' ) {

				var param = {};
				param[ 'name' ] = child.getAttribute( 'name' );
				param[ 'type' ] = child.getAttribute( 'type' );
				this.params.push( param );

			}

		}

		return this;

	};

	function Vertices() {

		this.input = {};

	};

	Vertices.prototype.parse = function ( element ) {

		this.id = element.getAttribute('id');

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			if ( element.childNodes[i].nodeName == 'input' ) {

				var input = ( new Input() ).parse( element.childNodes[ i ] );
				this.input[ input.semantic ] = input;

			}

		}

		return this;

	};

	function Input () {

		this.semantic = "";
		this.offset = 0;
		this.source = "";
		this.set = 0;

	};

	Input.prototype.parse = function ( element ) {

		this.semantic = element.getAttribute('semantic');
		this.source = element.getAttribute('source').replace(/^#/, '');
		this.set = _attr_as_int(element, 'set', -1);
		this.offset = _attr_as_int(element, 'offset', 0);

		if ( this.semantic == 'TEXCOORD' && this.set < 0 ) {

			this.set = 0;

		}

		return this;

	};

	function Source ( id ) {

		this.id = id;
		this.type = null;

	};

	Source.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];

			switch ( child.nodeName ) {

				case 'bool_array':

					this.data = _bools( child.textContent );
					this.type = child.nodeName;
					break;

				case 'float_array':

					this.data = _floats( child.textContent );
					this.type = child.nodeName;
					break;

				case 'int_array':

					this.data = _ints( child.textContent );
					this.type = child.nodeName;
					break;

				case 'IDREF_array':
				case 'Name_array':

					this.data = _strings( child.textContent );
					this.type = child.nodeName;
					break;

				case 'technique_common':

					for ( var j = 0; j < child.childNodes.length; j ++ ) {

						if ( child.childNodes[ j ].nodeName == 'accessor' ) {

							this.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );
							break;

						}
					}
					break;

				default:
					// console.log(child.nodeName);
					break;

			}

		}

		return this;

	};

	Source.prototype.read = function () {

		var result = [];

		//for (var i = 0; i < this.accessor.params.length; i++) {

			var param = this.accessor.params[ 0 ];

			//console.log(param.name + " " + param.type);

			switch ( param.type ) {

				case 'IDREF':
				case 'Name': case 'name':
				case 'float':

					return this.data;

				case 'float4x4':

					for ( var j = 0; j < this.data.length; j += 16 ) {

						var s = this.data.slice( j, j + 16 );
						var m = getConvertedMat4( s );
						result.push( m );
					}

					break;

				default:

					console.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );
					break;

			}

		//}

		return result;

	};

	function Material () {

		this.id = "";
		this.name = "";
		this.instance_effect = null;

	};

	Material.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			if ( element.childNodes[ i ].nodeName == 'instance_effect' ) {

				this.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );
				break;

			}

		}

		return this;

	};

	function ColorOrTexture () {

		this.color = new THREE.Color();
		this.color.setRGB( Math.random(), Math.random(), Math.random() );
		this.color.a = 1.0;

		this.texture = null;
		this.texcoord = null;
		this.texOpts = null;

	};

	ColorOrTexture.prototype.isColor = function () {

		return ( this.texture == null );

	};

	ColorOrTexture.prototype.isTexture = function () {

		return ( this.texture != null );

	};

	ColorOrTexture.prototype.parse = function ( element ) {

		if (element.nodeName == 'transparent') {

			this.opaque = element.getAttribute('opaque');

		}
		
		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'color':

					var rgba = _floats( child.textContent );
					this.color = new THREE.Color();
					this.color.setRGB( rgba[0], rgba[1], rgba[2] );
					this.color.a = rgba[3];
					break;

				case 'texture':

					this.texture = child.getAttribute('texture');
					this.texcoord = child.getAttribute('texcoord');
					// Defaults from:
					// https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension
					this.texOpts = {
						offsetU: 0,
						offsetV: 0,
						repeatU: 1,
						repeatV: 1,
						wrapU: 1,
						wrapV: 1
					};
					this.parseTexture( child );
					break;

				default:
					break;

			}

		}

		return this;

	};

	ColorOrTexture.prototype.parseTexture = function ( element ) {

		if ( ! element.childNodes ) return this;

		// This should be supported by Maya, 3dsMax, and MotionBuilder

		if ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {

			element = element.childNodes[1];

			if ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {

				element = element.childNodes[1];

			}

		}

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'offsetU':
				case 'offsetV':
				case 'repeatU':
				case 'repeatV':

					this.texOpts[ child.nodeName ] = parseFloat( child.textContent );

					break;

				case 'wrapU':
				case 'wrapV':
					
					// some dae have a value of true which becomes NaN via parseInt

					if ( child.textContent.toUpperCase() === 'TRUE' ) {
					
						this.texOpts[ child.nodeName ] = 1;
					
					} else {
					
						this.texOpts[ child.nodeName ] = parseInt( child.textContent );
					
					}
					break;

				default:

					this.texOpts[ child.nodeName ] = child.textContent;

					break;

			}

		}

		return this;

	};

	function Shader ( type, effect ) {

		this.type = type;
		this.effect = effect;
		this.material = null;

	};

	Shader.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'ambient':
				case 'emission':
				case 'diffuse':
				case 'specular':
				case 'transparent':
				case 'bump':

					this[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );
					break;

				case 'shininess':
				case 'reflectivity':
				case 'index_of_refraction':
				case 'transparency':

					var f = child.querySelectorAll('float');

					if ( f.length > 0 )
						this[ child.nodeName ] = parseFloat( f[ 0 ].textContent );

					break;

				default:
					break;

			}

		}

		this.create();
		return this;

	};

	Shader.prototype.create = function() {

		var props = {};

		var transparent = false;

		if (this['transparency'] !== undefined && this['transparent'] !== undefined) {
			// convert transparent color RBG to average value
			var transparentColor = this['transparent'];
			var transparencyLevel = (this.transparent.color.r +
										this.transparent.color.g + 
										this.transparent.color.b)
										/ 3 * this.transparency;
			
			if (transparencyLevel > 0) {
				transparent = true;
				props[ 'transparent' ] = true;
				props[ 'opacity' ] = 1 - transparencyLevel;

			}

		}
		
		var keys = {
			'diffuse':'map', 
			'ambient':"lightMap" ,
			'specular':'specularMap',
			'emission':'emissionMap',
			'bump':'normalMap'
			};
		
		for ( var prop in this ) {

			switch ( prop ) {

				case 'ambient':
				case 'emission':
				case 'diffuse':
				case 'specular':
				case 'bump':

					var cot = this[ prop ];

					if ( cot instanceof ColorOrTexture ) {

						if ( cot.isTexture() ) {

							var samplerId = cot.texture;
							var surfaceId = this.effect.sampler[samplerId];

							if ( surfaceId !== undefined && surfaceId.source !== undefined ) {

								var surface = this.effect.surface[surfaceId.source];
								var image = images[surface.init_from];

								if (image) {

									var texture = THREE.ImageUtils.loadTexture(baseUrl + image.init_from);
									texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
									texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
									texture.offset.x = cot.texOpts.offsetU;
									texture.offset.y = cot.texOpts.offsetV;
									texture.repeat.x = cot.texOpts.repeatU;
									texture.repeat.y = cot.texOpts.repeatV;
									props[keys[prop]] = texture;

									// Texture with baked lighting?
									if (prop === 'emission') props['emissive'] = 0xffffff;

								}

							}

						} else if ( prop === 'diffuse' || !transparent ) {

							if ( prop === 'emission' ) {

								props[ 'emissive' ] = cot.color.getHex();

							} else {

								props[ prop ] = cot.color.getHex();

							}

						}

					}

					break;

				case 'shininess':

					props[ prop ] = this[ prop ];
					break;

				case 'reflectivity':

					props[ prop ] = this[ prop ];
					if( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;
					props['combine'] = THREE.MixOperation;	//mix regular shading with reflective component
					break;

				case 'index_of_refraction':

					props[ 'refractionRatio' ] = this[ prop ]; //TODO: "index_of_refraction" becomes "refractionRatio" in shader, but I'm not sure if the two are actually comparable
					if ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;
					break;

				case 'transparency':
					// gets figured out up top
					break;

				default:
					break;

			}

		}

		props[ 'shading' ] = preferredShading;
		props[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;

		switch ( this.type ) {

			case 'constant':

				if (props.emissive != undefined) props.color = props.emissive;
				this.material = new THREE.MeshBasicMaterial( props );
				break;

			case 'phong':
			case 'blinn':

				if (props.diffuse != undefined) props.color = props.diffuse;
				this.material = new THREE.MeshPhongMaterial( props );
				break;

			case 'lambert':
			default:

				if (props.diffuse != undefined) props.color = props.diffuse;
				this.material = new THREE.MeshLambertMaterial( props );
				break;

		}

		return this.material;

	};

	function Surface ( effect ) {

		this.effect = effect;
		this.init_from = null;
		this.format = null;

	};

	Surface.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'init_from':

					this.init_from = child.textContent;
					break;

				case 'format':

					this.format = child.textContent;
					break;

				default:

					console.log( "unhandled Surface prop: " + child.nodeName );
					break;

			}

		}

		return this;

	};

	function Sampler2D ( effect ) {

		this.effect = effect;
		this.source = null;
		this.wrap_s = null;
		this.wrap_t = null;
		this.minfilter = null;
		this.magfilter = null;
		this.mipfilter = null;

	};

	Sampler2D.prototype.parse = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'source':

					this.source = child.textContent;
					break;

				case 'minfilter':

					this.minfilter = child.textContent;
					break;

				case 'magfilter':

					this.magfilter = child.textContent;
					break;

				case 'mipfilter':

					this.mipfilter = child.textContent;
					break;

				case 'wrap_s':

					this.wrap_s = child.textContent;
					break;

				case 'wrap_t':

					this.wrap_t = child.textContent;
					break;

				default:

					console.log( "unhandled Sampler2D prop: " + child.nodeName );
					break;

			}

		}

		return this;

	};

	function Effect () {

		this.id = "";
		this.name = "";
		this.shader = null;
		this.surface = {};
		this.sampler = {};

	};

	Effect.prototype.create = function () {

		if ( this.shader == null ) {

			return null;

		}

	};

	Effect.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );

		extractDoubleSided( this, element );

		this.shader = null;

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'profile_COMMON':

					this.parseTechnique( this.parseProfileCOMMON( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Effect.prototype.parseNewparam = function ( element ) {

		var sid = element.getAttribute( 'sid' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'surface':

					this.surface[sid] = ( new Surface( this ) ).parse( child );
					break;

				case 'sampler2D':

					this.sampler[sid] = ( new Sampler2D( this ) ).parse( child );
					break;

				case 'extra':

					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

	};

	Effect.prototype.parseProfileCOMMON = function ( element ) {

		var technique;

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'profile_COMMON':

					this.parseProfileCOMMON( child );
					break;

				case 'technique':

					technique = child;
					break;

				case 'newparam':

					this.parseNewparam( child );
					break;

				case 'image':

					var _image = ( new _Image() ).parse( child );
					images[ _image.id ] = _image;
					break;

				case 'extra':
					break;

				default:

					console.log( child.nodeName );
					break;

			}

		}

		return technique;

	};

	Effect.prototype.parseTechnique= function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'constant':
				case 'lambert':
				case 'blinn':
				case 'phong':

					this.shader = ( new Shader( child.nodeName, this ) ).parse( child );
					break;
				case 'extra':
					this.parseExtra(child);	
					break;
				default:
					break;

			}

		}

	};
	
	Effect.prototype.parseExtra = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'technique':
					this.parseExtraTechnique( child );
					break;
				default:
					break;

			}

		}

	};
	
	Effect.prototype.parseExtraTechnique= function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[i];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'bump':
					this.shader.parse( element );
					break;
				default:
					break;

			}

		}

	};

	function InstanceEffect () {

		this.url = "";

	};

	InstanceEffect.prototype.parse = function ( element ) {

		this.url = element.getAttribute( 'url' ).replace( /^#/, '' );
		return this;

	};

	function Animation() {

		this.id = "";
		this.name = "";
		this.source = {};
		this.sampler = [];
		this.channel = [];

	};

	Animation.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );
		this.source = {};

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'animation':

					var anim = ( new Animation() ).parse( child );

					for ( var src in anim.source ) {

						this.source[ src ] = anim.source[ src ];

					}

					for ( var j = 0; j < anim.channel.length; j ++ ) {

						this.channel.push( anim.channel[ j ] );
						this.sampler.push( anim.sampler[ j ] );

					}

					break;

				case 'source':

					var src = ( new Source() ).parse( child );
					this.source[ src.id ] = src;
					break;

				case 'sampler':

					this.sampler.push( ( new Sampler( this ) ).parse( child ) );
					break;

				case 'channel':

					this.channel.push( ( new Channel( this ) ).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	function Channel( animation ) {

		this.animation = animation;
		this.source = "";
		this.target = "";
		this.fullSid = null;
		this.sid = null;
		this.dotSyntax = null;
		this.arrSyntax = null;
		this.arrIndices = null;
		this.member = null;

	};

	Channel.prototype.parse = function ( element ) {

		this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
		this.target = element.getAttribute( 'target' );

		var parts = this.target.split( '/' );

		var id = parts.shift();
		var sid = parts.shift();

		var dotSyntax = ( sid.indexOf(".") >= 0 );
		var arrSyntax = ( sid.indexOf("(") >= 0 );

		if ( dotSyntax ) {

			parts = sid.split(".");
			this.sid = parts.shift();
			this.member = parts.shift();

		} else if ( arrSyntax ) {

			var arrIndices = sid.split("(");
			this.sid = arrIndices.shift();

			for (var j = 0; j < arrIndices.length; j ++ ) {

				arrIndices[j] = parseInt( arrIndices[j].replace(/\)/, '') );

			}

			this.arrIndices = arrIndices;

		} else {

			this.sid = sid;

		}

		this.fullSid = sid;
		this.dotSyntax = dotSyntax;
		this.arrSyntax = arrSyntax;

		return this;

	};

	function Sampler ( animation ) {

		this.id = "";
		this.animation = animation;
		this.inputs = [];
		this.input = null;
		this.output = null;
		this.strideOut = null;
		this.interpolation = null;
		this.startTime = null;
		this.endTime = null;
		this.duration = 0;

	};

	Sampler.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.inputs = [];

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'input':

					this.inputs.push( (new Input()).parse( child ) );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Sampler.prototype.create = function () {

		for ( var i = 0; i < this.inputs.length; i ++ ) {

			var input = this.inputs[ i ];
			var source = this.animation.source[ input.source ];

			switch ( input.semantic ) {

				case 'INPUT':

					this.input = source.read();
					break;

				case 'OUTPUT':

					this.output = source.read();
					this.strideOut = source.accessor.stride;
					break;

				case 'INTERPOLATION':

					this.interpolation = source.read();
					break;

				case 'IN_TANGENT':

					break;

				case 'OUT_TANGENT':

					break;

				default:

					console.log(input.semantic);
					break;

			}

		}

		this.startTime = 0;
		this.endTime = 0;
		this.duration = 0;

		if ( this.input.length ) {

			this.startTime = 100000000;
			this.endTime = -100000000;

			for ( var i = 0; i < this.input.length; i ++ ) {

				this.startTime = Math.min( this.startTime, this.input[ i ] );
				this.endTime = Math.max( this.endTime, this.input[ i ] );

			}

			this.duration = this.endTime - this.startTime;

		}

	};

	Sampler.prototype.getData = function ( type, ndx ) {

		var data;

		if ( type === 'matrix' && this.strideOut === 16 ) {

			data = this.output[ ndx ];

		} else if ( this.strideOut > 1 ) {

			data = [];
			ndx *= this.strideOut;

			for ( var i = 0; i < this.strideOut; ++i ) {

				data[ i ] = this.output[ ndx + i ];

			}

			if ( this.strideOut === 3 ) {

				switch ( type ) {

					case 'rotate':
					case 'translate':

						fixCoords( data, -1 );
						break;

					case 'scale':

						fixCoords( data, 1 );
						break;

				}

			} else if ( this.strideOut === 4 && type === 'matrix' ) {

				fixCoords( data, -1 );

			}

		} else {

			data = this.output[ ndx ];

		}

		return data;

	};

	function Key ( time ) {

		this.targets = [];
		this.time = time;

	};

	Key.prototype.addTarget = function ( fullSid, transform, member, data ) {

		this.targets.push( {
			sid: fullSid,
			member: member,
			transform: transform,
			data: data
		} );

	};

	Key.prototype.apply = function ( opt_sid ) {

		for ( var i = 0; i < this.targets.length; ++i ) {

			var target = this.targets[ i ];

			if ( !opt_sid || target.sid === opt_sid ) {

				target.transform.update( target.data, target.member );

			}

		}

	};

	Key.prototype.getTarget = function ( fullSid ) {

		for ( var i = 0; i < this.targets.length; ++i ) {

			if ( this.targets[ i ].sid === fullSid ) {

				return this.targets[ i ];

			}

		}

		return null;

	};

	Key.prototype.hasTarget = function ( fullSid ) {

		for ( var i = 0; i < this.targets.length; ++i ) {

			if ( this.targets[ i ].sid === fullSid ) {

				return true;

			}

		}

		return false;

	};

	// TODO: Currently only doing linear interpolation. Should support full COLLADA spec.
	Key.prototype.interpolate = function ( nextKey, time ) {

		for ( var i = 0, l = this.targets.length; i < l; i ++ ) {

			var target = this.targets[ i ],
				nextTarget = nextKey.getTarget( target.sid ),
				data;

			if ( target.transform.type !== 'matrix' && nextTarget ) {

				var scale = ( time - this.time ) / ( nextKey.time - this.time ),
					nextData = nextTarget.data,
					prevData = target.data;

				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;

				if ( prevData.length ) {

					data = [];

					for ( var j = 0; j < prevData.length; ++j ) {

						data[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;

					}

				} else {

					data = prevData + ( nextData - prevData ) * scale;

				}

			} else {

				data = target.data;

			}

			target.transform.update( data, target.member );

		}

	};

	// Camera
	function Camera() {

		this.id = "";
		this.name = "";
		this.technique = "";

	};

	Camera.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'optics':

					this.parseOptics( child );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Camera.prototype.parseOptics = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			if ( element.childNodes[ i ].nodeName == 'technique_common' ) {

				var technique = element.childNodes[ i ];

				for ( var j = 0; j < technique.childNodes.length; j ++ ) {

					this.technique = technique.childNodes[ j ].nodeName;

					if ( this.technique == 'perspective' ) {

						var perspective = technique.childNodes[ j ];

						for ( var k = 0; k < perspective.childNodes.length; k ++ ) {

							var param = perspective.childNodes[ k ];

							switch ( param.nodeName ) {

								case 'yfov':
									this.yfov = param.textContent;
									break;
								case 'xfov':
									this.xfov = param.textContent;
									break;
								case 'znear':
									this.znear = param.textContent;
									break;
								case 'zfar':
									this.zfar = param.textContent;
									break;
								case 'aspect_ratio':
									this.aspect_ratio = param.textContent;
									break;

							}

						}

					} else if ( this.technique == 'orthographic' ) {

						var orthographic = technique.childNodes[ j ];

						for ( var k = 0; k < orthographic.childNodes.length; k ++ ) {

							var param = orthographic.childNodes[ k ];

							switch ( param.nodeName ) {

								case 'xmag':
									this.xmag = param.textContent;
									break;
								case 'ymag':
									this.ymag = param.textContent;
									break;
								case 'znear':
									this.znear = param.textContent;
									break;
								case 'zfar':
									this.zfar = param.textContent;
									break;
								case 'aspect_ratio':
									this.aspect_ratio = param.textContent;
									break;

							}

						}

					}

				}

			}

		}

		return this;

	};

	function InstanceCamera() {

		this.url = "";

	};

	InstanceCamera.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');

		return this;

	};

	// Light

	function Light() {

		this.id = "";
		this.name = "";
		this.technique = "";

	};

	Light.prototype.parse = function ( element ) {

		this.id = element.getAttribute( 'id' );
		this.name = element.getAttribute( 'name' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];
			if ( child.nodeType != 1 ) continue;

			switch ( child.nodeName ) {

				case 'technique_common':

					this.parseCommon( child );
					break;

				case 'technique':

					this.parseTechnique( child );
					break;

				default:
					break;

			}

		}

		return this;

	};

	Light.prototype.parseCommon = function ( element ) {

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			switch ( element.childNodes[ i ].nodeName ) {

				case 'directional':
				case 'point':
				case 'spot':
				case 'ambient':

					this.technique = element.childNodes[ i ].nodeName;

					var light = element.childNodes[ i ];

					for ( var j = 0; j < light.childNodes.length; j ++ ) {

						var child = light.childNodes[j];

						switch ( child.nodeName ) {

							case 'color':

								var rgba = _floats( child.textContent );
								this.color = new THREE.Color(0);
								this.color.setRGB( rgba[0], rgba[1], rgba[2] );
								this.color.a = rgba[3];
								break;

							case 'falloff_angle':

								this.falloff_angle = parseFloat( child.textContent );
								break;
						}

					}

			}

		}

		return this;

	};

	Light.prototype.parseTechnique = function ( element ) {

		this.profile = element.getAttribute( 'profile' );

		for ( var i = 0; i < element.childNodes.length; i ++ ) {

			var child = element.childNodes[ i ];

			switch ( child.nodeName ) {

				case 'intensity':

					this.intensity = parseFloat(child.textContent);
					break;

			}

		}

		return this;

	};

	function InstanceLight() {

		this.url = "";

	};

	InstanceLight.prototype.parse = function ( element ) {

		this.url = element.getAttribute('url').replace(/^#/, '');

		return this;

	};

	function _source( element ) {

		var id = element.getAttribute( 'id' );

		if ( sources[ id ] != undefined ) {

			return sources[ id ];

		}

		sources[ id ] = ( new Source(id )).parse( element );
		return sources[ id ];

	};

	function _nsResolver( nsPrefix ) {

		if ( nsPrefix == "dae" ) {

			return "http://www.collada.org/2005/11/COLLADASchema";

		}

		return null;

	};

	function _bools( str ) {

		var raw = _strings( str );
		var data = [];

		for ( var i = 0, l = raw.length; i < l; i ++ ) {

			data.push( (raw[i] == 'true' || raw[i] == '1') ? true : false );

		}

		return data;

	};

	function _floats( str ) {

		var raw = _strings(str);
		var data = [];

		for ( var i = 0, l = raw.length; i < l; i ++ ) {

			data.push( parseFloat( raw[ i ] ) );

		}

		return data;

	};

	function _ints( str ) {

		var raw = _strings( str );
		var data = [];

		for ( var i = 0, l = raw.length; i < l; i ++ ) {

			data.push( parseInt( raw[ i ], 10 ) );

		}

		return data;

	};

	function _strings( str ) {

		return ( str.length > 0 ) ? _trimString( str ).split( /\s+/ ) : [];

	};

	function _trimString( str ) {

		return str.replace( /^\s+/, "" ).replace( /\s+$/, "" );

	};

	function _attr_as_float( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return parseFloat( element.getAttribute( name ) );

		} else {

			return defaultValue;

		}

	};

	function _attr_as_int( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return parseInt( element.getAttribute( name ), 10) ;

		} else {

			return defaultValue;

		}

	};

	function _attr_as_string( element, name, defaultValue ) {

		if ( element.hasAttribute( name ) ) {

			return element.getAttribute( name );

		} else {

			return defaultValue;

		}

	};

	function _format_float( f, num ) {

		if ( f === undefined ) {

			var s = '0.';

			while ( s.length < num + 2 ) {

				s += '0';

			}

			return s;

		}

		num = num || 2;

		var parts = f.toString().split( '.' );
		parts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : "0";

		while( parts[ 1 ].length < num ) {

			parts[ 1 ] += '0';

		}

		return parts.join( '.' );

	};

	function extractDoubleSided( obj, element ) {

		obj.doubleSided = false;

		var node = element.querySelectorAll('extra double_sided')[0];
	
		if ( node ) {

			if ( node && parseInt( node.textContent, 10 ) === 1 ) {

				obj.doubleSided = true;

			}

		}

	};

	// Up axis conversion

	function setUpConversion() {

		if ( !options.convertUpAxis || colladaUp === options.upAxis ) {

			upConversion = null;

		} else {

			switch ( colladaUp ) {

				case 'X':

					upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';
					break;

				case 'Y':

					upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';
					break;

				case 'Z':

					upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';
					break;

			}

		}

	};

	function fixCoords( data, sign ) {

		if ( !options.convertUpAxis || colladaUp === options.upAxis ) {

			return;

		}

		switch ( upConversion ) {

			case 'XtoY':

				var tmp = data[ 0 ];
				data[ 0 ] = sign * data[ 1 ];
				data[ 1 ] = tmp;
				break;

			case 'XtoZ':

				var tmp = data[ 2 ];
				data[ 2 ] = data[ 1 ];
				data[ 1 ] = data[ 0 ];
				data[ 0 ] = tmp;
				break;

			case 'YtoX':

				var tmp = data[ 0 ];
				data[ 0 ] = data[ 1 ];
				data[ 1 ] = sign * tmp;
				break;

			case 'YtoZ':

				var tmp = data[ 1 ];
				data[ 1 ] = sign * data[ 2 ];
				data[ 2 ] = tmp;
				break;

			case 'ZtoX':

				var tmp = data[ 0 ];
				data[ 0 ] = data[ 1 ];
				data[ 1 ] = data[ 2 ];
				data[ 2 ] = tmp;
				break;

			case 'ZtoY':

				var tmp = data[ 1 ];
				data[ 1 ] = data[ 2 ];
				data[ 2 ] = sign * tmp;
				break;

		}

	};

	function getConvertedVec3( data, offset ) {

		var arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];
		fixCoords( arr, -1 );
		return new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );

	};

	function getConvertedMat4( data ) {

		if ( options.convertUpAxis ) {

			// First fix rotation and scale

			// Columns first
			var arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];
			fixCoords( arr, -1 );
			data[ 0 ] = arr[ 0 ];
			data[ 4 ] = arr[ 1 ];
			data[ 8 ] = arr[ 2 ];
			arr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];
			fixCoords( arr, -1 );
			data[ 1 ] = arr[ 0 ];
			data[ 5 ] = arr[ 1 ];
			data[ 9 ] = arr[ 2 ];
			arr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];
			fixCoords( arr, -1 );
			data[ 2 ] = arr[ 0 ];
			data[ 6 ] = arr[ 1 ];
			data[ 10 ] = arr[ 2 ];
			// Rows second
			arr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];
			fixCoords( arr, -1 );
			data[ 0 ] = arr[ 0 ];
			data[ 1 ] = arr[ 1 ];
			data[ 2 ] = arr[ 2 ];
			arr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];
			fixCoords( arr, -1 );
			data[ 4 ] = arr[ 0 ];
			data[ 5 ] = arr[ 1 ];
			data[ 6 ] = arr[ 2 ];
			arr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];
			fixCoords( arr, -1 );
			data[ 8 ] = arr[ 0 ];
			data[ 9 ] = arr[ 1 ];
			data[ 10 ] = arr[ 2 ];

			// Now fix translation
			arr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];
			fixCoords( arr, -1 );
			data[ 3 ] = arr[ 0 ];
			data[ 7 ] = arr[ 1 ];
			data[ 11 ] = arr[ 2 ];

		}

		return new THREE.Matrix4(
			data[0], data[1], data[2], data[3],
			data[4], data[5], data[6], data[7],
			data[8], data[9], data[10], data[11],
			data[12], data[13], data[14], data[15]
			);

	};

	function getConvertedIndex( index ) {

		if ( index > -1 && index < 3 ) {

			var members = ['X', 'Y', 'Z'],
				indices = { X: 0, Y: 1, Z: 2 };

			index = getConvertedMember( members[ index ] );
			index = indices[ index ];

		}

		return index;

	};

	function getConvertedMember( member ) {

		if ( options.convertUpAxis ) {

			switch ( member ) {

				case 'X':

					switch ( upConversion ) {

						case 'XtoY':
						case 'XtoZ':
						case 'YtoX':

							member = 'Y';
							break;

						case 'ZtoX':

							member = 'Z';
							break;

					}

					break;

				case 'Y':

					switch ( upConversion ) {

						case 'XtoY':
						case 'YtoX':
						case 'ZtoX':

							member = 'X';
							break;

						case 'XtoZ':
						case 'YtoZ':
						case 'ZtoY':

							member = 'Z';
							break;

					}

					break;

				case 'Z':

					switch ( upConversion ) {

						case 'XtoZ':

							member = 'X';
							break;

						case 'YtoZ':
						case 'ZtoX':
						case 'ZtoY':

							member = 'Y';
							break;

					}

					break;

			}

		}

		return member;

	};

	return {

		load: load,
		parse: parse,
		setPreferredShading: setPreferredShading,
		applySkin: applySkin,
		geometries : geometries,
		options: options

	};

};
// Copyright (c) 2013 Fabrice Robinet
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/*
    The Abstract Loader has two modes:
        #1: [static] load all the JSON at once [as of now]
        #2: [stream] stream and parse JSON progressively [not yet supported]

    Whatever is the mechanism used to parse the JSON (#1 or #2),
    The loader starts by resolving the paths to binaries and referenced json files (by replace the value of the path property with an absolute path if it was relative).

    In case #1: it is guaranteed to call the concrete loader implementation methods in a order that solves the dependencies between the entries.
    only the nodes requires an extra pass to set up the hirerarchy.
    In case #2: the concrete implementation will have to solve the dependencies. no order is guaranteed.

    When case #1 is used the followed dependency order is:

    scenes -> nodes -> meshes -> materials -> techniques -> shaders
                    -> buffers
                    -> cameras
                    -> lights

    The readers starts with the leafs, i.e:
        shaders, techniques, materials, meshes, buffers, cameras, lights, nodes, scenes

    For each called handle method called the client should return true if the next handle can be call right after returning,
    or false if a callback on client side will notify the loader that the next handle method can be called.

*/
var global = window;
(function (root, factory) {
    if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        factory(module.exports);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function () {
            return factory(root);
        });
    } else {
        // Browser globals
        factory(root);
    }
}(this, function (root) {
    "use strict";

    var categoriesDepsOrder = ["buffers", "bufferViews", "images",  "videos", "samplers", "textures", "shaders", "programs", "techniques", "materials", "accessors", "meshes", "cameras", "lights", "skins", "nodes", "scenes", "animations"];

    var glTFParser = Object.create(Object.prototype, {

        _rootDescription: { value: null, writable: true },

        rootDescription: {
            set: function(value) {
                this._rootDescription = value;
            },
            get: function() {
                return this._rootDescription;
            }
        },

        baseURL: { value: null, writable: true },

        //detect absolute path following the same protocol than window.location
        _isAbsolutePath: {
            value: function(path) {
                var isAbsolutePathRegExp = new RegExp("^"+window.location.protocol, "i");

                return path.match(isAbsolutePathRegExp) ? true : false;
            }
        },

        resolvePathIfNeeded: {
            value: function(path) {
                if (this._isAbsolutePath(path)) {
                    return path;
                }

                return this.baseURL + path;
            }
        },

        _resolvePathsForCategories: {
            value: function(categories) {
                categories.forEach( function(category) {
                    var descriptions = this.json[category];
                    if (descriptions) {
                        var descriptionKeys = Object.keys(descriptions);
                        descriptionKeys.forEach( function(descriptionKey) {
                            var description = descriptions[descriptionKey];
                            description.path = this.resolvePathIfNeeded(description.path);
                        }, this);
                    }
                }, this);
            }
        },

        _json: {
            value: null,
            writable: true
        },

        json: {
            enumerable: true,
            get: function() {
                return this._json;
            },
            set: function(value) {
                if (this._json !== value) {
                    this._json = value;
                    this._resolvePathsForCategories(["buffers", "shaders", "images", "videos"]);
                }
            }
        },

        _path: {
            value: null,
            writable: true
        },

        getEntryDescription: {
            value: function (entryID, entryType) {
                var entries = null;

                var category = entryType;
                entries = this.rootDescription[category];
                if (!entries) {
                    console.log("ERROR:CANNOT find expected category named:"+category);
                    return null;
                }

                return entries ? entries[entryID] : null;
            }
        },

        _stepToNextCategory: {
            value: function() {
                this._state.categoryIndex = this.getNextCategoryIndex(this._state.categoryIndex + 1);
                if (this._state.categoryIndex !== -1) {
                    this._state.categoryState.index = 0;
                    return true;
                }

                return false;
            }
        },

        _stepToNextDescription: {
            enumerable: false,
            value: function() {
                var categoryState = this._state.categoryState;
                var keys = categoryState.keys;
                if (!keys) {
                    console.log("INCONSISTENCY ERROR");
                    return false;
                }

                categoryState.index++;
                categoryState.keys = null;
                if (categoryState.index >= keys.length) {
                    return this._stepToNextCategory();
                }
                return false;
            }
        },

        hasCategory: {
            value: function(category) {
                return this.rootDescription[category] ? true : false;
            }
        },

        _handleState: {
            value: function() {

                var methodForType = {
                    "buffers" : this.handleBuffer,
                    "bufferViews" : this.handleBufferView,
                    "shaders" : this.handleShader,
                    "programs" : this.handleProgram,
                    "techniques" : this.handleTechnique,
                    "materials" : this.handleMaterial,
                    "meshes" : this.handleMesh,
                    "cameras" : this.handleCamera,
                    "lights" : this.handleLight,
                    "nodes" : this.handleNode,
                    "scenes" : this.handleScene,
                    "images" : this.handleImage,
                    "animations" : this.handleAnimation,
                    "accessors" : this.handleAccessor,
                    "skins" : this.handleSkin,
                    "samplers" : this.handleSampler,
                    "textures" : this.handleTexture,
                    "videos" : this.handleVideo

                };

                var success = true;
                while (this._state.categoryIndex !== -1) {
                    var category = categoriesDepsOrder[this._state.categoryIndex];
                    var categoryState = this._state.categoryState;
                    var keys = categoryState.keys;
                    if (!keys) {
                        categoryState.keys = keys = Object.keys(this.rootDescription[category]);
                        if (keys) {
                            if (keys.length == 0) {
                                this._stepToNextDescription();
                                continue;
                            }
                        }
                    }

                    var type = category;
                    var entryID = keys[categoryState.index];
                    var description = this.getEntryDescription(entryID, type);
                    if (!description) {
                        if (this.handleError) {
                            this.handleError("INCONSISTENCY ERROR: no description found for entry "+entryID);
                            success = false;
                            break;
                        }
                    } else {

                        if (methodForType[type]) {
                            if (methodForType[type].call(this, entryID, description, this._state.userInfo) === false) {
                                success = false;
                                break;
                            }
                        }

                        this._stepToNextDescription();
                    }
                }

                if (this.handleLoadCompleted) {
                    this.handleLoadCompleted(success);
                }

            }
        },

        _loadJSONIfNeeded: {
            enumerable: true,
            value: function(callback) {
                var self = this;
                //FIXME: handle error
                if (!this._json)  {
                    var jsonPath = this._path;
                    var i = jsonPath.lastIndexOf("/");
                    this.baseURL = (i !== 0) ? jsonPath.substring(0, i + 1) : '';
                    var jsonfile = new XMLHttpRequest();
                    jsonfile.open("GET", jsonPath, true);
                    jsonfile.addEventListener( 'load', function ( event ) {
                        self.json = JSON.parse(jsonfile.responseText);
                        if (callback) {
                            callback(self.json);
                        }
                    }, false );
                    jsonfile.send(null);
               } else {
                    if (callback) {
                        callback(this.json);
                    }
                }
            }
        },

        /* load JSON and assign it as description to the reader */
        _buildLoader: {
            value: function(callback) {
                var self = this;
                function JSONReady(json) {
                    self.rootDescription = json;
                    if (callback)
                        callback(this);
                }

                this._loadJSONIfNeeded(JSONReady);
            }
        },

        _state: { value: null, writable: true },

        _getEntryType: {
            value: function(entryID) {
                var rootKeys = categoriesDepsOrder;
                for (var i = 0 ;  i < rootKeys.length ; i++) {
                    var rootValues = this.rootDescription[rootKeys[i]];
                    if (rootValues) {
                        return rootKeys[i];
                    }
                }
                return null;
            }
        },

        getNextCategoryIndex: {
            value: function(currentIndex) {
                for (var i = currentIndex ; i < categoriesDepsOrder.length ; i++) {
                    if (this.hasCategory(categoriesDepsOrder[i])) {
                        return i;
                    }
                }

                return -1;
            }
        },

        load: {
            enumerable: true,
            value: function(userInfo, options) {
                var self = this;
                this._buildLoader(function loaderReady(reader) {
                    var startCategory = self.getNextCategoryIndex.call(self,0);
                    if (startCategory !== -1) {
                        self._state = { "userInfo" : userInfo,
                                        "options" : options,
                                        "categoryIndex" : startCategory,
                                        "categoryState" : { "index" : "0" } };
                        self._handleState();
                    }
                });
            }
        },

        initWithPath: {
            value: function(path) {
                this._path = path;
                this._json = null;
                return this;
            }
        },

        //this is meant to be global and common for all instances
        _knownURLs: { writable: true, value: {} },

        //to be invoked by subclass, so that ids can be ensured to not overlap
        loaderContext: {
            value: function() {
                if (typeof this._knownURLs[this._path] === "undefined") {
                    this._knownURLs[this._path] = Object.keys(this._knownURLs).length;
                }
                return "__" + this._knownURLs[this._path];
            }
        },

        initWithJSON: {
            value: function(json, baseURL) {
                this.json = json;
                this.baseURL = baseURL;
                if (!baseURL) {
                    console.log("WARNING: no base URL passed to Reader:initWithJSON");
                }
                return this;
            }
        }

    });

    if(root) {
        root.glTFParser = glTFParser;
    }

    return glTFParser;

}));
/**
 * @author Tony Parisi / http://www.tonyparisi.com/
 */


THREE.glTFLoader = function (showStatus) {
	this.useBufferGeometry = (THREE.glTFLoader.useBufferGeometry !== undefined ) ?
			THREE.glTFLoader.useBufferGeometry : true;
    this.meshesRequested = 0;
    this.meshesLoaded = 0;
    this.pendingMeshes = [];
    this.animationsRequested = 0;
    this.animationsLoaded = 0;
    this.animations = [];
    this.shadersRequested = 0;
    this.shadersLoaded = 0;
    this.shaders = {};
    THREE.Loader.call( this, showStatus );
}

THREE.glTFLoader.prototype = new THREE.Loader();
THREE.glTFLoader.prototype.constructor = THREE.glTFLoader;

THREE.glTFLoader.prototype.load = function( url, callback ) {
	
	var theLoader = this;
	// Utilities

    function RgbArraytoHex(colorArray) {
        if(!colorArray) return 0xFFFFFFFF;
        var r = Math.floor(colorArray[0] * 255),
            g = Math.floor(colorArray[1] * 255),
            b = Math.floor(colorArray[2] * 255),
            a = 255;

        var color = (a << 24) + (r << 16) + (g << 8) + b;

        return color;
    }
    
    function convertAxisAngleToQuaternion(rotations, count)
    {
    	var q = new THREE.Quaternion;
    	var axis = new THREE.Vector3;
    	var euler = new THREE.Vector3;
    	
    	var i;
    	for (i = 0; i < count; i++) {
    		axis.set(rotations[i * 4], rotations[i * 4 + 1],
    				rotations[i * 4 + 2]).normalize();
    		var angle = rotations[i * 4 + 3];
    		q.setFromAxisAngle(axis, angle);
    		rotations[i * 4] = q.x;
    		rotations[i * 4 + 1] = q.y;
    		rotations[i * 4 + 2] = q.z;
    		rotations[i * 4 + 3] = q.w;
    	}
    }

    function componentsPerElementForGLType(glType) {
        switch (glType) {
            case WebGLRenderingContext.FLOAT :
            case WebGLRenderingContext.UNSIGNED_BYTE :
            case WebGLRenderingContext.UNSIGNED_SHORT :
                return 1;
            case WebGLRenderingContext.FLOAT_VEC2 :
                return 2;
            case WebGLRenderingContext.FLOAT_VEC3 :
                return 3;
            case WebGLRenderingContext.FLOAT_VEC4 :
                return 4;
            case WebGLRenderingContext.FLOAT_MAT4 :
                return 16;
            default:
                return null;
        }
    }


    function LoadTexture(src) {
        if(!src) { return null; }
        return THREE.ImageUtils.loadTexture(src);
    }

    // Geometry processing

    var ClassicGeometry = function() {

    	if (theLoader.useBufferGeometry) {
    		this.geometry = new THREE.BufferGeometry;
    	}
    	else {
    		this.geometry = new THREE.Geometry;
    	}
        this.totalAttributes = 0;
        this.loadedAttributes = 0;
        this.indicesLoaded = false;
        this.finished = false;

        this.onload = null;

        this.uvs = null;
        this.indexArray = null;
    };

    ClassicGeometry.prototype.constructor = ClassicGeometry;

    ClassicGeometry.prototype.buildArrayGeometry = function() {

    	// Build indexed mesh
        var geometry = this.geometry;
        var normals = geometry.normals;
        var indexArray = this.indexArray;
        var uvs = this.uvs;
        var a, b, c;
        var i, l;
        var faceNormals = null;
        var faceTexcoords = null;
        
        for(i = 0, l = this.indexArray.length; i < l; i += 3) {
            a = indexArray[i];
            b = indexArray[i+1];
            c = indexArray[i+2];
            if(normals) {
                faceNormals = [normals[a], normals[b], normals[c]];
            }
            geometry.faces.push( new THREE.Face3( a, b, c, faceNormals, null, null ) );
            if(uvs) {
                geometry.faceVertexUvs[0].push([ uvs[a], uvs[b], uvs[c] ]);
            }
        }

        // Allow Three.js to calculate some values for us
        geometry.computeBoundingBox();
        geometry.computeBoundingSphere();
        geometry.computeCentroids();
        geometry.computeFaceNormals();
        if(!normals) {
            geometry.computeVertexNormals();
        }

    }

    ClassicGeometry.prototype.buildBufferGeometry = function() {
        // Build indexed mesh
        var geometry = this.geometry;
        geometry.attributes.index = {
        		itemSize: 1,
        		array : this.indexArray
        };

		var offset = {
				start: 0,
				index: 0,
				count: this.indexArray.length
			};

		geometry.offsets.push( offset );

        geometry.computeBoundingSphere();
    }
    
    ClassicGeometry.prototype.checkFinished = function() {
        if(this.indexArray && this.loadedAttributes === this.totalAttributes) {
        	
        	if (theLoader.useBufferGeometry) {
        		this.buildBufferGeometry();
        	}
        	else {
        		this.buildArrayGeometry();
        	}
        	
            this.finished = true;

            if(this.onload) {
                this.onload();
            }
        }
    };

    // Delegate for processing index buffers
    var IndicesDelegate = function() {};

    IndicesDelegate.prototype.handleError = function(errorCode, info) {
        // FIXME: report error
        console.log("ERROR(IndicesDelegate):"+errorCode+":"+info);
    };

    IndicesDelegate.prototype.convert = function(resource, ctx) {
        return new Uint16Array(resource, 0, ctx.indices.count);
    };

    IndicesDelegate.prototype.resourceAvailable = function(glResource, ctx) {
        var geometry = ctx.geometry;
        geometry.indexArray = glResource;
        geometry.checkFinished();
        return true;
    };

    var indicesDelegate = new IndicesDelegate();

    var IndicesContext = function(indices, geometry) {
        this.indices = indices;
        this.geometry = geometry;
    };
    
    // Delegate for processing vertex attribute buffers
    var VertexAttributeDelegate = function() {};

    VertexAttributeDelegate.prototype.handleError = function(errorCode, info) {
        // FIXME: report error
        console.log("ERROR(VertexAttributeDelegate):"+errorCode+":"+info);
    };

    VertexAttributeDelegate.prototype.convert = function(resource, ctx) {
        return resource;
    };



    VertexAttributeDelegate.prototype.arrayResourceAvailable = function(glResource, ctx) {
        var geom = ctx.geometry;
        var attribute = ctx.attribute;
        var semantic = ctx.semantic;
        var floatArray;
        var i, l;
        //FIXME: Float32 is assumed here, but should be checked.

        if(semantic == "POSITION") {
            // TODO: Should be easy to take strides into account here
            floatArray = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
            for(i = 0, l = floatArray.length; i < l; i += 3) {
                geom.geometry.vertices.push( new THREE.Vector3( floatArray[i], floatArray[i+1], floatArray[i+2] ) );
            }
        } else if(semantic == "NORMAL") {
            geom.geometry.normals = [];
            floatArray = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
            for(i = 0, l = floatArray.length; i < l; i += 3) {
                geom.geometry.normals.push( new THREE.Vector3( floatArray[i], floatArray[i+1], floatArray[i+2] ) );
            }
        } else if ((semantic == "TEXCOORD_0") || (semantic == "TEXCOORD" )) {
        	geom.uvs = [];
            floatArray = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
            for(i = 0, l = floatArray.length; i < l; i += 2) {
                geom.uvs.push( new THREE.Vector2( floatArray[i], 1.0 - floatArray[i+1] ) );
            }
        }
        else if (semantic == "WEIGHT") {
        	nComponents = componentsPerElementForGLType(attribute.type);
            floatArray = new Float32Array(glResource, 0, attribute.count * nComponents);
            for(i = 0, l = floatArray.length; i < l; i += 4) {
            	geom.geometry.skinWeights.push( new THREE.Vector4( floatArray[i], floatArray[i+1], floatArray[i+2], floatArray[i+3] ) );
            }
        }
        else if (semantic == "JOINT") {
        	nComponents = componentsPerElementForGLType(attribute.type);
            floatArray = new Float32Array(glResource, 0, attribute.count * nComponents);
            for(i = 0, l = floatArray.length; i < l; i += 4) {
            	geom.geometry.skinIndices.push( new THREE.Vector4( floatArray[i], floatArray[i+1], floatArray[i+2], floatArray[i+3] ) );
            }
        }
    }
    
    VertexAttributeDelegate.prototype.bufferResourceAvailable = function(glResource, ctx) {
        var geom = ctx.geometry;
        var attribute = ctx.attribute;
        var semantic = ctx.semantic;
        var floatArray;
        var i, l;
        var nComponents;
        //FIXME: Float32 is assumed here, but should be checked.

        if(semantic == "POSITION") {
            // TODO: Should be easy to take strides into account here
            floatArray = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
            geom.geometry.attributes.position = {
            		itemSize: 3,
            		array : floatArray
            };
        } else if(semantic == "NORMAL") {
            floatArray = new Float32Array(glResource, 0, attribute.count * componentsPerElementForGLType(attribute.type));
            geom.geometry.attributes.normal = {
            		itemSize: 3,
            		array : floatArray
            };
        } else if ((semantic == "TEXCOORD_0") || (semantic == "TEXCOORD" )) {
        	
        	nComponents = componentsPerElementForGLType(attribute.type);
            floatArray = new Float32Array(glResource, 0, attribute.count * nComponents);
            // N.B.: flip Y value... should we just set texture.flipY everywhere?
            for (i = 0; i < floatArray.length / 2; i++) {
            	floatArray[i*2+1] = 1.0 - floatArray[i*2+1];
            }
            geom.geometry.attributes.uv = {
            		itemSize: nComponents,
            		array : floatArray
            };
        }
        else if (semantic == "WEIGHT") {
        	nComponents = componentsPerElementForGLType(attribute.type);
            floatArray = new Float32Array(glResource, 0, attribute.count * nComponents);
            geom.geometry.attributes.skinWeight = {
            		itemSize: nComponents,
            		array : floatArray
            };        	
        }
        else if (semantic == "JOINT") {
        	nComponents = componentsPerElementForGLType(attribute.type);
            floatArray = new Float32Array(glResource, 0, attribute.count * nComponents);
            geom.geometry.attributes.skinIndex = {
            		itemSize: nComponents,
            		array : floatArray
            };        	
        }
    }
    
    VertexAttributeDelegate.prototype.resourceAvailable = function(glResource, ctx) {
    	if (theLoader.useBufferGeometry) {
    		this.bufferResourceAvailable(glResource, ctx);
    	}
    	else {
    		this.arrayResourceAvailable(glResource, ctx);
    	}
    	
        var geom = ctx.geometry;
        geom.loadedAttributes++;
        geom.checkFinished();
        return true;
    };

    var vertexAttributeDelegate = new VertexAttributeDelegate();

    var VertexAttributeContext = function(attribute, semantic, geometry) {
        this.attribute = attribute;
        this.semantic = semantic;
        this.geometry = geometry;
    };

    var Mesh = function() {
        this.primitives = [];
        this.materialsPending = [];
        this.loadedGeometry = 0;
        this.onCompleteCallbacks = [];
    };

    Mesh.prototype.addPrimitive = function(geometry, material) {
        
    	var self = this;
        geometry.onload = function() {
            self.loadedGeometry++;
            self.checkComplete();
        };
        
        this.primitives.push({
            geometry: geometry,
            material: material,
            mesh: null
        });
    };

    Mesh.prototype.onComplete = function(callback) {
        this.onCompleteCallbacks.push(callback);
        this.checkComplete();
    };

    Mesh.prototype.checkComplete = function() {
        var self = this;
        if(this.onCompleteCallbacks.length && this.primitives.length == this.loadedGeometry) {
            this.onCompleteCallbacks.forEach(function(callback) {
                callback(self);
            });
            this.onCompleteCallbacks = [];
        }
    };

    Mesh.prototype.attachToNode = function(threeNode) {
        // Assumes that the geometry is complete
        this.primitives.forEach(function(primitive) {
            /*if(!primitive.mesh) {
                primitive.mesh = new THREE.Mesh(primitive.geometry, primitive.material);
            }*/
        	var material = primitive.material;
        	if (!(material instanceof THREE.Material)) {
        		material = theLoader.createShaderMaterial(material);
        	}

        	var threeMesh = new THREE.Mesh(primitive.geometry.geometry, material);
            threeMesh.castShadow = true;
            threeNode.add(threeMesh);
        });
    };

    // Delayed-loaded material
    var Material = function(params) {
    	this.params = params;
    };
    
    // Delegate for processing animation parameter buffers
    var AnimationParameterDelegate = function() {};

    AnimationParameterDelegate.prototype.handleError = function(errorCode, info) {
        // FIXME: report error
        console.log("ERROR(AnimationParameterDelegate):"+errorCode+":"+info);
    };

    AnimationParameterDelegate.prototype.convert = function(resource, ctx) {
    	var parameter = ctx.parameter;

    	var glResource = null;
    	switch (parameter.type) {
	        case WebGLRenderingContext.FLOAT :
	        case WebGLRenderingContext.FLOAT_VEC2 :
	        case WebGLRenderingContext.FLOAT_VEC3 :
	        case WebGLRenderingContext.FLOAT_VEC4 :
	        	glResource = new Float32Array(resource, 0, parameter.count * componentsPerElementForGLType(parameter.type));
	        	break;
	        default:
	        	break;
    	}
    	
        return glResource;
    };

    AnimationParameterDelegate.prototype.resourceAvailable = function(glResource, ctx) {
    	var animation = ctx.animation;
    	var parameter = ctx.parameter;
    	parameter.data = glResource;
    	animation.handleParameterLoaded(parameter);
        return true;
    };

    var animationParameterDelegate = new AnimationParameterDelegate();

    var AnimationParameterContext = function(parameter, animation) {
        this.parameter = parameter;
        this.animation = animation;
    };

    // Animations
    var Animation = function() {

    	// create Three.js keyframe here
        this.totalParameters = 0;
        this.loadedParameters = 0;
        this.parameters = {};
        this.finishedLoading = false;
        this.onload = null;

    };

    Animation.prototype.constructor = Animation;

    Animation.prototype.handleParameterLoaded = function(parameter) {
    	this.parameters[parameter.name] = parameter;
    	this.loadedParameters++;
    	this.checkFinished();
    };
    
    Animation.prototype.checkFinished = function() {
        if(this.loadedParameters === this.totalParameters) {
            // Build animation
            this.finishedLoading = true;

            if (this.onload) {
                this.onload();
            }
        }
    };
    
    // Delegate for processing inverse bind matrices buffer
    var InverseBindMatricesDelegate = function() {};

    InverseBindMatricesDelegate.prototype.handleError = function(errorCode, info) {
        // FIXME: report error
        console.log("ERROR(InverseBindMatricesDelegate):"+errorCode+":"+info);
    };

    InverseBindMatricesDelegate.prototype.convert = function(resource, ctx) {
    	var parameter = ctx.parameter;

    	var glResource = null;
    	switch (parameter.type) {
	        case WebGLRenderingContext.FLOAT_MAT4 :
	        	glResource = new Float32Array(resource, 0, parameter.count * componentsPerElementForGLType(parameter.type));
	        	break;
	        default:
	        	break;
    	}
    	
        return glResource;
    };

    InverseBindMatricesDelegate.prototype.resourceAvailable = function(glResource, ctx) {
    	var skin = ctx.skin;
    	skin.inverseBindMatrices = glResource;
        return true;
    };

    var inverseBindMatricesDelegate = new InverseBindMatricesDelegate();

    var InverseBindMatricesContext = function(param, skin) {
    	this.parameter = param;
        this.skin = skin;
    };

    // Delegate for processing shaders from external files
    var ShaderDelegate = function() {};

    ShaderDelegate.prototype.handleError = function(errorCode, info) {
        // FIXME: report error
        console.log("ERROR(ShaderDelegate):"+errorCode+":"+info);
    };

    ShaderDelegate.prototype.convert = function(resource, ctx) {
    	return resource; 
    }
    
    ShaderDelegate.prototype.resourceAvailable = function(data, ctx) {
        theLoader.shadersLoaded++;
        theLoader.shaders[ctx.id] = data;
        return true;
    };

    var shaderDelegate = new ShaderDelegate();

    var ShaderContext = function(id, path) {
    	this.id = id;
    	this.path = path;
    };
    
    // Resource management

    var ResourceEntry = function(entryID, object, description) {
        this.entryID = entryID;
        this.object = object;
        this.description = description;
    };

    var Resources = function() {
        this._entries = {};
    };

    Resources.prototype.setEntry = function(entryID, object, description) {
        if (!entryID) {
            console.error("No EntryID provided, cannot store", description);
            return;
        }

        if (this._entries[entryID]) {
            console.warn("entry["+entryID+"] is being overwritten");
        }
    
        this._entries[entryID] = new ResourceEntry(entryID, object, description );
    };
    
    Resources.prototype.getEntry = function(entryID) {
        return this._entries[entryID];
    };

    Resources.prototype.clearEntries = function() {
        this._entries = {};
    };

    var LoadDelegate = function() {
    }
    
    LoadDelegate.prototype.loadCompleted = function(callback, obj) {
    	callback.call(Window, obj);
    }
    
    // Loader

    var ThreeGLTFLoader = Object.create(glTFParser, {

        load: {
            enumerable: true,
            value: function(userInfo, options) {
                this.resources = new Resources();
                this.cameras = [];
                this.lights = [];
                this.animations = [];
                this.joints = {};
                this.skeltons = {};
                this.loaderUtils = THREE.GLTFLoaderUtils();
                glTFParser.load.call(this, userInfo, options);
            }
        },

        cameras: {
        	enumerable: true,
        	writable: true,
        	value : []
        },

        lights: {
        	enumerable: true,
        	writable: true,
        	value : []
        },
        
        animations: {
        	enumerable: true,
        	writable: true,
        	value : []
        },
        
        // Implement WebGLTFLoader handlers

        handleBuffer: {
            value: function(entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);
                description.type = "ArrayBuffer";
                return true;
            }
        },

        handleBufferView: {
            value: function(entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);

                var buffer =  this.resources.getEntry(description.buffer);
                description.type = "ArrayBufferView";

                var bufferViewEntry = this.resources.getEntry(entryID);
                bufferViewEntry.buffer = buffer;
                return true;
            }
        },

        handleShader: {
            value: function(entryID, description, userInfo) {
        		this.resources.setEntry(entryID, null, description);
        		var shaderRequest = {
        				id : entryID,
        				path : description.path,
        		};

                var shaderContext = new ShaderContext(entryID, description.path);

//                theLoader.shadersRequested++;
//        		this.loaderUtils.getFile(shaderRequest, shaderDelegate, shaderContext);
        		
                return true;
            }
        },

        handleProgram: {
            value: function(entryID, description, userInfo) {
        		this.resources.setEntry(entryID, null, description);
                return true;
            }
        },

        handleTechnique: {
            value: function(entryID, description, userInfo) {
        		this.resources.setEntry(entryID, null, description);
                return true;
            }
        },

        createShaderMaterial : {
        	value: function(material) {
        		
        		var fragmentShader = theLoader.shaders[material.params.fragmentShader];
        		if (!fragmentShader) {
                    console.log("ERROR: Missing fragment shader definition:", material.params.fragmentShader);
            		return new THREE.MeshPhongMaterial;
        		}
        		
        		var vertexShader = theLoader.shaders[material.params.vertexShader];
        		if (!fragmentShader) {
                    console.log("ERROR: Missing vertex shader definition:", material.params.vertexShader);
            		return new THREE.MeshPhongMaterial;
        		}
        		
        		var uniforms = {};
        		var shaderMaterial = new THREE.ShaderMaterial( {

        			fragmentShader: fragmentShader,
        			vertexShader: vertexShader,
        			uniforms: uniforms,

        		} );

        		return new THREE.MeshPhongMaterial(material.params);
        	}
        },
        
        createShaderParams : {
        	value: function(materialId, values, params, instanceProgram) {
				var program = this.resources.getEntry(instanceProgram.program);
				
				if (program) {
					params.fragmentShader = program.description.fragmentShader;
					params.vertexShader = program.description.vertexShader;
					params.attributes = instanceProgram.attributes;
					params.uniforms = instanceProgram.uniforms;
				}
        	}
        },
        
        threeJSMaterialType : {
            value: function(materialId, technique, values, params) {
        	
        		var materialType = THREE.MeshPhongMaterial;
        		var defaultPass = null;
        		if (technique && technique.description && technique.description.passes)
        			defaultPass = technique.description.passes.defaultPass;
        		
        		if (defaultPass) {
        			if (defaultPass.details && defaultPass.details.commonProfile) {
	            		var profile = technique.description.passes.defaultPass.details.commonProfile;
	            		if (profile)
	            		{
		            		switch (profile.lightingModel)
		            		{
		            			case 'Blinn' :
		            			case 'Phong' :
		            				materialType = THREE.MeshPhongMaterial;
		            				break;
	
		            			case 'Lambert' :
		            				materialType = THREE.MeshLambertMaterial;
		            				break;
		            				
		            			default :
		            				materialType = THREE.MeshBasicMaterial;
		            				break;
		            		}
		            		
		            		if (profile.extras && profile.extras.doubleSided)
		            		{
		            			params.side = THREE.DoubleSide;
		            		}
	            		}
        			}
        			else if (defaultPass.instanceProgram) {
        				
        				var instanceProgram = defaultPass.instanceProgram;

    					this.createShaderParams(materialId, values, params, instanceProgram);
    					
    					var loadshaders = true;
    					
    					if (loadshaders) {
    						materialType = Material;
    					}
        			}
        		}
        		
                var texturePath = null;
                var textureParams = null;
                var diffuse = values.diffuse;
                if (diffuse)
                {
                	var texture = diffuse;
                    if (texture) {
                        var textureEntry = this.resources.getEntry(texture);
                        if (textureEntry) {
                        	{
                        		var imageEntry = this.resources.getEntry(textureEntry.description.source);
                        		if (imageEntry) {
                        			texturePath = imageEntry.description.path;
                        		}
                        		
                        		var samplerEntry = this.resources.getEntry(textureEntry.description.sampler);
                        		if (samplerEntry) {
                        			textureParams = samplerEntry.description;
                        		}
                        	}
                        }
                    }                    
                }

                var texture = LoadTexture(texturePath);
                if (texture && textureParams) {
                	
                	if (textureParams.wrapS == WebGLRenderingContext.REPEAT)
                		texture.wrapS = THREE.RepeatWrapping;

                	if (textureParams.wrapT == WebGLRenderingContext.REPEAT)
                		texture.wrapT = THREE.RepeatWrapping;
                	
                	if (textureParams.magFilter == WebGLRenderingContext.LINEAR)
                		texture.magFilter = THREE.LinearFilter;

//                	if (textureParams.minFilter == "LINEAR")
//               		texture.minFilter = THREE.LinearFilter;
                	
                    params.map = texture;
                }

                var envMapPath = null;
                var envMapParams = null;
                var reflective = values.reflective;
                if (reflective)
                {
                	var texture = reflective;
                    if (texture) {
                        var textureEntry = this.resources.getEntry(texture);
                        if (textureEntry) {
                        	{
                        		var imageEntry = this.resources.getEntry(textureEntry.description.source);
                        		if (imageEntry) {
                        			envMapPath = imageEntry.description.path;
                        		}
                        		
                        		var samplerEntry = this.resources.getEntry(textureEntry.description.sampler);
                        		if (samplerEntry) {
                        			envMapParams = samplerEntry.description;
                        		}
                        	}
                        }
                    }                    
                }

                var texture = LoadTexture(envMapPath);
                if (texture && envMapParams) {
                	
                	if (envMapParams.wrapS == WebGLRenderingContext.REPEAT)
                		texture.wrapS = THREE.RepeatWrapping;

                	if (envMapParams.wrapT == WebGLRenderingContext.REPEAT)
                		texture.wrapT = THREE.RepeatWrapping;
                	
                	if (envMapParams.magFilter == WebGLRenderingContext.LINEAR)
                		texture.magFilter = THREE.LinearFilter;

//                	if (envMapParams.minFilter == WebGLRenderingContext.LINEAR)
//               		texture.minFilter = THREE.LinearFilter;
                	
                    params.envMap = texture;
                }
                
                var shininess = values.shininesss || values.shininess; // N.B.: typo in converter!
                if (shininess)
                {
                	shininess = shininess;
                }
                
                var diffuseColor = !texturePath ? diffuse : null;
                var opacity = 1.0;
                if (values.hasOwnProperty("transparency"))
                {
                	var USE_A_ONE = true; // for now, hack because file format isn't telling us
                	opacity =  USE_A_ONE ? values.transparency : (1.0 - values.transparency);
                }
                
                // if (diffuseColor) diffuseColor = [0, 1, 0];
                                    
                params.color = RgbArraytoHex(diffuseColor);
                params.opacity = opacity;
                params.transparent = opacity < 1.0;
                // hack hack hack
                if (texturePath && texturePath.toLowerCase().indexOf(".png") != -1)
                	params.transparent = true;
                
                if (!(shininess === undefined))
                {
                	params.shininess = shininess;
                }
                
                if (!(values.ambient === undefined) && !(typeof(values.ambient) == 'string'))
                {
                	params.ambient = RgbArraytoHex(values.ambient);
                }

                if (!(values.emission === undefined))
                {
                	params.emissive = RgbArraytoHex(values.emission);
                }
                
                if (!(values.specular === undefined))
                {
                	params.specular = RgbArraytoHex(values.specular);
                }

        		return materialType;
        		
        	}
        },
        
        handleMaterial: {
            value: function(entryID, description, userInfo) {
                //this should be rewritten using the meta datas that actually create the shader.
                //here we will infer what needs to be pass to Three.js by looking inside the technique parameters.
                var technique = this.resources.getEntry(description.instanceTechnique.technique);
                var materialParams = {};
                var values = description.instanceTechnique.values;
                
                var materialType = this.threeJSMaterialType(entryID, technique, values, materialParams);

                var material = new materialType(materialParams);
                
                this.resources.setEntry(entryID, material, description);

                return true;
            }
        },

        handleMesh: {
            value: function(entryID, description, userInfo) {
                var mesh = new Mesh();
                this.resources.setEntry(entryID, mesh, description);
                var primitivesDescription = description.primitives;
                if (!primitivesDescription) {
                    //FIXME: not implemented in delegate
                    console.log("MISSING_PRIMITIVES for mesh:"+ entryID);
                    return false;
                }

                for (var i = 0 ; i < primitivesDescription.length ; i++) {
                    var primitiveDescription = primitivesDescription[i];
                    
                    if (primitiveDescription.primitive === WebGLRenderingContext.TRIANGLES) {

                        var geometry = new ClassicGeometry();
                        var materialEntry = this.resources.getEntry(primitiveDescription.material);

                        mesh.addPrimitive(geometry, materialEntry.object);

                        var indices = this.resources.getEntry(primitiveDescription.indices);
                        var bufferEntry = this.resources.getEntry(indices.description.bufferView);
                        var indicesObject = {
                        		bufferView : bufferEntry,
                        		byteOffset : indices.description.byteOffset,
                        		count : indices.description.count,
                        		id : indices.entryID,
                        		type : indices.description.type
                        };
                        
                        var indicesContext = new IndicesContext(indicesObject, geometry);
                        var alreadyProcessedIndices = this.loaderUtils.getBuffer(indicesObject, indicesDelegate, indicesContext);
                        /*if(alreadyProcessedIndices) {
                            indicesDelegate.resourceAvailable(alreadyProcessedIndices, indicesContext);
                        }*/

                        // Load Vertex Attributes
                        var allAttributes = Object.keys(primitiveDescription.attributes);
                        allAttributes.forEach( function(semantic) {
                            geometry.totalAttributes++;

                            var attribute;
                            var attributeID = primitiveDescription.attributes[semantic];
                            var attributeEntry = this.resources.getEntry(attributeID);
                            if (!attributeEntry) {
                                //let's just use an anonymous object for the attribute
                                attribute = description.attributes[attributeID];
                                attribute.id = attributeID;
                                this.resources.setEntry(attributeID, attribute, attribute);
            
                                var bufferEntry = this.resources.getEntry(attribute.bufferView);
                                attributeEntry = this.resources.getEntry(attributeID);

                            } else {
                                attribute = attributeEntry.object;
                                attribute.id = attributeID;
                                var bufferEntry = this.resources.getEntry(attribute.bufferView);
                            }

                            var attributeObject = {
                            		bufferView : bufferEntry,
                            		byteOffset : attribute.byteOffset,
                            		byteStride : attribute.byteStride,
                            		count : attribute.count,
                            		max : attribute.max,
                            		min : attribute.min,
                            		type : attribute.type,
                            		id : attributeID             
                            };
                            
                            var attribContext = new VertexAttributeContext(attributeObject, semantic, geometry);

                            var alreadyProcessedAttribute = this.loaderUtils.getBuffer(attributeObject, vertexAttributeDelegate, attribContext);
                            /*if(alreadyProcessedAttribute) {
                                vertexAttributeDelegate.resourceAvailable(alreadyProcessedAttribute, attribContext);
                            }*/
                        }, this);
                    }
                }
                return true;
            }
        },

        handleCamera: {
            value: function(entryID, description, userInfo) {
                var camera;
                if (description.type == "perspective")
                {
            		var znear = description.perspective.znear;
            		var zfar = description.perspective.zfar;
                	var yfov = description.perspective.yfov;                	
                	var xfov = description.perspective.xfov;
            		var aspect_ratio = description.perspective.aspect_ratio;

            		if (!aspect_ratio)
            			aspect_ratio = 1; 
            		
                	if (yfov === undefined)
                	{
                		if (xfov)
                		{
                			// According to COLLADA spec...
                			// aspect_ratio = xfov / yfov
                			yfov = xfov / aspect_ratio;
                		}
                		
                	}
                	
                	if (yfov)
                	{
                		camera = new THREE.PerspectiveCamera(yfov, aspect_ratio, znear, zfar);
                	}
                }
                else
                {
    				camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, znear, zfar );
                }
                
                if (camera)
                {
                	this.resources.setEntry(entryID, camera, description);
                }
                
                return true;
            }
        },

        handleLight: {
            value: function(entryID, description, userInfo) {

        		var light = null;
        		var type = description.type;
        		if (type && description[type])
        		{
        			var lparams = description[type];
            		var color = RgbArraytoHex(lparams.color);
            		
            		switch (type) {
            			case "directional" :
            				light = new THREE.DirectionalLight(color);
    						light.position.set(0, 0, 1);
            			break;
            			
            			case "point" :
            				light = new THREE.PointLight(color);
            			break;
            			
            			case "spot " :
            				light = new THREE.SpotLight(color);
    						light.position.set(0, 0, 1);
            			break;
            			
            			case "ambient" : 
            				light = new THREE.AmbientLight(color);
            			break;
            		}
        		}

        		if (light)
        		{
                	this.resources.setEntry(entryID, light, description);	
        		}
        		
        		return true;
            }
        },

        addPendingMesh: {
            value: function(mesh, threeNode) {
        		theLoader.pendingMeshes.push({
        			mesh: mesh,
        			node: threeNode
        		});
        	}
        },
        
        handleNode: {
            value: function(entryID, description, userInfo) {

        		var threeNode = null;
	            if (description.jointId) {
	                threeNode = new THREE.Bone();
	                threeNode.jointId = description.jointId;
	                this.joints[description.jointId] = entryID;
	            }
	            else {
	                threeNode = new THREE.Object3D();
	            }
	            
                threeNode.name = description.name;
                
                this.resources.setEntry(entryID, threeNode, description);

                var m = description.matrix;
                if(m) {
                    threeNode.matrixAutoUpdate = false;
                    threeNode.applyMatrix(new THREE.Matrix4(
                        m[0],  m[4],  m[8],  m[12],
                        m[1],  m[5],  m[9],  m[13],
                        m[2],  m[6],  m[10], m[14],
                        m[3],  m[7],  m[11], m[15]
                    ));                    
                }
                else {
                	var t = description.translation;
                	var r = description.rotation;
                	var s = description.scale;
                	
                	var position = t ? new THREE.Vector3(t[0], t[1], t[2]) :
                		new THREE.Vector3;
                	if (r) {
                		convertAxisAngleToQuaternion(r, 1);
                	}
                	var rotation = r ? new THREE.Quaternion(r[0], r[1], r[2], r[3]) :
                		new THREE.Quaternion;
                	var scale = s ? new THREE.Vector3(s[0], s[1], s[2]) :
                		new THREE.Vector3;
                	
                	var matrix = new THREE.Matrix4;
                	matrix.compose(position, rotation, scale);
                    threeNode.matrixAutoUpdate = false;
                    threeNode.applyMatrix(matrix);                    
                }

                var self = this;
                
                // Iterate through all node meshes and attach the appropriate objects
                //FIXME: decision needs to be made between these 2 ways, probably meshes will be discarded.
                var meshEntry;
                if (description.mesh) {
                    meshEntry = this.resources.getEntry(description.mesh);
                    theLoader.meshesRequested++;
                    meshEntry.object.onComplete(function(mesh) {
                    	self.addPendingMesh(mesh, threeNode);
                        theLoader.meshesLoaded++;
                        theLoader.checkComplete();
                    });
                }

                if (description.meshes) {
                    description.meshes.forEach( function(meshID) {
                        meshEntry = this.resources.getEntry(meshID);
                        theLoader.meshesRequested++;
                        meshEntry.object.onComplete(function(mesh) {
                        	self.addPendingMesh(mesh, threeNode);
                            theLoader.meshesLoaded++;
                            theLoader.checkComplete();
                        });
                    }, this);
                }

                if (description.instanceSkin) {

                	var skinEntry =  this.resources.getEntry(description.instanceSkin.skin);
                	
                	if (skinEntry) {

                		var skin = skinEntry.object;
                		description.instanceSkin.skin = skin;
                        threeNode.instanceSkin = description.instanceSkin;

                		var sources = description.instanceSkin.sources;
                		skin.meshes = [];
                        sources.forEach( function(meshID) {
                            meshEntry = this.resources.getEntry(meshID);
                            theLoader.meshesRequested++;
                            meshEntry.object.onComplete(function(mesh) {
                            	
                            	skin.meshes.push(mesh);
                                theLoader.meshesLoaded++;
                                theLoader.checkComplete();
                            });
                        }, this);
                        
                	}
                }
                                
                if (description.camera) {
                    var cameraEntry = this.resources.getEntry(description.camera);
                    if (cameraEntry) {
                    	threeNode.add(cameraEntry.object);
                    	this.cameras.push(cameraEntry.object);
                    }
                }

                if (description.light) {
                    var lightEntry = this.resources.getEntry(description.light);
                    if (lightEntry) {
                    	threeNode.add(lightEntry.object);
                    	this.lights.push(lightEntry.object);
                    }
                }
                
                return true;
            }
        },
        
        buildNodeHirerachy: {
            value: function(nodeEntryId, parentThreeNode) {
                var nodeEntry = this.resources.getEntry(nodeEntryId);
                var threeNode = nodeEntry.object;
                parentThreeNode.add(threeNode);

                var children = nodeEntry.description.children;
                if (children) {
                    children.forEach( function(childID) {
                        this.buildNodeHirerachy(childID, threeNode);
                    }, this);
                }

                return threeNode;
            }
        },

        buildSkin: {
            value: function(node) {
        	
                var skin = node.instanceSkin.skin;
                if (skin) {
                    node.instanceSkin.skeletons.forEach(function(skeleton) {
                        var nodeEntry = this.resources.getEntry(skeleton);
                        if (nodeEntry) {

                        	var rootSkeleton = nodeEntry.object;

                            var dobones = true;

                            var i, len = skin.meshes.length;
                            for (i = 0; i < len; i++) {
                            	var mesh = skin.meshes[i];
                            	var threeMesh = null;
                                mesh.primitives.forEach(function(primitive) {

                                	var material = primitive.material;
                                	if (!(material instanceof THREE.Material)) {
                                		material = this.createShaderMaterial(material);
                                	}

                                	threeMesh = new THREE.SkinnedMesh(primitive.geometry.geometry, material, false);
                            		threeMesh.add(rootSkeleton);
                                	
                                    var geometry = primitive.geometry.geometry;
                                    var j;
                                    if (geometry.vertices) {
	                            		for ( j = 0; j < geometry.vertices.length; j ++ ) {
	                            			geometry.vertices[j].applyMatrix4( skin.bindShapeMatrix );	
	                            		}
                                    }
                                    else if (geometry.attributes.position) {
                                    	var a = geometry.attributes.position.array;
                                    	var v = new THREE.Vector3;
	                            		for ( j = 0; j < a.length / 3; j++ ) {
	                            			v.set(a[j * 3], a[j * 3 + 1], a[j * 3 + 2]);
	                            			v.applyMatrix4( skin.bindShapeMatrix );
	                            			a[j * 3] = v.x;
	                            			a[j * 3 + 1] = v.y;
	                            			a[j * 3 + 2] = v.z;
	                            		}
                                    }

                                    if (threeMesh && dobones) {

                                    	material.skinning = true;
        	                            
                                    	threeMesh.boneInverses = [];
        	                            var jointsIds = skin.jointsIds;
        	                            var joints = [];
        	                            var i, len = jointsIds.length;
        	                            for (i = 0; i < len; i++) {
        	                            	var jointId = jointsIds[i];
        	                                var nodeForJoint = this.joints[jointId];
        	                                var joint = this.resources.getEntry(nodeForJoint).object;
        	                                if (joint) {
        	                                	
        	                                	joint.skin = threeMesh;
        	                                    joints.push(joint);
        	                                    threeMesh.bones.push(joint);
        	                                    
        	                                    var m = skin.inverseBindMatrices;
        	                    	            var mat = new THREE.Matrix4(
        	                                            m[i * 16 + 0],  m[i * 16 + 4],  m[i * 16 + 8],  m[i * 16 + 12],
        	                                            m[i * 16 + 1],  m[i * 16 + 5],  m[i * 16 + 9],  m[i * 16 + 13],
        	                                            m[i * 16 + 2],  m[i * 16 + 6],  m[i * 16 + 10], m[i * 16 + 14],
        	                                            m[i * 16 + 3],  m[i * 16 + 7],  m[i * 16 + 11], m[i * 16 + 15]
        	                                        );
        	                                    threeMesh.boneInverses.push(mat);
        	                                    threeMesh.pose();
        	                                    
        	                                } else {
        	                                    console.log("WARNING: jointId:"+jointId+" cannot be found in skeleton:"+skeleton);
        	                                }
        	                            }
                                    }
                                    
                                    if (threeMesh) {
                                    	threeMesh.castShadow = true;
                                    	node.add(threeMesh);
                                    }
                                    
                                }, this);                            	
                            }
                            
                        }

                    
                    }, this);
                    
                }
            }
        },
         
        buildSkins: {
            value: function(node) {

        		if (node.instanceSkin)
        			this.buildSkin(node);
        		
                var children = node.children;
                if (children) {
                    children.forEach( function(child) {
                        this.buildSkins(child);
                    }, this);
                }
            }
        },
        
        createMeshAnimations : {
        	value : function(root) {
        			this.buildSkins(root);
        		}
        },        

        handleScene: {
            value: function(entryID, description, userInfo) {

                if (!description.nodes) {
                    console.log("ERROR: invalid file required nodes property is missing from scene");
                    return false;
                }

                description.nodes.forEach( function(nodeUID) {
                    this.buildNodeHirerachy(nodeUID, userInfo.rootObj);
                }, this);

                if (this.delegate) {
                    this.delegate.loadCompleted(userInfo.callback, userInfo.rootObj);
                }

                return true;
            }
        },

        handleImage: {
            value: function(entryID, description, userInfo) {
                this.resources.setEntry(entryID, null, description);
                return true;
            }
        },
        
        addNodeAnimationChannel : {
        	value : function(name, channel, interp) {
        		if (!this.nodeAnimationChannels)
        			this.nodeAnimationChannels = {};
        		
        		if (!this.nodeAnimationChannels[name]) {
        			this.nodeAnimationChannels[name] = [];
        		}
        		
        		this.nodeAnimationChannels[name].push(interp);
        	},
        },
        
        createAnimations : {
        	value : function() {
        		for (var name in this.nodeAnimationChannels) {
        			var nodeAnimationChannels = this.nodeAnimationChannels[name];
        			var i, len = nodeAnimationChannels.length;
        			//console.log(" animation channels for node " + name);
        			//for (i = 0; i < len; i++) {
        			//	console.log(nodeAnimationChannels[i]);
        			//}
	            	var anim = new THREE.glTFAnimation(nodeAnimationChannels);
	            	anim.name = "animation_" + name;
	            	this.animations.push(anim);        				
        		}
        	}
        },
        
        buildAnimation: {
        	value : function(animation) {
        	
        		var interps = [];
	            var i, len = animation.channels.length;
	            for (i = 0; i < len; i++) {
	            	
	            	var channel = animation.channels[i];
	            	var sampler = animation.samplers[channel.sampler];
	            	if (sampler) {
	
	            		var input = animation.parameters[sampler.input];
	            		if (input && input.data) {
	            			
	            			var output = animation.parameters[sampler.output];
	            			if (output && output.data) {
	            				
	            				var target = channel.target;
	            				var node = this.resources.getEntry(target.id);
	            				if (node) {

	            					var path = target.path;
		            				
		            				if (path == "rotation")
		            				{
		            					convertAxisAngleToQuaternion(output.data, output.count);
		            				}
		            				
			            			var interp = {
			            					keys : input.data,
			            					values : output.data,
			            					count : input.count,
			            					target : node.object,
			            					path : path,
			            					type : sampler.interpolation
			            			};
			            			
			            			this.addNodeAnimationChannel(target.id, channel, interp);
			            			interps.push(interp);
	            				}
	            			}
	            		}
	            	}
	            }	            
        	}
        },
        
        handleAnimation: {
            value: function(entryID, description, userInfo) {
        	
        		var self = this;
	            theLoader.animationsRequested++;
	            var animation = new Animation();
                animation.name = entryID;
	            animation.onload = function() {
	            	// self.buildAnimation(animation);
	            	theLoader.animationsLoaded++;
	            	theLoader.animations.push(animation);
                    theLoader.checkComplete();
	            };	            
	            
	            animation.channels = description.channels;
	            animation.samplers = description.samplers;
	            this.resources.setEntry(entryID, animation, description);
	            var parameters = description.parameters;
	            if (!parameters) {
	                //FIXME: not implemented in delegate
	                console.log("MISSING_PARAMETERS for animation:"+ entryID);
	                return false;
	            }
	
                // Load parameter buffers
                var params = Object.keys(parameters);
                params.forEach( function(param) {

                	animation.totalParameters++;
                    var parameter = parameters[param];
                    var accessor = this.resources.getEntry(parameter);
                    if (!accessor)
                    	debugger;
                    accessor = accessor.object;
                    var bufferView = this.resources.getEntry(accessor.bufferView);
                    var paramObject = {
                    		bufferView : bufferView,
                    		byteOffset : accessor.byteOffset,
                    		count : accessor.count,
                    		type : accessor.type,
                    		id : accessor.bufferView,
                    		name : param             
                    };
                    
                    var paramContext = new AnimationParameterContext(paramObject, animation);

                    var alreadyProcessedAttribute = this.loaderUtils.getBuffer(paramObject, animationParameterDelegate, paramContext);
                    /*if(alreadyProcessedAttribute) {
                        vertexAttributeDelegate.resourceAvailable(alreadyProcessedAttribute, attribContext);
                    }*/
                }, this);

	            return true;
            }
        },

        handleAccessor: {
            value: function(entryID, description, userInfo) {
	    		// Save attribute entry
	    		this.resources.setEntry(entryID, description, description);
                return true;
            }
        },

        handleSkin: {
            value: function(entryID, description, userInfo) {
	    		// Save skin entry
        	
        		var skin = {
        		};
        		
                var m = description.bindShapeMatrix;
	            skin.bindShapeMatrix = new THREE.Matrix4(
                        m[0],  m[4],  m[8],  m[12],
                        m[1],  m[5],  m[9],  m[13],
                        m[2],  m[6],  m[10], m[14],
                        m[3],  m[7],  m[11], m[15]
                    );
	            
	            skin.jointsIds = description.joints;
	            var inverseBindMatricesDescription = description.inverseBindMatrices;
	            skin.inverseBindMatricesDescription = inverseBindMatricesDescription;
	            skin.inverseBindMatricesDescription.id = entryID + "_inverseBindMatrices";

                var bufferEntry = this.resources.getEntry(inverseBindMatricesDescription.bufferView);

                var paramObject = {
                		bufferView : bufferEntry,
                		byteOffset : inverseBindMatricesDescription.byteOffset,
                		count : inverseBindMatricesDescription.count,
                		type : inverseBindMatricesDescription.type,
                		id : inverseBindMatricesDescription.bufferView,
                		name : skin.inverseBindMatricesDescription.id             
                };
                
	            var context = new InverseBindMatricesContext(paramObject, skin);

                var alreadyProcessedAttribute = this.loaderUtils.getBuffer(paramObject, inverseBindMatricesDelegate, context);

	            var bufferView = this.resources.getEntry(skin.inverseBindMatricesDescription.bufferView);
	            skin.inverseBindMatricesDescription.bufferView = 
	            	bufferView.object;
	    		this.resources.setEntry(entryID, skin, description);
                return true;
            }
        },

        handleSampler: {
            value: function(entryID, description, userInfo) {
	    		// Save attribute entry
	    		this.resources.setEntry(entryID, description, description);
                return true;
            }
        },

        handleTexture: {
            value: function(entryID, description, userInfo) {
	    		// Save attribute entry
	    		this.resources.setEntry(entryID, null, description);
                return true;
            }
        },
        
        handleError: {
            value: function(msg) {

        		throw new Error(msg);
        		return true;
        	}
        },
        
        _delegate: {
            value: new LoadDelegate,
            writable: true
        },

        delegate: {
            enumerable: true,
            get: function() {
                return this._delegate;
            },
            set: function(value) {
                this._delegate = value;
            }
        }
    });


    // Loader

    var Context = function(rootObj, callback) {
        this.rootObj = rootObj;
        this.callback = callback;
    };

    var rootObj = new THREE.Object3D();

    var self = this;
    
    var loader = Object.create(ThreeGLTFLoader);
    this.loader = loader;
    this.callback = callback;
    this.rootObj = rootObj;

    loader.initWithPath(url);
    loader.load(new Context(rootObj, 
    					function(obj) {
    					}), 
    			null);

    return rootObj;
}

THREE.glTFLoader.prototype.callLoadedCallback = function() {
	var result = {
			scene : this.rootObj,
			cameras : this.loader.cameras,
			animations : this.loader.animations,
	};
	
	this.callback(result);
}

THREE.glTFLoader.prototype.checkComplete = function() {

	if (this.meshesLoaded == this.meshesRequested 
			&& this.shadersLoaded == this.shadersRequested
			&& this.animationsLoaded == this.animationsRequested)
	{
		
		for (var i = 0; i < this.pendingMeshes.length; i++) {
			var pending = this.pendingMeshes[i];
			pending.mesh.attachToNode(pending.node);
		}
		
		for (var i = 0; i < this.animationsLoaded; i++) {
			var animation = this.animations[i];
			this.loader.buildAnimation(animation);
		}

		this.loader.createAnimations();
		this.loader.createMeshAnimations(this.rootObj);
        
		this.callLoadedCallback();
	}
}



/**
 * @author Tony Parisi / http://www.tonyparisi.com/
 */

THREE.GLTFLoaderUtils = function() {
  var utils = Object.create(Object, {

    // errors
    MISSING_DESCRIPTION: { value: "MISSING_DESCRIPTION" },
    INVALID_PATH: { value: "INVALID_PATH" },
    INVALID_TYPE: { value: "INVALID_TYPE" },
    XMLHTTPREQUEST_STATUS_ERROR: { value: "XMLHTTPREQUEST_STATUS_ERROR" },
    NOT_FOUND: { value: "NOT_FOUND" },
    // misc constants
    ARRAY_BUFFER: { value: "ArrayBuffer" },

    _streams : { value:{}, writable: true },

    _streamsStatus: { value: {}, writable: true },
    
    _resources: { value: {}, writable: true },

    _resourcesStatus: { value: {}, writable: true },

    // initialization
    init: {
        value: function() {
	        this._streams = {};
	        this._streamsStatus = {};
            this._resources = {};
            this._resourcesStatus = {};
        }
    },

    //manage entries
    _containsResource: {
        enumerable: false,
        value: function(resourceID) {
            return this._resources[resourceID] ? true : false;
        }
    },

    _storeResource: {
        enumerable: false,
        value: function(resourceID, resource) {
            if (!resourceID) {
                console.log("ERROR: entry does not contain id, cannot store");
                return;
            }

            if (this._containsResource[resourceID]) {
                console.log("WARNING: resource:"+resourceID+" is already stored, overriding");
            }

           this._resources[resourceID] = resource;
        }
    },

    _getResource: {
        enumerable: false,
        value: function(resourceID) {
            return this._resources[resourceID];
        }
    },

    _loadStream: {
        value: function(path, type, delegate) {
            var self = this;

            if (!type) {
                delegate.handleError(THREE.GLTFLoaderUtils.INVALID_TYPE, null);
                return;
            }

            if (!path) {
                delegate.handleError(THREE.GLTFLoaderUtils.INVALID_PATH);
                return;
            }

            var xhr = new XMLHttpRequest();
            xhr.open('GET', path, true);
            xhr.responseType = (type === this.ARRAY_BUFFER) ? "arraybuffer" : "text";

            //if this is not specified, 1 "big blob" scenes fails to load.
            xhr.setRequestHeader("If-Modified-Since", "Sat, 01 Jan 1970 00:00:00 GMT");
            xhr.addEventListener( 'load', function ( event ) {
                delegate.streamAvailable(path, xhr.response);
            }, false );
            xhr.addEventListener( 'error', function ( event ) {
                delegate.handleError(THREE.GLTFLoaderUtils.XMLHTTPREQUEST_STATUS_ERROR, xhr.status);
            }, false );
            xhr.send(null);
        }
    },

    send: { value: 0, writable: true },
    requested: { value: 0, writable: true },

    _handleRequest: {
        value: function(request) {
            var resourceStatus = this._resourcesStatus[request.id];
            if (resourceStatus)
            {
            	this._resourcesStatus[request.id]++;
            }
            else
            {
            	this._resourcesStatus[request.id] = 1;
            }
            
            var streamStatus = this._streamsStatus[request.path];
            if (streamStatus && streamStatus.status === "loading" )
            {
            	streamStatus.requests.push(request);
                return;
            }
            
            this._streamsStatus[request.path] = { status : "loading", requests : [request] };
    		
            var self = this;
            var processResourceDelegate = {};

            processResourceDelegate.streamAvailable = function(path, res_) {
            	var streamStatus = self._streamsStatus[path];
            	var requests = streamStatus.requests;
//            	console.log("Stream available: ", path, requests.length);
                requests.forEach( function(req_) {
                    var subArray = res_.slice(req_.range[0], req_.range[1]);
                    var convertedResource = req_.delegate.convert(subArray, req_.ctx);
                    self._storeResource(req_.id, convertedResource);
                    req_.delegate.resourceAvailable(convertedResource, req_.ctx);
                    --self._resourcesStatus[req_.id];

                }, this);
            	
                delete self._streamsStatus[path];

            };

            processResourceDelegate.handleError = function(errorCode, info) {
                request.delegate.handleError(errorCode, info);
            }

            this._loadStream(request.path, request.type, processResourceDelegate);
        }
    },


    _elementSizeForGLType: {
        value: function(glType) {
            switch (glType) {
                case WebGLRenderingContext.FLOAT :
                    return Float32Array.BYTES_PER_ELEMENT;
                case WebGLRenderingContext.UNSIGNED_BYTE :
                    return Uint8Array.BYTES_PER_ELEMENT;
                case WebGLRenderingContext.UNSIGNED_SHORT :
                    return Uint16Array.BYTES_PER_ELEMENT;
                case WebGLRenderingContext.FLOAT_VEC2 :
                    return Float32Array.BYTES_PER_ELEMENT * 2;
                case WebGLRenderingContext.FLOAT_VEC3 :
                    return Float32Array.BYTES_PER_ELEMENT * 3;
                case WebGLRenderingContext.FLOAT_VEC4 :
                    return Float32Array.BYTES_PER_ELEMENT * 4;
                case WebGLRenderingContext.FLOAT_MAT3 :
                    return Float32Array.BYTES_PER_ELEMENT * 9;
                case WebGLRenderingContext.FLOAT_MAT4 :
                    return Float32Array.BYTES_PER_ELEMENT * 16;
                default:
                    return null;
            }
        }
    },

    _handleWrappedBufferViewResourceLoading: {
        value: function(wrappedBufferView, delegate, ctx) {
            var bufferView = wrappedBufferView.bufferView;
            var buffer = bufferView.buffer;
            var byteOffset = wrappedBufferView.byteOffset + bufferView.description.byteOffset;
            var range = [byteOffset , (this._elementSizeForGLType(wrappedBufferView.type) * wrappedBufferView.count) + byteOffset];

            this._handleRequest({   "id" : wrappedBufferView.id,
                                    "range" : range,
                                    "type" : buffer.description.type,
                                    "path" : buffer.description.path,
                                    "delegate" : delegate,
                                    "ctx" : ctx }, null);
        }
    },
    
    getBuffer: {
    	
            value: function(wrappedBufferView, delegate, ctx) {

            var savedBuffer = this._getResource(wrappedBufferView.id);
            if (savedBuffer) {
                return savedBuffer;
            } else {
                this._handleWrappedBufferViewResourceLoading(wrappedBufferView, delegate, ctx);
            }

            return null;
        }
    },

    getFile: {
    	
        value: function(request, delegate, ctx) {

    		request.delegate = delegate;
    		request.ctx = ctx;

            this._handleRequest({   "id" : request.id,
                "path" : request.path,
                "range" : [0],
                "type" : "text",
                "delegate" : delegate,
                "ctx" : ctx }, null);
    	
            return null;
	    }
	},    
  });
  
  utils.init();
  return utils;
}
/**
 * @author Tony Parisi / http://www.tonyparisi.com/
 */

THREE.glTFAnimator = ( function () {

	var animators = [];

	return	{
		add : function(animator)
		{
			animators.push(animator);
		},

		remove: function(animator)
		{

			var i = animators.indexOf(animator);

			if ( i !== -1 ) {
				animators.splice( i, 1 );
			}
		},

		update : function()
		{
			for (i = 0; i < animators.length; i++)
			{
				animators[i].update();
			}
		},
	};
})();

// Construction/initialization
THREE.glTFAnimation = function(interps)
{
	this.running = false;
	this.loop = false;
	this.duration = 0;
	this.direction = THREE.glTFAnimation.FORWARD_DIRECTION;
	this.startTime = 0;
	this.interps = [];
	
	if (interps)
	{
		this.createInterpolators(interps);
	}
}

THREE.glTFAnimation.prototype.createInterpolators = function(interps)
{
	var i, len = interps.length;
	for (i = 0; i < len; i++)
	{
		var interp = new THREE.glTFInterpolator(interps[i]);
		this.interps.push(interp);
		this.duration = Math.max(this.duration, interp.duration);
	}
}

// Start/stop
THREE.glTFAnimation.prototype.play = function()
{
	if (this.running)
		return;
	
	this.startTime = Date.now();
	this.running = true;
	THREE.glTFAnimator.add(this);
}

THREE.glTFAnimation.prototype.stop = function()
{
	this.running = false;
	THREE.glTFAnimator.remove(this);
}

// Update - drive key frame evaluation
THREE.glTFAnimation.prototype.update = function()
{
	if (!this.running)
		return;
	
	var now = Date.now();
	var deltat = (now - this.startTime) / 1000;
	var t = deltat % this.duration;
	var nCycles = Math.floor(deltat / this.duration);
	if (this.direction == THREE.glTFAnimation.REVERSE_DIRECTION) {
		t = this.duration - t;
	}
	
	if (nCycles >= 1 && !this.loop)
	{
		this.running = false;
		var i, len = this.interps.length;
		for (i = 0; i < len; i++)
		{
			if (this.direction == THREE.glTFAnimation.REVERSE_DIRECTION)
				this.interps[i].interp(0);
			else
				this.interps[i].interp(this.duration);
		}
		this.stop();
		return;
	}
	else
	{
		var i, len = this.interps.length;
		for (i = 0; i < len; i++)
		{
			this.interps[i].interp(t);
		}
	}
}

//Interpolator class
//Construction/initialization
THREE.glTFInterpolator = function(param) 
{	    		
	this.keys = param.keys;
	this.values = param.values;
	this.count = param.count;
	this.type = param.type;
	this.path = param.path;
	this.isRot = false;
	
	var node = param.target;
	node.updateMatrix();
	node.matrixAutoUpdate = true;
	this.targetNode = node;
	
	switch (param.path) {
		case "translation" :
			this.target = node.position;
			this.originalValue = node.position.clone();
			break;
		case "rotation" :
			this.target = node.quaternion;
			this.originalValue = node.quaternion.clone();
			this.isRot = true;
			break;
		case "scale" :
			this.target = node.scale;
			this.originalValue = node.scale.clone();
			break;
	}
	
	this.duration = this.keys[this.count - 1];
	
	this.vec1 = new THREE.Vector3;
	this.vec2 = new THREE.Vector3;
	this.vec3 = new THREE.Vector3;
	this.quat1 = new THREE.Quaternion;
	this.quat2 = new THREE.Quaternion;
	this.quat3 = new THREE.Quaternion;
}

//Interpolation and tweening methods
THREE.glTFInterpolator.prototype.interp = function(t)
{
	var i, j;
	if (t == this.keys[0])
	{
		if (this.isRot) {
			this.quat3.set(this.values[0], this.values[1], this.values[2], this.values[3]);
		}
		else {
			this.vec3.set(this.values[0], this.values[1], this.values[2]);
		}
	}
	else if (t < this.keys[0])
	{
		if (this.isRot) {
			this.quat1.set(this.originalValue.x,
					this.originalValue.y,
					this.originalValue.z,
					this.originalValue.w);
			this.quat2.set(this.values[0],
					this.values[1],
					this.values[2],
					this.values[3]);
			THREE.Quaternion.slerp(this.quat1, this.quat2, this.quat3, t / this.keys[0]);
		}
		else {
			this.vec3.set(this.originalValue.x,
					this.originalValue.y,
					this.originalValue.z);
			this.vec2.set(this.values[0],
					this.values[1],
					this.values[2]);

			this.vec3.lerp(this.vec2, t / this.keys[0]);
		}
	}
	else if (t >= this.keys[this.count - 1])
	{
		if (this.isRot) {
			this.quat3.set(this.values[(this.count - 1) * 4], 
					this.values[(this.count - 1) * 4 + 1],
					this.values[(this.count - 1) * 4 + 2],
					this.values[(this.count - 1) * 4 + 3]);
		}
		else {
			this.vec3.set(this.values[(this.count - 1) * 3], 
					this.values[(this.count - 1) * 3 + 1],
					this.values[(this.count - 1) * 3 + 2]);
		}
	}
	else
	{
		for (i = 0; i < this.count - 1; i++)
		{
			var key1 = this.keys[i];
			var key2 = this.keys[i + 1];
	
			if (t >= key1 && t <= key2)
			{
				if (this.isRot) {
					this.quat1.set(this.values[i * 4],
							this.values[i * 4 + 1],
							this.values[i * 4 + 2],
							this.values[i * 4 + 3]);
					this.quat2.set(this.values[(i + 1) * 4],
							this.values[(i + 1) * 4 + 1],
							this.values[(i + 1) * 4 + 2],
							this.values[(i + 1) * 4 + 3]);
					THREE.Quaternion.slerp(this.quat1, this.quat2, this.quat3, (t - key1) / (key2 - key1));
				}
				else {
					this.vec3.set(this.values[i * 3],
							this.values[i * 3 + 1],
							this.values[i * 3 + 2]);
					this.vec2.set(this.values[(i + 1) * 3],
							this.values[(i + 1) * 3 + 1],
							this.values[(i + 1) * 3 + 2]);
	
					this.vec3.lerp(this.vec2, (t - key1) / (key2 - key1));
				}
			}
		}
	}
	
	if (this.target)
	{
		this.copyValue(this.target);
	}
}

THREE.glTFInterpolator.prototype.copyValue = function(target) {
	
	if (this.isRot) {
		target.copy(this.quat3);
	}
	else {
		target.copy(this.vec3);
	}		
}

THREE.glTFAnimation.FORWARD_DIRECTION = 0;
THREE.glTFAnimation.REVERSE_DIRECTION = 1;

var OculusBridge = function(config) {

	// ye olde websocket
	var socket;

	var reconnectTimeout 	= null;
	var retryOnDisconnect 	= true;
	var websocketAddress 	= config.hasOwnProperty("address") 			? config["address"] 		: "localhost";
	var websocketPort 		= config.hasOwnProperty("port") 			? config["port"] 			: 9005;
	var retryInterval 		= config.hasOwnProperty("retryInterval") 	? config["retryInterval"] 	: 1;
	var debugEnabled		= config.hasOwnProperty("debug") 			? config["debug"] 			: false;

	// Quaternion values
	var quaternionValues = { 
		x : 0,
		y : 0,
		z : 0,
		w : 0 
	};

	// Accelerometer readings
	var accelerationValues = {
		x : 0,
		y : 0,
		z : 0
	};

	// Display metrics, set to defaults from the dev kit hardware
	var displayMetrics = {
		FOV 					: 125.871,

		hScreenSize				: 0.14976,
		vScreenSize				: 0.0935,
		vScreenCenter			: 0.0935 / 2,

		eyeToScreenDistance		: 0.041,

		lensSeparationDistance	: 0.067,
		interpupillaryDistance	: 0.0675,

		hResolution				: 1280,
		vResolution				: 720,

		distortionK				: [1, .22, .24, 0],
		chromaAbParameter		: [0.996, -0.004, 1.014, 0]
	}

	// Callback handlers.
	var callbacks = {
		onOrientationUpdate : null,
		onAccelerationUpdate: null,
		onConfigUpdate : null,
		onConnect : null,
		onDisconnect : null
	};

	// hook up any callbacks specified in the config object
	for(var cb in callbacks){
		if(typeof(config[cb]) == "function"){
			callbacks[cb] = config[cb];
		}
	}

	var updateOrientation = function(data) {

		if(data["o"] && (data["o"].length == 4)) {
			
			quaternionValues.x = Number(data["o"][1]);
			quaternionValues.y = Number(data["o"][2]);
			quaternionValues.z = Number(data["o"][3]);
			quaternionValues.w = Number(data["o"][0]);

			if(callbacks["onOrientationUpdate"]) {
				callbacks["onOrientationUpdate"](quaternionValues);
			}
		}
	}

	var updateAcceleration = function(data) {

		if(data["a"] && (data["a"].length == 3)) {
			
			accelerationValues.x = Number(data["a"][0]);
			accelerationValues.y = Number(data["a"][1]);
			accelerationValues.z = Number(data["a"][2]);

			if(callbacks["onAccelerationUpdate"]) {
				callbacks["onAccelerationUpdate"](accelerationValues);
			}
		}
	}

	var updateConfig = function(data) {
		displayMetrics.hScreenSize				= data["screenSize"][0];
		displayMetrics.vScreenSize				= data["screenSize"][1];
		displayMetrics.vScreenCenter			= data["screenSize"][1] / 2;

		displayMetrics.eyeToScreenDistance		= data["eyeToScreen"];

		displayMetrics.lensSeparationDistance	= data["lensDistance"];
		displayMetrics.interpupillaryDistance	= data["interpupillaryDistance"];

		displayMetrics.hResolution				= data["screenResolution"][0];
		displayMetrics.vResolution				= data["screenResolution"][1];

		displayMetrics.distortionK				= [ data["distortion"][0], data["distortion"][1], data["distortion"][2], data["distortion"][3] ];

		displayMetrics.FOV						= data["fov"];

		if(callbacks["onConfigUpdate"]) {
			callbacks["onConfigUpdate"]( displayMetrics );
		}
	}


	var connect = function() {
		
		retryOnDisconnect = true;
		
		var socketURL = "ws://" + websocketAddress + ":" + websocketPort + "/";
		
		// attempt to open the socket connection
	 	socket = new WebSocket(socketURL); 

		debug("Attempting to connect: " + socketURL);
	 	

	 	// hook up websocket events //

		socket.onopen = function(){
			debug("Connected!")

			if(callbacks["onConnect"]) {
				callbacks["onConnect"]();
			}
		}

		socket.onerror = function(e){
			debug("Socket error.");
		}
		
		socket.onmessage = function(msg) {
			
			var data = JSON.parse( msg.data );

			var message = data["m"];

			switch(message){
				case "config" :
					updateConfig(data);
				break;

				// For backwards compatability with the bridge application.
				case "orientation":
					updateOrientation(data);
				break;

				case "update":
					updateOrientation(data);
					updateAcceleration(data);
				break;

				default:
					debug("Unknown message received from server: " + msg.data);
					disconnect();
				break;
			}

		}
		
		socket.onclose = function() {
			if(callbacks["onDisconnect"]) {
				callbacks["onDisconnect"]();
			}

			if(retryOnDisconnect){
				debug("Connection failed, retrying in 1 second...");
				reconnectTimeout = window.setTimeout( reconnect, retryInterval * 1000 );
			}
		}
	}

	var debug = function(message){
		if(debugEnabled){
			console.log("OculusBridge: " + message);
		}
	}

	var reconnect = function(){
		connect();
	}

	var disconnect = function(){
		retryOnDisconnect = false;
		window.clearTimeout(reconnectTimeout);
		socket.close();
	}

	var getConfiguration = function(){
		return displayMetrics;
	}

	var getOrientation = function(){
		return quaternionValues;
	}

	var getAcceleration = function(){
		return accelerationValues;
	}

	var isConnected = function(){
		return socket.readyState == 1;
	}

	return {
		"isConnected" 		: isConnected,
		"disconnect" 		: disconnect,
		"connect" 			: connect,
		"getOrientation" 	: getOrientation,
		"getConfiguration" 	: getConfiguration
	}
};/**
 * @author troffmo5 / http://github.com/troffmo5
 *
 * Effect to render the scene in stereo 3d side by side with lens distortion.
 * It is written to be used with the Oculus Rift (http://www.oculusvr.com/) but
 * it works also with other HMD using the same technology
 */

THREE.OculusRiftEffect = function ( renderer, options ) {
	// worldFactor indicates how many units is 1 meter
	var worldFactor = (options && options.worldFactor) ? options.worldFactor: 1.0;

	// Specific HMD parameters
	var HMD = (options && options.HMD) ? options.HMD: {
		// Parameters from the Oculus Rift DK1
		hResolution: 1280,
		vResolution: 720,
		hScreenSize: 0.14976,
		vScreenSize: 0.0935,
		interpupillaryDistance: 0.064,
		lensSeparationDistance: 0.0635,
		eyeToScreenDistance: 0.041,
		distortionK : [1.0, 0.22, 0.24, 0.0],
		chromaAbParameter : [0.996, -0.004, 1.014, 0]
	};

	// Perspective camera
	var pCamera = new THREE.PerspectiveCamera();
	pCamera.matrixAutoUpdate = false;
	pCamera.target = new THREE.Vector3();

	// Orthographic camera
	var oCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0.0001, 100000 );
	oCamera.position.z = 1;

	// pre-render hooks
	this.preLeftRender = function() {};
	this.preRightRender = function() {};

	//renderer.autoClear = false;
	var emptyColor = new THREE.Color("black");

	// Render target
	var RTParams = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };
	var renderTarget = new THREE.WebGLRenderTarget( 640, 800, RTParams );
	var RTMaterial = new THREE.ShaderMaterial( {
		uniforms: {
			"texid": { type: "t", value: renderTarget },
			"scale": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
			"scaleIn": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
			"lensCenter": { type: "v2", value: new THREE.Vector2(0.0,0.0) },
			"hmdWarpParam": { type: "v4", value: new THREE.Vector4(1.0,0.0,0.0,0.0) },
			"chromAbParam": { type: "v4", value: new THREE.Vector4(1.0,0.0,0.0,0.0) }
		},
		vertexShader: [
			"varying vec2 vUv;",
			"void main() {",
			" vUv = uv;",
			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
			"}"
		].join("\n"),

		fragmentShader: [
			"uniform vec2 scale;",
			"uniform vec2 scaleIn;",
			"uniform vec2 lensCenter;",
			"uniform vec4 hmdWarpParam;",
			'uniform vec4 chromAbParam;',
			"uniform sampler2D texid;",
			"varying vec2 vUv;",
			"void main()",
			"{",
			"  vec2 uv = (vUv*2.0)-1.0;", // range from [0,1] to [-1,1]
			"  vec2 theta = (uv-lensCenter)*scaleIn;",
			"  float rSq = theta.x*theta.x + theta.y*theta.y;",
			"  vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);",
			'  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);',
			"  vec2 tcBlue = (lensCenter + scale * rBlue);",
			"  tcBlue = (tcBlue+1.0)/2.0;", // range from [-1,1] to [0,1]
			"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {",
			"    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);",
			"    return;}",
			"  vec2 tcGreen = lensCenter + scale * rvector;",
			"  tcGreen = (tcGreen+1.0)/2.0;", // range from [-1,1] to [0,1]
			"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);",
			"  vec2 tcRed = lensCenter + scale * rRed;",
			"  tcRed = (tcRed+1.0)/2.0;", // range from [-1,1] to [0,1]
			"  gl_FragColor = vec4(texture2D(texid, tcRed).r, texture2D(texid, tcGreen).g, texture2D(texid, tcBlue).b, 1);",
			"}"
		].join("\n")
	} );

	var mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), RTMaterial );

	// Final scene
	var finalScene = new THREE.Scene();
	finalScene.add( oCamera );
	finalScene.add( mesh );

    var left = {}, right = {};
    var distScale = 1.0;
	this.setHMD = function(v) {
		HMD = v;
		// Compute aspect ratio and FOV
		var aspect = HMD.hResolution / (2*HMD.vResolution);

		// Fov is normally computed with:
		//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );
		// But with lens distortion it is increased (see Oculus SDK Documentation)
		var r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);
		distScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));
		var fov = HMD.fov ? HMD.fov : THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));

		// Compute camera projection matrices
		var proj = (new THREE.Matrix4()).makePerspective( fov, aspect, 0.01, 100000 );
		var h = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;
		left.proj = ((new THREE.Matrix4()).makeTranslation( h, 0.0, 0.0 )).multiply(proj);
		right.proj = ((new THREE.Matrix4()).makeTranslation( -h, 0.0, 0.0 )).multiply(proj);

		// Compute camera transformation matrices
		left.tranform = (new THREE.Matrix4()).makeTranslation( -worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );
		right.tranform = (new THREE.Matrix4()).makeTranslation( worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );

		// Compute Viewport
		left.viewport = [0, 0, HMD.hResolution/2, HMD.vResolution];
		right.viewport = [HMD.hResolution/2, 0, HMD.hResolution/2, HMD.vResolution];

		// Distortion shader parameters
		var lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;
		left.lensCenter = new THREE.Vector2(lensShift, 0.0);
		right.lensCenter = new THREE.Vector2(-lensShift, 0.0);

		RTMaterial.uniforms['hmdWarpParam'].value = new THREE.Vector4(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);
		RTMaterial.uniforms['chromAbParam'].value = new THREE.Vector4(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);
		RTMaterial.uniforms['scaleIn'].value = new THREE.Vector2(1.0,1.0/aspect);
		RTMaterial.uniforms['scale'].value = new THREE.Vector2(1.0/distScale, 1.0*aspect/distScale);
		console.log(lensShift);
		console.log("ScaleIn",  new THREE.Vector2(1.0,1.0/aspect));
		console.log("Scale",  new THREE.Vector2(1.0,1.0/aspect));

		// Create render target
		renderTarget = new THREE.WebGLRenderTarget( HMD.hResolution*distScale/2, HMD.vResolution*distScale, RTParams );
		RTMaterial.uniforms[ "texid" ].value = renderTarget;

	}	
	this.getHMD = function() {return HMD};

	this.setHMD(HMD);	

	this.setSize = function ( width, height ) {
		left.viewport = [width/2 - HMD.hResolution/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];
		right.viewport = [width/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];

		renderer.setSize( width, height );
	};

	this.render = function ( scene, camera ) {
		var cc = renderer.getClearColor().clone();
		var autoClear = renderer.autoClear;

		renderer.autoClear = false;

		// Clear
		renderer.setClearColor(emptyColor);
		renderer.clear();
		renderer.setClearColor(cc);

		var scenes, cameras;
		if (scene instanceof Array) {
			scenes = scene;
		}
		else {
			scenes = [ scene ];
		}

		if (camera instanceof Array) {
			cameras = camera;
		}
		else {
			cameras = [ camera ];
		}

		// Render left
		this.preLeftRender();

		renderer.setViewport(left.viewport[0], left.viewport[1], left.viewport[2], left.viewport[3]);
		RTMaterial.uniforms['lensCenter'].value = left.lensCenter;

		var i, len = scenes.length;
		for (i = 0; i < len; i++) {

			if (i == 0) {
			   	renderer.setClearColor( 0, 0 );
				renderer.autoClearColor = true;				
			}
			else {
			    renderer.setClearColor( 0, 1 );
				renderer.autoClearColor = false;				
			}

			var scene = scenes[i];
			var camera = cameras[i];			

			// camera parameters
			scene.updateMatrix();
			scene.updateMatrixWorld();
			if (camera.matrixAutoUpdate) {
					camera.updateMatrix();
					camera.updateMatrixWorld();
			}

			pCamera.projectionMatrix.copy(left.proj);

			pCamera.matrix.copy(camera.matrixWorld).multiply(left.tranform);
			pCamera.matrixWorldNeedsUpdate = true;

			renderer.render( scene, pCamera, renderTarget, true );
		}


		renderer.render( finalScene, oCamera );

		// Render right
		this.preRightRender();

		renderer.setViewport(right.viewport[0], right.viewport[1], right.viewport[2], right.viewport[3]);
		RTMaterial.uniforms['lensCenter'].value = right.lensCenter;
		
		var i, len = scenes.length;
		for (i = 0; i < len; i++) {

			if (i == 0) {
			   	renderer.setClearColor( 0, 0 );
				renderer.autoClearColor = true;				
			}
			else {
			    renderer.setClearColor( 0, 1 );
				renderer.autoClearColor = false;				
			}

			var scene = scenes[i];
			var camera = cameras[i];			

			// camera parameters
			scene.updateMatrix();
			scene.updateMatrixWorld();
			if (camera.matrixAutoUpdate) {
					camera.updateMatrix();
					camera.updateMatrixWorld();
			}
			pCamera.projectionMatrix.copy(right.proj);

			pCamera.matrix.copy(camera.matrixWorld).multiply(right.tranform);
			pCamera.matrixWorldNeedsUpdate = true;


			renderer.render( scene, pCamera, renderTarget, true );
		}

		renderer.render( finalScene, oCamera );

		renderer.autoClear = autoClear;
	};

};/**
 * vr.js library main code.
 *
 * @author Ben Vanik <ben.vanik@gmail.com>
 * @license Apache 2.0
 * @module vr
 */

(function(global) {


/**
 * @namespace vr
 * @alias module vr
 */
var vr = {};


/**
 * Error codes that may be set as the 'code' property on Error objects.
 * These can be used for handing the errors without having to inspect their
 * text.
 * @enum {number}
 * @memberof vr
 */
vr.ErrorCode = {
  /**
   * The plugin was not found and is most likely not installed.
   */
  PLUGIN_NOT_FOUND: 1,

  /**
   * Plugin is present but was blocked from running by the browser. The user
   * should enable the plugin for the page (from the page action in Chrome).
   */
  PLUGIN_BLOCKED: 4
};


/**
 * The data source providing the sensor data.
 * @enum {number}
 * @memberof vr
 */
vr.DataSourceMode = {
  /**
   * NPAPI plugin.
   */
  PLUGIN: 0,

  /**
   * Javascript USB driver.
   */
  DRIVER: 1
};


// From Closure base.js:
function inherits(childCtor, parentCtor) {
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  childCtor.prototype.constructor = childCtor;
};


/**
 * Data source base type.
 * @constructor
 * @private
 */
vr.DataSource = function() {
};


/**
 * Disposes the data source and any dependent resources.
 */
vr.DataSource.prototype.dispose = function() {
};


/**
 * Detects whether the data source is present and supported.
 * This could be called periodically to wait for install.
 * @return {boolean} True if present.
 */
vr.DataSource.prototype.isPresent = function() {
  return false;
};


/**
 * Loads the data source.
 * @param {function(this:T, Error=)=} opt_callback Callback function.
 * @param {T=} opt_scope Optional callback scope.
 * @template T
 */
vr.DataSource.prototype.load = function(callback, opt_scope) {
  global.setTimeout(function() {
    callback.call(opt_scope, null);
  }, 0);
};


/**
 * Queries the connected HMD device.
 * @return {vr.HmdInfo} Device info or null if none attached.
 */
vr.DataSource.prototype.queryHmdInfo = function() {
  return null;
};


/**
 * Queries the connected Sixense device.
 * @return {vr.SixenseInfo} Device info or null if none attached.
 */
vr.DataSource.prototype.querySixenseInfo = function() {
  return null;
};


/**
 * Resets the HMD orientation to its default.
 */
vr.DataSource.prototype.resetHmdOrientation = function() {
};


/**
 * Polls active devices and fills in the state structure.
 * @param {!vr.State} state State structure to fill in. This must be created by
 *     the caller and should be cached across calls to prevent extra garbage.
 */
vr.DataSource.prototype.poll = function(state) {
};



/**
 * NPAPI plugin-based data source.
 * @param {!Document} document HTML document.
 * @constructor
 * @inherits {vr.DataSource}
 * @private
 */
vr.PluginDataSource = function(document) {
  vr.DataSource.call(this);

  /**
   * HTML document.
   * @type {!Document}
   * @private
   */
  this.document_ = document;

  /**
   * Native plugin object.
   * @type {Object}
   * @private
   */
  this.native_ = null;
};
inherits(vr.PluginDataSource, vr.DataSource);


/**
 * @override
 */
vr.PluginDataSource.prototype.dispose = function() {
  // TOOD(benvanik): destroy the plugin embed, remove from dom, etc.
  vr.DataSource.prototype.dispose.call(this);
};


/**
 * @override
 */
vr.PluginDataSource.prototype.isPresent = function() {
  var plugins = navigator.plugins;
  plugins.refresh();
  for (var n = 0; n < plugins.length; n++) {
    var plugin = plugins[n];
    for (var m = 0; m < plugin.length; m++) {
      var mimeType = plugin[m];
      if (mimeType.type == 'application/x-vnd-vr') {
        return true;
      }
    }
  }
  return false;
};


/**
 * Creates the <embed> tag for the plugin.
 * @return {!HTMLEmbedElement} Embed element. Not yet added to the DOM.
 * @private
 */
vr.PluginDataSource.prototype.createEmbed_ = function() {
  var embed = this.document_.createElement('embed');
  embed.type = 'application/x-vnd-vr';
  embed.width = 4;
  embed.height = 4;
  embed.style.visibility = 'hidden';
  embed.style.width = '0';
  embed.style.height = '0';
  embed.style.margin = '0';
  embed.style.padding = '0';
  embed.style.borderStyle = 'none';
  embed.style.borderWidth = '0';
  embed.style.maxWidth = '0';
  embed.style.maxHeight = '0';
  return embed;
};


/**
 * @override
 */
vr.PluginDataSource.prototype.load = function(callback, opt_scope) {
  // Create <embed>.
  var embed = this.createEmbed_();

  // Add to DOM. We may be able to just add to a fragment, but I'm not
  // sure.
  this.document_.body.appendChild(embed);

  // Wait until the plugin adds itself to the global.
  var startTime = Date.now();
  var self = this;
  function checkLoaded() {
    if (global._vr_native_) {
      self.native_ = global._vr_native_;
      callback.call(opt_scope, null);
    } else {
      var elapsed = Date.now() - startTime;
      if (elapsed > 5 * 1000) {
        // Waited longer than 5 seconds - timeout.
        self.native_ = null;
        var e = new Error('Plugin blocked - enable and reload.');
        e.code = vr.ErrorCode.PLUGIN_BLOCKED;
        callback.call(opt_scope, e);
      } else {
        // Keep waiting.
        global.setTimeout(checkLoaded, 100);
      }
    }
  };
  checkLoaded();
};


/**
 * Executes a command in the plugin and returns the raw result.
 * @param {number} commandId Command ID.
 * @param {string=} opt_commandData Command data string.
 * @return {string} Raw result string.
 * @private
 */
vr.PluginDataSource.prototype.execCommand_ = function(
    commandId, opt_commandData) {
  if (!this.native_) {
    return '';
  }
  return this.native_.exec(commandId, opt_commandData || '') || '';
};


/**
 * @override
 */
vr.PluginDataSource.prototype.queryHmdInfo = function() {
  var queryData = this.execCommand_(1);
  if (!queryData || !queryData.length) {
    return null;
  }
  var values = queryData.split(',');
  return new vr.HmdInfo(values);
};


/**
 * @override
 */
vr.PluginDataSource.prototype.querySixenseInfo = function() {
  // TODO(benvanik): a real query
  return new vr.SixenseInfo();
};


/**
 * @override
 */
vr.PluginDataSource.prototype.resetHmdOrientation = function() {
  this.execCommand_(2);
};


/**
 * @override
 */
vr.PluginDataSource.prototype.poll = function(state) {
  if (!this.native_) {
    return;
  }

  // Data is chunked into devices by |.
  // Data inside the device chunk is split on ,.
  // The first entry inside a chunk is the device type.
  // So:
  // s,1,2,3|r,4,5,6|
  // is:
  //   - sixense with data 1,2,3
  //   - rift with data 4,5,6
  var pollData = this.native_.poll();
  var deviceChunks = pollData.split('|');
  for (var n = 0; n < deviceChunks.length; n++) {
    var deviceChunk = deviceChunks[n].split(',');
    if (!deviceChunk.length) {
      continue;
    }
    switch (deviceChunk[0]) {
      case 's':
        // Sixense data.
        this.parseSixenseChunk_(state, deviceChunk, 1);
        break;
      case 'r':
        // Oculus data.
        this.parseHmdChunk_(state, deviceChunk, 1);
        break;
    }
  }
};


/**
 * Parses a Sixense data poll chunk and sets the state.
 * @param {!vr.State} state Target state.
 * @param {!Array.<string>} data Data elements.
 * @param {number} o Offset into data elements to start at.
 * @private
 */
vr.PluginDataSource.prototype.parseSixenseChunk_ = function(state, data, o) {
  // b,[base#],
  //   c,[controller#],
  //     [x],[y],[z],[q0],[q1],[q2],[q3],[jx],[jy],[tr],[buttons],
  //     [docked],[hand],[hemisphere tracking],
  //   c,[controller#],
  //     [x],[y],[z],[q0],[q1],[q2],[q3],[jx],[jy],[tr],[buttons],
  //     [docked],[hand],[hemisphere tracking],
  //   ...
  // ...

  while (o < data.length) {
    var c = data[o++];
    if (c == 'b') {
      var baseId = data[o++];
      state.sixense.present = true;
    } else if (c == 'c') {
      var controllerId = data[o++];
      var controller = state.sixense.controllers[controllerId];
      controller.position[0] = parseFloat(data[o++]);
      controller.position[1] = parseFloat(data[o++]);
      controller.position[2] = parseFloat(data[o++]);
      controller.rotation[0] = parseFloat(data[o++]);
      controller.rotation[1] = parseFloat(data[o++]);
      controller.rotation[2] = parseFloat(data[o++]);
      controller.rotation[3] = parseFloat(data[o++]);
      controller.joystick[0] = parseFloat(data[o++]);
      controller.joystick[1] = parseFloat(data[o++]);
      controller.trigger = parseFloat(data[o++]);
      controller.buttons = parseInt(data[o++], 10);
      controller.isDocked = data[o++] == '1';
      controller.hand = parseInt(data[o++], 10);
      controller.isTrackingHemispheres = data[o++] == '1';
    } else {
      break;
    }
  }
};


/**
 * Parses an HMD data poll chunk and sets the state.
 * @param {!vr.State} state Target state.
 * @param {!Array.<string>} data Data elements.
 * @param {number} o Offset into data elements to start at.
 * @private
 */
vr.PluginDataSource.prototype.parseHmdChunk_ = function(state, data, o) {
  if (data.length == 5) {
    state.hmd.present = true;
    state.hmd.rotation[0] = parseFloat(data[o++]);
    state.hmd.rotation[1] = parseFloat(data[o++]);
    state.hmd.rotation[2] = parseFloat(data[o++]);
    state.hmd.rotation[3] = parseFloat(data[o++]);
  } else {
    state.hmd.present = false;
  }
};



/**
 * Javascript USB driver-based data source.
 * @param {!Object} driver Driver instance.
 * @constructor
 * @inherits {vr.DataSource}
 * @private
 */
vr.DriverDataSource = function(driver) {
  vr.DataSource.call(this);

  /**
   * Driver object.
   * @type {!Object}
   * @private
   */
  this.driver_ = driver;
};
inherits(vr.DriverDataSource, vr.DataSource);


/**
 * @override
 */
vr.DriverDataSource.prototype.dispose = function() {
  this.driver_.dispose();
  vr.DataSource.prototype.dispose.call(this);
};


/**
 * @override
 */
vr.DriverDataSource.prototype.isPresent = function() {
  return true;
};


/**
 * @override
 */
vr.DriverDataSource.prototype.load = function(callback, opt_scope) {
  global.setTimeout(function() {
    callback.call(opt_scope, null);
  }, 0);
};


/**
 * @override
 */
vr.DriverDataSource.prototype.queryHmdInfo = function() {
  var info = new vr.HmdInfo();
  if (!this.driver_.fillHmdInfo(info)) {
    return null;
  }
  return info;
};


/**
 * @override
 */
vr.DriverDataSource.prototype.querySixenseInfo = function() {
  return null;
};


/**
 * @override
 */
vr.DriverDataSource.prototype.resetHmdOrientation = function() {
  this.driver_.resetOrientation();
};


/**
 * @override
 */
vr.DriverDataSource.prototype.poll = function(state) {
  var present = this.driver_.isPresent();
  state.hmd.present = present;
  if (present) {
    this.driver_.getOrientation(state.hmd.rotation);
  } else {
    state.hmd.rotation[0] = state.hmd.rotation[1] = state.hmd.rotation[2] = 0;
    state.hmd.rotation[3] = 0;
  }
};



/**
 * VR runtime state object.
 * Keeps track of state used by the various {@link vr} namespace methods.
 * @param {!Document} document HTML document.
 * @constructor
 * @private
 */
vr.Runtime = function(document) {
  /**
   * HTML document.
   * @type {!Document}
   * @private
   */
  this.document_ = document;

  /**
   * Current data source mode.
   * @type {vr.DataSourceMode}
   * @private
   */
  this.dataSourceMode_ = vr.DataSourceMode.PLUGIN;

  // If we have the USB driver, use that. Otherwise, default to plugin.
  if (global['__vr_driver__']) {
    this.dataSourceMode_ = vr.DataSourceMode.DRIVER;
  }
  var dataSource = null;
  switch (this.dataSourceMode_) {
    default:
    case vr.DataSourceMode.PLUGIN:
      dataSource = new vr.PluginDataSource(this.document_);
      break;
    case vr.DataSourceMode.DRIVER:
      dataSource = new vr.DriverDataSource(global['__vr_driver__']);
      break;
  }

  /**
   * Current data source.
   * @type {!vr.DataSource}
   * @private
   */
  this.dataSource_ = dataSource;

  /**
   * Whether the plugin is installed.
   * @type {boolean}
   * @private
   */
  this.isInstalled_ = this.dataSource_.isPresent();

  /**
   * Whether the plugin is initialized.
   * @type {boolean}
   * @private
   */
  this.isLoaded_ = false;

  /**
   * The error that occurred during initialization, if any.
   * @type {Object}
   * @private
   */
  this.error_ = null;

  /**
   * Whether the plugin is attempting to load.
   * This is set on the first attempt and never cleared to prevent fail loops.
   * @type {boolean}
   * @private
   */
  this.isLoading_ = false;

  /**
   * A list of callbacks waiting for ready.
   * @type {!Array.<!Array>}
   * @private
   */
  this.readyWaiters_ = [];

  /**
   * HMD info, if any device is attached.
   * @type {vr.HmdInfo}
   * @private
   */
  this.hmdInfo_ = null;

  /**
   * Sixense info, if any device is attached.
   * @type {vr.SixenseInfo}
   * @private
   */
  this.sixenseInfo_ = null;

  /**
   * An array of [x, y, w, h] of the window position before entering fullscreen.
   * This will not be set if we were not the ones who initiated the fullscreen
   * change.
   * @type {Array.<number>}
   * @private
   */
  this.oldWindowSize_ = null;

  var self = this;
  var fullScreenChange = function(e) {
    self.fullScreenChange_(e);
  };
  document.addEventListener('fullscreenchange', fullScreenChange, false);
  document.addEventListener('mozfullscreenchange', fullScreenChange, false);
};


/**
 * Starts loading the plugin and queues a callback that will be called when the
 * plugin is ready.
 *
 * The callback will receive an error object if an error occurred.
 * This error object may have a 'code' property corresponding to
 * {@link vr.ErrorCode}.
 *
 * If the plugin is already initialized the given callback will be called next
 * tick, so it's always safe to use this and assume asynchronicity.
 *
 * @param {function(this:T, Error=)=} opt_callback Callback function.
 * @param {T=} opt_scope Optional callback scope.
 * @template T
 */
vr.Runtime.prototype.load = function(opt_callback, opt_scope) {
  var self = this;

  // Fail if not installed.
  if (!this.isInstalled_) {
    var e = new Error('Plugin not installed!');
    e.code = vr.ErrorCode.PLUGIN_NOT_FOUND;
    this.error_ = e;
    if (opt_callback) {
      global.setTimeout(function() {
        opt_callback.call(opt_scope, self.error_);
      }, 0);
    }
    return;
  }

  if (this.isLoaded_ || this.error) {
    // Already loaded or errored, callback.
    if (opt_callback) {
      global.setTimeout(function() {
        opt_callback.call(opt_scope, self.error_);
      }, 0);
    }
    return;
  } else {
    // Wait for load...
    if (opt_callback) {
      this.readyWaiters_.push([opt_callback, opt_scope]);
    }

    if (this.isLoading_) {
      // Already loading, ignore the request.
      return;
    }

    // Start loading!
    this.isLoading_ = true;

    // Wait for DOM ready and initialize.
    vr.waitForDomReady(this.document_, function() {
      this.dataSource_.load(function(opt_error) {
        this.completeLoad_(opt_error);
      }, this);
    }, this);

    return;
  }
};


/**
 * Readies the library and calls back any waiters.
 * @param {Object=} opt_error Error, if any.
 * @private
 */
vr.Runtime.prototype.completeLoad_ = function(opt_error) {
  // Set state.
  if (opt_error) {
    this.isLoaded_ = false;
    this.error_ = opt_error;
  } else {
    this.isLoaded_ = true;
    this.error_ = null;
  }

  // Callback all waiters.
  while (this.readyWaiters_.length) {
    var waiter = this.readyWaiters_.shift();
    waiter[0].call(waiter[1], opt_error || null);
  }
};


/**
 * Polls active devices and fills in the state structure.
 * This also takes care of dispatching device notifications/etc.
 * @param {!vr.State} state State structure to fill in. This must be created by
 *     the caller and should be cached across calls to prevent extra garbage.
 * @return {boolean} True if the state query was successful.
 */
vr.Runtime.prototype.poll = function(state) {
  // Reset.
  state.sixense.present = false;
  state.hmd.present = false;

  // Poll data.
  this.dataSource_.poll(state);

  // Query any info if needed.
  if (state.sixense.present && !this.sixenseInfo_) {
    // Sixense connected.
    this.sixenseInfo_ = this.dataSource_.querySixenseInfo();
    // TODO(benvanik): fire event?
  } else if (!state.sixense.present && this.sixenseInfo_) {
    // Sixense disconnected.
    this.sixenseInfo_ = null;
    // TODO(benvanik): fire event?
  }
  if (state.hmd.present && !this.hmdInfo_) {
    // HMD connected.
    this.hmdInfo_ = this.dataSource_.queryHmdInfo();
    // TODO(benvanik): fire event?
  } else if (!state.hmd.present && this.hmdInfo_) {
    // HMD disconnected.
    this.hmdInfo_ = null;
    // TODO(benvanik): fire event?
  }

  return true;
};


/**
 * Handles full screen change events.
 * @param {!Event} e Event.
 * @private
 */
vr.Runtime.prototype.fullScreenChange_ = function(e) {
  if (vr.isFullScreen()) {
    // Entered fullscreen.
  } else {
    // Exited fullscreen.

    // Move the window back.
    if (this.oldWindowSize_) {
      global.moveTo(this.oldWindowSize_[0], this.oldWindowSize_[1]);
      global.resizeTo(this.oldWindowSize_[2], this.oldWindowSize_[3]);
      this.oldWindowSize_ = null;
    }
  }
};


/**
 * Shared runtime object.
 * @type {!vr.Runtime}
 * @private
 */
vr.runtime_ = new vr.Runtime(global.document);


/**
 * Whether the plugin is installed.
 * Note that even if installed it may be blocked on first use by the browser.
 * @return {boolean} True if the plugin is installed.
 */
vr.isInstalled = function() {
  return vr.runtime_.isInstalled_;
};


/**
 * Whether the plugin is initialized.
 * @return {boolean} True if the plugin is loaded.
 */
vr.isLoaded = function() {
  return vr.runtime_.isLoaded_;
};


/**
 * Gets the error that occurred during initialization, if any.
 * @return {Error|null} Error object. May contain a 'code' property
 *     corresponding to a value from {@link vr.ErrorCode}.
 * @memberof vr
 */
vr.getError = function() {
  return vr.runtime_.error_;
};


/**
 * Starts loading the plugin and queues a callback that will be called when the
 * plugin is ready.
 *
 * The callback will receive an error object if an error occurred.
 * This error object may have a 'code' property corresponding to
 * {@link vr.ErrorCode}.
 *
 * If the plugin is already initialized the given callback will be called next
 * tick, so it's always safe to use this and assume asynchronicity.
 *
 * @param {function(this:T, Error=)=} opt_callback Callback function.
 * @param {T=} opt_scope Optional callback scope.
 * @template T
 * @memberof vr
 *
 * @example
 * vr.load(function(opt_error) {
 *   if (opt_error) {
 *     // Plugin failed to load for some reason.
 *     switch (opt_error.code) {
 *       case vr.ErrorCode.PLUGIN_NOT_FOUND:
 *         // Plugin was not installed.
 *         break;
 *       case vr.ErrorCode.PLUGIN_BLOCKED:
 *         // Plugin was blocked by the browser - user must enable.
 *         break;
 *       default:
 *         // Some other error?
 *         break;
 *     }
 *     return;
 *   } else {
 *     // Plugin found and ready to use!
 *   }
 * });
 */
vr.load = function(opt_callback, opt_scope) {
  vr.runtime_.load(opt_callback, opt_scope);
};



/**
 * Gets the information of the currently connected HMD device, if any.
 * This is populated on demand by calling {@link vr.pollState}.
 * @return {vr.HmdInfo} HMD info, if any.
 * @memberof vr
 */
vr.getHmdInfo = function() {
  return vr.runtime_.hmdInfo_;
};


/**
 * Resets the current orientation of the headset to be zero.
 * This should be used to compensate for drift when the user has likely come
 * back after not using the HMD for awhile. For example, on page visibility
 * change.
 * @memberof vr
 */
vr.resetHmdOrientation = function() {
  vr.runtime_.dataSource_.resetHmdOrientation();
};


/**
 * Gets the information of the currently connected Sixense device, if any.
 * This is populated on demand by calling {@link vr.pollState}.
 * @return {vr.SixenseInfo} Sixense info, if any.
 * @memberof vr
 */
vr.getSixenseInfo = function() {
  return vr.runtime_.sixenseInfo_;
};


/**
 * Polls active devices and fills in the state structure.
 * This also takes care of dispatching device notifications/etc.
 * @param {!vr.State} state State structure to fill in. This must be created by
 *     the caller and should be cached across calls to prevent extra garbage.
 * @return {boolean} True if the state query was successful.
 * @memberof vr
 *
 * @example
 * // Cache the state object to reduce garbage generation.
 * var state = new vr.State();
 * function frameTick() {
 *   // Poll state at the start of each frame, before rendering.
 *   if (vr.pollState(state)) {
 *     // VR plugin active and state was polled.
 *     // TODO: update camera/controls/etc.
 *   }
 *   // TODO: render with the latest data.
 * };
 */
vr.pollState = function(state) {
  return vr.runtime_.poll(state);
};


/**
 * Detects whether the window is currently fullscreen.
 * @return {boolean} True if in full screen mode.
 * @memberof vr
 */
vr.isFullScreen = function() {
  var runtime = vr.runtime_;
  var element =
      runtime.document_.fullScreenElement ||
      runtime.document_.mozFullScreenElement ||
      runtime.document_.webkitFullscreenElement;
  return !!element;
};


/**
 * Enters full screen mode, moving the window to the Oculus display if present.
 * @return {boolean} True if the window entered fullscreen.
 * @memberof vr
 */
vr.enterFullScreen = function() {
  var runtime = vr.runtime_;

  // Stash current window position.
  runtime.oldWindowSize_ = [
    global.screenX, global.screenY,
    global.outerWidth, global.outerHeight
  ];

  // Move to new position.
  // TODO(benvanik): make this work. I believe the API only works for popups.
  var hmdInfo = runtime.hmdInfo_;
  if (hmdInfo) {
    global.moveTo(hmdInfo.desktopX, hmdInfo.desktopY);
    global.resizeTo(hmdInfo.resolutionHorz, hmdInfo.resolutionVert);
  }

  // Enter fullscreen.
  var requestFullScreen =
      runtime.document_.documentElement.requestFullscreen ||
      runtime.document_.documentElement.mozRequestFullScreen ||
      runtime.document_.documentElement.webkitRequestFullScreen;
  requestFullScreen.call(
      runtime.document_.documentElement, Element.ALLOW_KEYBOARD_INPUT);

  return true;
};


/**
 * Exits fullscreen mode and moves the window back to its original position.
 * @memberof vr
 */
vr.exitFullScreen = function() {
  var runtime = vr.runtime_;

  // Exit fullscreen.
  // The {@link vr.Runtime#fullScreenChange_} handler will move the window back.
  var cancelFullScreen =
      runtime.document_.cancelFullScreen ||
      runtime.document_.mozCancelFullScreen ||
      runtime.document_.webkitCancelFullScreen;
  if (cancelFullScreen) {
    cancelFullScreen.call(runtime.document_);
  }
};


/**
 * Requests an animation frame.
 * @param {!function(this:T)} callback Function to call on the next frame.
 * @param {T=} opt_scope Callback scope.
 * @template T
 * @memberof vr
 */
vr.requestAnimationFrame = function(callback, opt_scope) {
  var raf =
      global.requestAnimationFrame ||
      global.mozRequestAnimationFrame ||
      global.msRequestAnimationFrame ||
      global.oRequestAnimationFrame ||
      global.webkitRequestAnimationFrame;
  if (opt_scope) {
    return raf.call(global, function() {
      return callback.apply(opt_scope, arguments);
    });
  } else {
    return raf.call(global, callback);
  }
};


/**
 * Calls the given function when the DOM is ready for use.
 * @param {!Document} document HTML document.
 * @param {!function(this:T)} callback Callback function.
 * @param {T=} opt_scope Optional callback scope.
 * @template T
 */
vr.waitForDomReady = function(document, callback, opt_scope) {
  if (document.readyState == 'interactive' ||
      document.readyState == 'complete') {
    global.setTimeout(function() {
      callback.call(opt_scope);
    }, 0);
  } else {
    var initialize = function() {
      document.removeEventListener('DOMContentLoaded', initialize, false);
      callback.call(opt_scope);
    };
    document.addEventListener('DOMContentLoaded', initialize, false);
  }
};


/**
 * Logs to the console, if one is present.
 * This should be used for critical debugging messages only, as it has a
 * performance cost.
 * @param {...*} var_args Things to log.
 * @memberof vr
 */
vr.log = function(var_args) {
  if (global.console && global.console.log) {
    global.console.log.apply(global.console, arguments);
  }
};


// TODO(benvanik): move state/info to its own file


/**
 * HMD device info.
 * @param {Array.<number>=} opt_values Device values.
 * @constructor
 */
vr.HmdInfo = function(opt_values) {
  var o = 0;

  /**
   * Name string describing the product: "Oculus Rift DK1", etc.
   * @type {string}
   * @readonly
   */
  this.deviceName = opt_values ?
      opt_values[o++] : 'Mock Device';

  /**
   * Manufacturer name.
   * @type {string}
   * @readonly
   */
  this.deviceManufacturer = opt_values ?
      opt_values[o++] : 'vr.js';

  /**
   * Device version.
   * @type {number}
   * @readonly
   */
  this.deviceVersion = opt_values ?
      parseFloat(opt_values[o++]) : 0;

  /**
   * Desktop coordinate position of the screen (can be negative) along X.
   * @type {number}
   * @readonly
   */
  this.desktopX = opt_values ?
      parseFloat(opt_values[o++]) : 0;

  /**
   * Desktop coordinate position of the screen (can be negative) along Y.
   * @type {number}
   * @readonly
   */
  this.desktopY = opt_values ?
      parseFloat(opt_values[o++]) : 0;

  /**
   * Horizontal resolution of the entire screen, in pixels.
   * @type {number}
   * @readonly
   */
  this.resolutionHorz = opt_values ?
      parseFloat(opt_values[o++]) : 1280;

  /**
   * Vertical resolution of the entire screen, in pixels.
   * @type {number}
   * @readonly
   */
  this.resolutionVert =opt_values ?
      parseFloat(opt_values[o++]) : 800;

  /**
   * Horizontal physical size of the screen, in meters.
   * @type {number}
   * @readonly
   */
  this.screenSizeHorz = opt_values ?
      parseFloat(opt_values[o++]) : 0.14976;

  /**
   * Vertical physical size of the screen, in meters.
   * @type {number}
   * @readonly
   */
  this.screenSizeVert = opt_values ?
      parseFloat(opt_values[o++]) : 0.0936;

  /**
   * Physical offset from the top of the screen to the eye center, in meters.
   * This will usually, but not necessarily be half of
   * {@link vr.HmdInfo#screenSizeVert}.
   * @type {number}
   * @readonly
   */
  this.screenCenterVert = opt_values ?
      parseFloat(opt_values[o++]) : 800 / 2;

  /**
   * Distance from the eye to screen surface, in meters.
   * Useful for calculating FOV and projection.
   * @type {number}
   * @readonly
   */
  this.eyeToScreenDistance = opt_values ?
      parseFloat(opt_values[o++]) : 0.041;

  /**
   * Distance between physical lens centers useful for calculating distortion
   * center.
   * @type {number}
   * @readonly
   */
  this.lensSeparationDistance = opt_values ?
      parseFloat(opt_values[o++]) : 0.0635;

  /**
   * Configured distance between the user's eye centers, in meters.
   * Defaults to 0.0635.
   * @type {number}
   * @readonly
   */
  this.interpupillaryDistance = opt_values ?
      parseFloat(opt_values[o++]) : 0.0635;

  /**
   * Radial distortion correction coefficients.
   * The distortion assumes that the input texture coordinates will be scaled
   * by the following equation:
   *   uvResult = uvInput * (K0 + K1 * uvLength^2 + K2 * uvLength^4)
   * Where uvInput is the UV vector from the center of distortion in direction
   * of the mapped pixel, uvLength is the magnitude of that vector, and uvResult
   * the corresponding location after distortion.
   * @type {!Float32Array}
   * @readonly
   */
  this.distortionK = new Float32Array(opt_values ? [
    parseFloat(opt_values[o++]), parseFloat(opt_values[o++]),
    parseFloat(opt_values[o++]), parseFloat(opt_values[o++])
  ] : [1.0, 0.22, 0.24, 0]);

  /**
   * Additional per-channel scaling is applied after distortion:
   * Index [0] - Red channel constant coefficient.
   * Index [1] - Red channel r^2 coefficient.
   * Index [2] - Blue channel constant coefficient.
   * Index [3] - Blue channel r^2 coefficient.
   * @type {!Float32Array}
   * @readonly
   */
  this.chromaAbCorrection = new Float32Array(opt_values ? [
    parseFloat(opt_values[o++]), parseFloat(opt_values[o++]),
    parseFloat(opt_values[o++]), parseFloat(opt_values[o++])
  ] : [1, 0, 1, 0]);
};


/**
 * Gets a human readable string describing the device.
 * @return {string} String.
 */
vr.HmdInfo.prototype.toString = function() {
  return this.deviceName + ' v' + this.deviceVersion +
      ' (' + this.deviceManufacturer + ')';
};


/**
 * Distorts the given value the same way the shader would.
 * @param {number} r Value to distort.
 * @return {number} Distorted value.
 */
vr.HmdInfo.prototype.distort = function(r) {
  var rsq = r * r;
  var K = this.distortionK;
  return r * (K[0] + K[1] * rsq + K[2] * rsq * rsq + K[3] * rsq * rsq * rsq);
};


/**
 * Default HMD info.
 * Do not modify.
 * @type {!vr.HmdInfo}
 */
vr.HmdInfo.DEFAULT = new vr.HmdInfo();



/**
 * HMD state data.
 * @constructor
 */
vr.HmdState = function() {
  /**
   * Whether any HMD data is present in this state update.
   * Do not use any other values on this type if this is false.
   * @type {boolean}
   * @readonly
   */
  this.present = false;

  /**
   * Rotation quaternion.
   * @type {!Float32Array}
   * @readonly
   */
  this.rotation = new Float32Array(4);
};



/**
 * Bitmask values for the sixense controller buttons field.
 * @enum {number}
 * @memberof vr
 */
vr.SixenseButton = {
  NONE: 0,
  BUTTON_START: 1 << 0,
  BUTTON_1: 1 << 5,
  BUTTON_2: 1 << 6,
  BUTTON_3: 1 << 3,
  BUTTON_4: 1 << 4,
  BUMPER: 1 << 7,
  JOYSTICK: 1 << 8
};


/**
 * Possible values of the sixense controller hand.
 * @enum {number}
 * @memberof vr
 */
vr.SixenseHand = {
  /** Hand has not yet been determined. */
  UNKNOWN: 0,
  /** Controller is in the left hand. */
  LEFT: 1,
  /** Controller is in the right hand. */
  RIGHT: 2
};



/**
 * Sixense device info.
 * @param {Array.<number>=} opt_values Device values.
 * @constructor
 */
vr.SixenseInfo = function(opt_values) {
};



/**
 * Sixense state data.
 * @constructor
 */
vr.SixenseState = function() {
  /**
   * Whether any sixense data is present in this state update.
   * Do not use any other values on this type if this is false.
   * @type {boolean}
   * @readonly
   */
  this.present = false;

  /**
   * Connected controllers.
   * @type {!Array.<!vr.SixenseControllerState>}
   * @readonly
   */
  this.controllers = [
    new vr.SixenseControllerState(),
    new vr.SixenseControllerState()
  ];
};



/**
 * Sixense controller state data.
 * @constructor
 */
vr.SixenseControllerState = function() {
  /**
   * Position XYZ.
   * @type {!Float32Array}
   * @readonly
   */
  this.position = new Float32Array(3);

  /**
   * Rotation quaternion.
   * @type {!Float32Array}
   * @readonly
   */
  this.rotation = new Float32Array(4);

  /**
   * Joystick XY.
   * @type {!Float32Array}
   * @readonly
   */
  this.joystick = new Float32Array(2);

  /**
   * Trigger press value [0-1].
   * @type {number}
   * @readonly
   */
  this.trigger = 0.0;

  /**
   * A bitmask of {@link vr.SixenseButton} values indicating which buttons
   * are currently pressed.
   * @type {number}
   * @readonly
   */
  this.buttons = vr.SixenseButton.NONE;

  /**
   * Whether the controller is docked in the station.
   * Make the user place the controllers in the dock to get this value.
   * @type {boolean}
   * @readonly
   */
  this.isDocked = false;

  /**
   * The hand the controller represents, if it has been set.
   * Make the user place the controllers in the dock to get this value.
   * @type {vr.SixenseHand}
   * @readonly
   */
  this.hand = vr.SixenseHand.UNKNOWN;

  /**
   * Whether hemisphere tracking is enabled.
   * Make the user place the controllers in the dock to get this value.
   * @type {boolean}
   * @readonly
   */
  this.isTrackingHemispheres = false;
};



/**
 * VR state object.
 * This should be created and cached to enable efficient updates.
 * @constructor
 */
vr.State = function() {
  /**
   * Sixense state.
   * @type {!vr.SixenseState}
   * @readonly
   */
  this.sixense = new vr.SixenseState();

  /**
   * HMD state.
   * @type {!vr.HmdState}
   * @readonly
   */
  this.hmd = new vr.HmdState();
};


// TODO(benvanik): move math to its own file


/**
 * @namespace vr.mat4f
 */
vr.mat4f = {};


/**
 * Simple 4x4 float32 matrix storage type.
 * @typedef {!Float32Array}
 * @memberof vr.mat4f
 *
 * @example
 * [ m00 m01 m02 m03    [  0  1  2  3
 *   m10 m11 m12 m13       4  5  6  7
 *   m20 m21 m22 m23       8  9 10 11
 *   m30 m31 m32 m33 ]    12 13 14 15 ]
 */
vr.mat4f.Type;


/**
 * Creates a matrix object.
 * @return {!vr.mat4f.Type} Matrix.
 * @memberof vr.mat4f
 */
vr.mat4f.create = function() {
  return new Float32Array(16);
};


/**
 * Makes an identity matrix.
 * @param {!vr.mat4f.Type} v Destination matrix.
 * @memberof vr.mat4f
 */
vr.mat4f.makeIdentity = function(v) {
  v[0] = v[5] = v[10] = v[15] = 1;
  v[1] = v[2] = v[3] = v[4] = v[6] = v[7] = v[8] = v[9] = v[11] =
      v[12] = v[13] = v[14] = 0;
};


/**
 * Makes a translation matrix.
 * @param {!vr.mat4f.Type} v Destination matrix.
 * @param {number} x Translation along X.
 * @param {number} y Translation along Y.
 * @param {number} z Translation along Z.
 * @memberof vr.mat4f
 */
vr.mat4f.makeTranslation = function(v, x, y, z) {
  v[0] = v[5] = v[10] = v[15] = 1;
  v[1] = v[2] = v[3] = v[4] = v[6] = v[7] = v[8] = v[9] = v[11] = 0;
  v[12] = x;
  v[13] = y;
  v[14] = z;
};


/**
 * Makes a matrix describing a rectangle.
 * @param {!vr.mat4f.Type} v Destination matrix.
 * @param {number} x Rectangle X.
 * @param {number} y Rectangle Y.
 * @param {number} w Rectangle width.
 * @param {number} h Rectangle height.
 * @memberof vr.mat4f
 */
vr.mat4f.makeRect = function(v, x, y, w, h) {
  v[0] = w;
  v[5] = h;
  v[10] = v[15] = 1;
  v[1] = v[2] = v[3] = v[4] = v[6] = v[7] = v[8] = v[9] = v[11] = v[14] = 0;
  v[12] = x;
  v[13] = y;
};


/**
 * Makes a perspective projection matrix.
 * @param {!vr.mat4f.Type} v Destination matrix.
 * @param {number} fovy FOV along Y.
 * @param {number} aspect Aspect ratio.
 * @param {number} near Near plane distance.
 * @param {number} far Far plane distance.
 * @memberof vr.mat4f
 */
vr.mat4f.makePerspective = function(v, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2);
  var nf = 1 / (near - far);
  v[0] = f / aspect;
  v[1] = v[2] = v[3] = v[4] = 0;
  v[5] = f;
  v[6] = v[7] = v[8] = v[9] = 0;
  v[10] = (far + near) * nf;
  v[11] = -1;
  v[12] = v[13] = 0;
  v[14] = (2 * far * near) * nf;
  v[15] = 0;
};


/**
 * Multiples matrices a and b in order and stores the result in v.
 * @param {!vr.mat4f.Type} v Destination matrix.
 * @param {!vr.mat4f.Type} a LHS matrix.
 * @param {!vr.mat4f.Type} b RHS matrix.
 * @memberof vr.mat4f
 */
vr.mat4f.multiply = function(v, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0, b1, b2, b3;
  b0 = b[0]; b1 = b[1]; b2 = b[2]; b3 = b[3];
  v[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  v[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  v[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  v[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  v[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  v[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  v[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  v[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  v[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  v[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  v[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  v[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  v[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  v[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  v[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  v[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
};



// TODO(benvanik): move webgl to its own file

/**
 * WebGL program object.
 * Designed to support async compilation/linking.
 * When creating many programs first call {@link vr.Program#beginLinking} on all
 * of them followed by a {@link vr.Program#endLinking} on all of them.
 * @param {!WebGLRenderingContext} gl WebGL context.
 * @param {string} displayName Debug name.
 * @param {string} vertexShaderSource Vertex shader source.
 * @param {string} fragmentShaderSource Fragment shader source.
 * @param {!Array.<string>} attributeNames A list of attribute names.
 * @param {!Array.<string>} uniformNames A list of uniform names.
 * @constructor
 *
 * @example
 * var program = new vr.Program(gl, 'MyShader',
 *     'vertex shader source', 'fragment shader source',
 *     ['attribute1', 'attribute2'],
 *     ['uniform1', 'uniform2']);
 * program.beginLinking();
 * program.endLinking();
 * function render() {
 *   program.use();
 *   gl.enableVertexAttribArray(program.attributes['attribute1']);
 *   gl.enableVertexAttribArray(program.attributes['attribute2']);
 *   gl.uniform1f(program.uniforms['uniform1'], 1);
 *   gl.uniform1f(program.uniforms['uniform2'], 2);
 *   // Draw/etc.
 * };
 *
 * @example <caption>Asynchronous compilation/linking.</caption>
 * // Create all programs. This is cheap.
 * var programs = [new vr.Program(...), new vr.Program(...), ...];
 *
 * // Begin compilation/linking.
 * for (var n = 0; n < programs.length; n++) {
 *   programs[n].beginLinking();
 * }
 *
 * // Perform other loading/uploads/etc.
 * // TODO: your loading code.
 *
 * // End compilation/linking and generate any errors.
 * for (var n = 0; n < programs.length; n++) {
 *   try {
 *     programs[n].endLinking();
 *   } catch (e) {
 *     // Handle any compilation/link errors here.
 *   }
 * }
 */
vr.Program = function(gl, displayName,
    vertexShaderSource, fragmentShaderSource,
    attributeNames, uniformNames) {
  /**
   * WebGL context.
   * @type {!WebGLRenderingContext}
   * @private
   */
  this.gl_ = gl;

  /**
   * Attribute names to locations.
   * @type {!Object.<number>}
   * @readonly
   */
  this.attributes = {};
  for (var n = 0; n < attributeNames.length; n++) {
    this.attributes[attributeNames[n]] = -1;
  }

  /**
   * Uniform names to locations.
   * @type {!Object.<!WebGLUniformLocation>}
   * @readonly
   */
  this.uniforms = {};
  for (var n = 0; n < uniformNames.length; n++) {
    this.uniforms[uniformNames[n]] = null;
  }

  /**
   * WebGL program object.
   * @type {!WebGLProgram}
   * @private
   */
  this.program_ = gl.createProgram();
  this.program_.displayName = displayName;

  // Create shaders and attach to program.
  // The program retains them and we no longer need them.
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  vertexShader.displayName = displayName + ':VS';
  gl.shaderSource(vertexShader, vertexShaderSource);
  gl.attachShader(this.program_, vertexShader);
  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  fragmentShader.displayName = displayName + ':FS';
  gl.shaderSource(fragmentShader, fragmentShaderSource);
  gl.attachShader(this.program_, fragmentShader);
};


/**
 * Disposes the object.
 */
vr.Program.prototype.dispose = function() {
  var gl = this.gl_;
  gl.deleteProgram(this.program_);
};


/**
 * Compiles the shaders and begins linking.
 * This must be followed by a call to {@link vr.Program#endLinking}.
 * Shader/program errors will not be queried until then.
 */
vr.Program.prototype.beginLinking = function() {
  var gl = this.gl_;
  var shaders = gl.getAttachedShaders(this.program_);
  for (var n = 0; n < shaders.length; n++) {
    gl.compileShader(shaders[n]);
  }
  gl.linkProgram(this.program_);
};


/**
 * Links the program and throws on any compile/link errors.
 */
vr.Program.prototype.endLinking = function() {
  var gl = this.gl_;

  // Gather shader compilation errors/warnings.
  var shaders = gl.getAttachedShaders(this.program_);
  for (var n = 0; n < shaders.length; n++) {
    var shaderName = shaders[n].displayName;
    var shaderInfoLog = gl.getShaderInfoLog(shaders[n]);
    var compiled = !!gl.getShaderParameter(shaders[n], gl.COMPILE_STATUS);
    if (!compiled) {
      // Error.
      throw 'Shader ' + shaderName + ' compilation errors:\n' +
          shaderInfoLog;
    } else if (shaderInfoLog && shaderInfoLog.length) {
      // Warning.
      vr.log('Shader ' + shaderName + ' compilation warnings:\n' +
          shaderInfoLog);
    }
  }

  // Gather link errors/warnings.
  var programName = this.program_.displayName;
  var programInfoLog = gl.getProgramInfoLog(this.program_);
  var linked = !!gl.getProgramParameter(this.program_, gl.LINK_STATUS);
  if (!linked) {
    // Error.
    throw 'Program ' + programName + ' link errors:\n' +
        programInfoLog;
  } else if (programInfoLog && programInfoLog.length) {
    // Warning.
    vr.log('Program ' + programName + ' link warnings:\n' +
        programInfoLog);
  }

  // Grab attribute/uniform locations.
  for (var attribName in this.attributes) {
    this.attributes[attribName] =
        gl.getAttribLocation(this.program_, attribName);
  }
  for (var uniformName in this.uniforms) {
    this.uniforms[uniformName] =
        gl.getUniformLocation(this.program_, uniformName);
  }
};


/**
 * Uses the program on the current GL context.
 */
vr.Program.prototype.use = function() {
  this.gl_.useProgram(this.program_);
};




// TODO(benvanik): move stereo eye/params its own file


/**
 * An eye.
 * Contains matrices used when rendering the viewport.
 *
 * You should not create this directly. Instead, use the
 * {@link vr.StereoParams#getEyes} to get eyes that have their information
 * updated automatically.
 *
 * @param {number} left Left, in [0-1] view coordinates.
 * @param {number} top Top, in [0-1] view coordinates.
 * @param {number} width Width, in [0-1] view coordinates.
 * @param {number} height Height, in [0-1] view coordinates.
 * @constructor
 */
vr.StereoEye = function(left, top, width, height) {
  /**
   * 2D viewport used when compositing, in [0-1] view coordinates.
   * Stored as [left, top, width, height].
   * @type {!Array.<number>}
   * @readonly
   */
  this.viewport = [left, top, width, height];

  /**
   * Eye-specific distortion center X.
   * @type {number}
   * @readonly
   */
  this.distortionCenterOffsetX = 0;

  /**
   * Eye-specific distortion center Y.
   * @type {number}
   * @readonly
   */
  this.distortionCenterOffsetY = 0;

  /**
   * Matrix used for drawing 3D things.
   * @type {!vr.mat4f.Type}
   * @readonly
   */
  this.projectionMatrix = new Float32Array(16);

  /**
   * Translation to be applied to the view matrix.
   * @type {!vr.mat4f.Type}
   * @readonly
   */
  this.viewAdjustMatrix = new Float32Array(16);

  /**
   * Matrix used for drawing 2D things, like HUDs.
   * @type {!vr.mat4f.Type}
   * @readonly
   */
  this.orthoProjectionMatrix = new Float32Array(16);
};



/**
 * Stereo rendering parameters.
 *
 * You should not create this directly. Instead, use
 * {@link vr.StereoRenderer#getParams} to get an instance that is kept up to
 * date auotmatically.
 *
 * @constructor
 */
vr.StereoParams = function() {
  /**
   * Near plane Z.
   * @type {number}
   * @private
   */
  this.zNear_ = 0.01;

  /**
   * Far plane Z.
   * @type {number}
   * @private
   */
  this.zFar_ = 1000;

  /**
   * Overridden IPD from the device.
   * If this is undefined the value from the HMD info will be used instead.
   * @type {number|undefined}
   * @private
   */
  this.interpupillaryDistance_ = undefined;

  /**
   * Scale by which the input render texture is scaled by to make the
   * post-distortion result fit the viewport.
   * @type {number}
   * @private
   */
  this.distortionScale_ = 1;

  // Constants for now.
  this.distortionFitX_ = -1;
  this.distortionFitY_ = 0;

  /**
   * Eyes.
   * Each eye contains the matrices and bounding data used when rendering.
   * @type {!Array.<!vr.StereoEye>}
   * @private
   */
  this.eyes_ = [
    new vr.StereoEye(0, 0, 0.5, 1),
    new vr.StereoEye(0.5, 0, 0.5, 1)
  ];

  /**
   * Cached matrices used for temporary math.
   * @type {!Array.<!vr.mat4f>}
   * @private
   */
  this.tmpMat4s_ = [vr.mat4f.create(), vr.mat4f.create()];
};


/**
 * Sets the value of the near Z plane.
 * @param {number} value New value.
 */
vr.StereoParams.prototype.setZNear = function(value) {
  this.zNear_ = value;
};


/**
 * Sets the value of the far Z plane.
 * @param {number} value New value.
 */
vr.StereoParams.prototype.setZFar = function(value) {
  this.zFar_ = value;
};


/**
 * Gets the current value of the interpupillary distance, if overriden.
 * @return {number|undefined} Current value or undefined if not set.
 */
vr.StereoParams.prototype.getInterpupillaryDistance = function() {
  return this.interpupillaryDistance_;
};


/**
 * Sets the value of the interpupillary distance override.
 * Use a value of undefined to clear the override and use device defaults.
 * @param {number|undefined} value New value or undefined to disable override.
 */
vr.StereoParams.prototype.setInterpupillaryDistance = function(value) {
  this.interpupillaryDistance_ = value;
};


/**
 * Gets the distortion scale.
 * The data in the eyes must be updated for the frame with a call to
 * {@link vr.StereoParams#update}.
 * @return {number} Distortion scale.
 */
vr.StereoParams.prototype.getDistortionScale = function() {
  return this.distortionScale_;
};


/**
 * Gets a list of eyes.
 * The data in the eyes must be updated for the frame with a call to
 * {@link vr.StereoParams#update}.
 * @return {!Array.<!vr.StereoEye>}
 */
vr.StereoParams.prototype.getEyes = function() {
  return [this.eyes_[0], this.eyes_[1]];
};


/**
 * Updates the stereo parameters with the given HMD data.
 * @param {!vr.HmdInfo} info HMD info.
 */
vr.StereoParams.prototype.update = function(info) {
  var interpupillaryDistance = info.interpupillaryDistance;
  if (this.interpupillaryDistance_ !== undefined) {
    interpupillaryDistance = this.interpupillaryDistance_;
  }

  // -- updateDistortionOffsetAndScale --

  var lensOffset = info.lensSeparationDistance / 2;
  var lensShift = info.screenSizeHorz / 4 - lensOffset;
  var lensViewportShift = 4 * lensShift / info.screenSizeHorz;
  var distortionCenterOffsetX = lensViewportShift;
  if (Math.abs(this.distortionFitX_) < 0.0001 &&
      Math.abs(this.distortionFitY_) < 0.0001) {
    this.distortionScale_ = 1;
  } else {
    var stereoAspect = info.resolutionHorz / info.resolutionVert / 2;
    var dx = this.distortionFitX_ - distortionCenterOffsetX;
    var dy = this.distortionFitY_ / stereoAspect;
    var fitRadius = Math.sqrt(dx * dx + dy * dy);
    this.distortionScale_ = info.distort(fitRadius) / fitRadius;
  }

  // -- updateComputedState --

  var percievedHalfRTDistance = info.screenSizeVert / 2 * this.distortionScale_;
  var fovY = 2 * Math.atan(percievedHalfRTDistance / info.eyeToScreenDistance);

  // -- updateProjectionOffset --

  var viewCenter = info.screenSizeHorz / 4;
  var eyeProjectionShift = viewCenter - info.lensSeparationDistance / 2;
  var projectionCenterOffset = 4 * eyeProjectionShift / info.screenSizeHorz;

  // -- update2D --
  var metersToPixels = (info.resolutionHorz / info.screenSizeHorz);
  var lensDistanceScreenPixels = metersToPixels * info.lensSeparationDistance;
  var eyeDistanceScreenPixels = metersToPixels * interpupillaryDistance;
  var offCenterShiftPixels =
      (info.eyeToScreenDistance / 0.8) * eyeDistanceScreenPixels;
  var leftPixelCenter =
      (info.resolutionHorz / 2) - lensDistanceScreenPixels / 2;
  var rightPixelCenter = lensDistanceScreenPixels / 2;
  var pixelDifference = leftPixelCenter - rightPixelCenter;
  var area2dfov = 85 * Math.PI / 180;
  var percievedHalfScreenDistance =
      Math.tan(area2dfov / 2) * info.eyeToScreenDistance;
  var vfovSize = 2.0 * percievedHalfScreenDistance / this.distortionScale_;
  var fovPixels = info.resolutionVert * vfovSize / info.screenSizeVert;
  var orthoPixelOffset =
      (pixelDifference + offCenterShiftPixels / this.distortionScale_) / 2;
  orthoPixelOffset = orthoPixelOffset * 2 / fovPixels;

  // -- updateEyeParams --
  var eyeL = this.eyes_[0];
  var eyeR = this.eyes_[1];

  eyeL.distortionCenterOffsetX = distortionCenterOffsetX;
  eyeL.distortionCenterOffsetY = 0;
  eyeR.distortionCenterOffsetX = -distortionCenterOffsetX;
  eyeR.distortionCenterOffsetY = 0;

  vr.mat4f.makeIdentity(eyeL.viewAdjustMatrix);
  eyeL.viewAdjustMatrix[12] = -interpupillaryDistance / 2;
  vr.mat4f.makeIdentity(eyeR.viewAdjustMatrix);
  eyeR.viewAdjustMatrix[12] = interpupillaryDistance / 2;

  // eye proj = proj offset * proj center
  var projMatrix = this.tmpMat4s_[0];
  var projOffsetMatrix = this.tmpMat4s_[1];
  var aspect = info.resolutionHorz / info.resolutionVert / 2;
  vr.mat4f.makePerspective(projMatrix, fovY, aspect, this.zNear_, this.zFar_);
  vr.mat4f.makeTranslation(projOffsetMatrix, projectionCenterOffset, 0, 0);
  vr.mat4f.multiply(eyeL.projectionMatrix, projOffsetMatrix, projMatrix);
  vr.mat4f.makeTranslation(projOffsetMatrix, -projectionCenterOffset, 0, 0);
  vr.mat4f.multiply(eyeR.projectionMatrix, projOffsetMatrix, projMatrix);

  // eye ortho = ortho center * ortho offset
  var orthoMatrix = this.tmpMat4s_[0];
  var orthoOffsetMatrix = this.tmpMat4s_[1];
  vr.mat4f.makeIdentity(orthoMatrix);
  orthoMatrix[0] = fovPixels / (info.resolutionHorz / 2);
  orthoMatrix[5] = -fovPixels / info.resolutionVert;
  vr.mat4f.makeTranslation(orthoOffsetMatrix, orthoPixelOffset, 0, 0);
  vr.mat4f.multiply(eyeL.orthoProjectionMatrix, orthoMatrix, orthoOffsetMatrix);
  vr.mat4f.makeTranslation(orthoOffsetMatrix, -orthoPixelOffset, 0, 0);
  vr.mat4f.multiply(eyeR.orthoProjectionMatrix, orthoMatrix, orthoOffsetMatrix);
};



// TODO(benvanik): move stereo renderer to its own file


/**
 * The post processing mode to use when rendering each eye.
 * @enum {number}
 * @memberof vr
 */
vr.PostProcessingMode = {
  /**
   * Straight pass-through with no distortion.
   */
  STRAIGHT: 0,
  /**
   * Distort for lens correction.
   */
  WARP: 1,
  /**
   * Distort and also apply chromatic aberration correction.
   */
  WARP_CHROMEAB: 2
};


/**
 * Stereo rendering controller.
 * Responsible for setting up stereo rendering and drawing the scene each frame.
 * @param {!WebGLRenderingContext} gl GL context.
 * @param {vr.StereoRenderer.Attributes=} opt_attributes Render target
 *     attributes.
 * @constructor
 *
 * @example
 * // Create a renderer with just a depth channel.
 * var stereoRenderer = new vr.StereoRenderer(gl, {
 *   alpha: false,
 *   depth: true,
 *   stencil: false
 * });
 * var state = new vr.State();
 * function renderScene() {
 *   vr.pollState(state);
 *   // TODO: process camera/controls/etc.
 *   stereoRenderer.render(state, function(eye) {
 *     // Compute the model-view matrix from the camera and the eye view adjust.
 *     var modelViewMatrix = mat4.clone(camera.modelViewMatrix);
 *     mat4.multiply(modelViewMatrix, eye.viewAdjustMatrix, modelViewMatrix);
 *     // Render using the eye projection matrix and the new model-view matrix.
 *     renderMyScene(eye.projectionMatrix, modelViewMatrix);
 *   });
 * };
 */
vr.StereoRenderer = function(gl, opt_attributes) {
  /**
   * WebGL context.
   * @type {!WebGLRenderingContext}
   * @private
   */
  this.gl_ = gl;

  /**
   * Render target attributes.
   * Values may be omitted.
   * @type {!vr.StereoRenderer.Attributes}
   * @private
   */
  this.attributes_ = opt_attributes || {};

  /**
   * Whether the renderer has been initialized yet.
   * Invalid to draw if this is false.
   * @type {boolean}
   * @private
   */
  this.isInitialized_ = false;

  /**
   * Whether a real HMD is present.
   * @type {boolean}
   * @private
   */
  this.hmdPresent_ = false;

  /**
   * Current HMD info.
   * If no HMD is present this is set to the default info used for testing.
   * @type {!vr.HmdInfo}
   * @private
   */
  this.hmdInfo_ = new vr.HmdInfo();

  /**
   * 2D quad data buffer.
   * @type {!WebGLBuffer}
   * @private
   */
  this.quadBuffer_ = gl.createBuffer();
  this.quadBuffer_.displayName = 'vr.StereoRendererQuad';
  var previousBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
  gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer_);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0, 0, 0, // TL   x-x
    1, 0, 1, 0, // TR   |/
    0, 1, 0, 1, // BL   x
    1, 0, 1, 0, // TR     x
    1, 1, 1, 1, // BR    /|
    0, 1, 0, 1  // BL   x-x
  ]), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, previousBuffer);

  /**
   * Straight pass-through program.
   * Does not distort the eyes as they are rendered.
   * @type {!vr.Program}
   * @private
   */
  this.straightProgram_ = new vr.Program(gl,
      'vr.StereoRendererStraight',
      vr.StereoRenderer.PROGRAM_VERTEX_SOURCE_,
      vr.StereoRenderer.STRAIGHT_FRAGMENT_SOURCE_,
      vr.StereoRenderer.PROGRAM_ATTRIBUTE_NAMES_,
      vr.StereoRenderer.PROGRAM_UNIFORM_NAMES_);

  /**
   * Warp program.
   * Draws a single eye distored to a render target.
   * @type {!vr.Program}
   * @private
   */
  this.warpProgram_ = new vr.Program(gl,
      'vr.StereoRendererWarp',
      vr.StereoRenderer.PROGRAM_VERTEX_SOURCE_,
      vr.StereoRenderer.WARP_FRAGMENT_SOURCE_,
      vr.StereoRenderer.PROGRAM_ATTRIBUTE_NAMES_,
      vr.StereoRenderer.PROGRAM_UNIFORM_NAMES_);

  /**
   * Warp program with chromatic aberration correction.
   * Draws a single eye distored to a render target.
   * @type {!vr.Program}
   * @private
   */
  this.warpChromeAbProgram_ = new vr.Program(gl,
      'vr.StereoRendererWarpChromeAb',
      vr.StereoRenderer.PROGRAM_VERTEX_SOURCE_,
      vr.StereoRenderer.WARP_CHROMEAB_FRAGMENT_SOURCE_,
      vr.StereoRenderer.PROGRAM_ATTRIBUTE_NAMES_,
      vr.StereoRenderer.PROGRAM_UNIFORM_NAMES_);

  /**
   * Current post processing mode.
   * Updated by {@link vr.StereoRenderer#setPostProcessingMode}.
   * @type {vr.PostProcessingMode}
   * @private
   */
  this.postProcessingMode_ = vr.PostProcessingMode.WARP_CHROMEAB;

  /**
   * Current post processing program.
   * Updated by {@link vr.StereoRenderer#setPostProcessingMode}.
   * @type {!vr.Program}
   * @private
   */
  this.postProcessingProgram_ = this.warpChromeAbProgram_;

  /**
   * Whether all uniform values need to be updated for the program.
   * This is used to prevent some redundant uniform calls for values that don't
   * change frequently.
   * @type {boolean}
   * @private
   */
  this.updateAllUniforms_ = true;

  /**
   * Framebuffer used for drawing the scene.
   * Managed by {@link vr.StereoRenderer#initialize_}.
   * @type {!WebGLFramebuffer}
   * @private
   */
  this.framebuffer_ = gl.createFramebuffer();
  this.framebuffer_.displayName = 'vr.StereoRendererFB';

  /**
   * Renderbuffers attached to the framebuffer, excluding the render texture.
   * Makes for easier cleanup.
   * @type {!Array.<!WebGLRenderbuffer>}
   * @private
   */
  this.framebufferAttachments_ = [];

  /**
   * The width of the render target used for drawing the scene.
   * Managed by {@link vr.StereoRenderer#initialize_}.
   * @type {number}
   * @private
   */
  this.renderTargetWidth_ = 0;

  /**
   * The height of the render target used for drawing the scene.
   * Managed by {@link vr.StereoRenderer#initialize_}.
   * @type {number}
   * @private
   */
  this.renderTargetHeight_ = 0;

  /**
   * Render texture used for drawing the scene.
   * Managed by {@link vr.StereoRenderer#initialize_}.
   * @type {!WebGLTexture}
   * @private
   */
  this.renderTexture_ = gl.createTexture();
  this.renderTexture_.displayName = 'vr.StereoRendererRT';

  /**
   * Stereo parameters.
   * These may change at any time, and should be verified each update.
   * @type {!StereoParams}
   * @private
   */
  this.stereoParams_ = new vr.StereoParams();

  /**
   * Cached matrix used for temporary math.
   * @type {!vr.mat4f.Type}
   * @private
   */
  this.tmpMat4_ = vr.mat4f.create();

  // TODO(benvanik): only link the programs required.
  // TODO(benvanik): all programs async.
  var programs = [
    this.straightProgram_,
    this.warpProgram_,
    this.warpChromeAbProgram_
  ];
  for (var n = 0; n < programs.length; n++) {
    programs[n].beginLinking();
  }
  for (var n = 0; n < programs.length; n++) {
    programs[n].endLinking();
  }

  // Startup with default options.
  this.initialize_();
};


/**
 * Render target attributes.
 * @typedef {Object}
 * @property {boolean|undefined} alpha Whether an alpha channel is required.
 * @property {boolean|undefined} depth Whether an depth channel is required.
 * @property {boolean|undefined} stencil Whether an stencil channel is required.
 */
vr.StereoRenderer.Attributes;


/**
 * The render target used for rendering the scene will be this much larger
 * than the HMD's resolution, to compensate for the resolution loss from the
 * warping shader.
 * @type {number}
 * @const
 * @private
 */
vr.StereoRenderer.RENDER_TARGET_SCALE_ = 2;


/**
 * Disposes the object.
 */
vr.StereoRenderer.prototype.dispose = function() {
  var gl = this.gl_;
  for (var n = 0; n < this.framebufferAttachments_.length; n++) {
    gl.deleteRenderbuffer(this.framebufferAttachments_[n]);
  }
  gl.deleteTexture(this.renderTexture_);
  gl.deleteFramebuffer(this.framebuffer_);
  gl.deleteBuffer(this.quadBuffer_);
  if (this.straightProgram_) {
    this.straightProgram_.dispose();
  }
  if (this.warpProgram_) {
    this.warpProgram_.dispose();
  }
  if (this.warpChromeAbProgram_) {
    this.warpChromeAbProgram_.dispose();
  }
};


/**
 * Gets the parameters used for stereo rendering.
 * @return {!vr.StereoParams} Stereo params.
 */
vr.StereoRenderer.prototype.getParams = function() {
  return this.stereoParams_;
};


/**
 * Gets the current post-processing mode.
 * @return {vr.PostProcessingMode} Post-processing mode.
 */
vr.StereoRenderer.prototype.getPostProcessingMode = function() {
  return this.postProcessingMode_;
};


/**
 * Switches the post-processing mode.
 * @param {vr.PostProcessingMode} value New mode.
 */
vr.StereoRenderer.prototype.setPostProcessingMode = function(value) {
  if (value == this.postProcessingMode_) {
    return;
  }
  this.updateAllUniforms_ = true;
  this.postProcessingMode_ = value;
  switch (value) {
    case vr.PostProcessingMode.STRAIGHT:
      this.postProcessingProgram_ = this.straightProgram_;
      break;
    case vr.PostProcessingMode.WARP:
      this.postProcessingProgram_ = this.warpProgram_;
      break;
    default:
    case vr.PostProcessingMode.WARP_CHROMEAB:
      this.postProcessingProgram_ = this.warpChromeAbProgram_;
      break;
  }
};


/**
 * Initializes the renderer when the HMD changes.
 * @private
 */
vr.StereoRenderer.prototype.initialize_ = function() {
  var gl = this.gl_;
  var info = this.hmdInfo_;

  // Only resize if required.
  if (gl.canvas.width != info.resolutionHorz) {
    // Resize canvas to HMD resolution.
    // Also ensure device pixel size is 1:1.
    gl.canvas.width = info.resolutionHorz;
    gl.canvas.height = info.resolutionVert;
    gl.canvas.style.width = gl.canvas.width + 'px';
    gl.canvas.style.height = gl.canvas.height + 'px';
  }

  // Resize framebuffer and validate.
  this.setupRenderTarget_(
      info.resolutionHorz * vr.StereoRenderer.RENDER_TARGET_SCALE_,
      info.resolutionVert * vr.StereoRenderer.RENDER_TARGET_SCALE_);

  // Update program uniforms next render.
  this.updateAllUniforms_ = true;

  this.isInitialized_ = true;
};


/**
 * Sets up the render target for drawing the scene.
 * @param {number} width Render target width.
 * @param {number} height Render target height.
 * @private
 */
vr.StereoRenderer.prototype.setupRenderTarget_ = function(width, height) {
  var gl = this.gl_;

  width = Math.floor(width) || 4;
  height = Math.floor(height) || 4;

  // Ignore redundant setups.
  if (this.renderTargetWidth_ == width &&
      this.renderTargetHeight_ == height) {
    return;
  }

  this.renderTargetWidth_ = width;
  this.renderTargetHeight_ = height;

  var previousFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  var previousRenderbuffer = gl.getParameter(gl.RENDERBUFFER_BINDING);
  var previousTexture2d = gl.getParameter(gl.TEXTURE_BINDING_2D);

  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);

  // Resize texture.
  gl.bindTexture(gl.TEXTURE_2D, this.renderTexture_);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0,
      this.attributes_.alpha ? gl.RGBA : gl.RGB,
      width, height, 0,
      this.attributes_.alpha ? gl.RGBA : gl.RGB,
      gl.UNSIGNED_BYTE, null);

  // Attach color texture.
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
      this.renderTexture_, 0);

  // Cleanup previous attachments.
  for (var n = 0; n < this.framebufferAttachments_.length; n++) {
    gl.deleteRenderbuffer(this.framebufferAttachments_[n]);
  }
  this.framebufferAttachments_ = [];

  // Setup depth/stencil textures.
  var depthBuffer = null;
  if (this.attributes_.depth) {
    depthBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
        width, height);
    this.framebufferAttachments_.push(depthBuffer);
  }
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
      gl.RENDERBUFFER, depthBuffer);
  var stencilBuffer = null;
  if (this.attributes_.stencil) {
    stencilBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencilBuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, width, height);
    this.framebufferAttachments_.push(stencilBuffer);
  }
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT,
      gl.RENDERBUFFER, stencilBuffer);

  // Verify.
  var status = gl.FRAMEBUFFER_COMPLETE;
  // TODO(benvanik): debug only.
  status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  gl.bindFramebuffer(gl.FRAMEBUFFER, previousFramebuffer);
  gl.bindRenderbuffer(gl.RENDERBUFFER, previousRenderbuffer);
  gl.bindTexture(gl.TEXTURE_2D, previousTexture2d);

  if (status != gl.FRAMEBUFFER_COMPLETE) {
    throw 'Invalid framebuffer: ' + status;
  }
};


/**
 * Gets the current interpupillary distance value.
 * @return {number} IPD value.
 */
vr.StereoRenderer.prototype.getInterpupillaryDistance = function() {
  var info = this.hmdInfo_;
  var ipd = this.stereoParams_.getInterpupillaryDistance();
  return (ipd !== undefined) ? ipd : info.interpupillaryDistance;
};


/**
 * Sets a new interpupillary distance value.
 * @param {number} value New IPD value.
 */
vr.StereoRenderer.prototype.setInterpupillaryDistance = function(value) {
  this.stereoParams_.setInterpupillaryDistance(value);
};


/**
 * Updates the stereo data and renders the scene.
 * The given callback is used to perform the render and may be called more than
 * once. It receives the eye to render and the width and height of the render
 * target.
 * @param {function(this:T, !vr.StereoEye, number, number)} callback Callback.
 * @param {T=} opt_scope Scope.
 * @template T
 */
vr.StereoRenderer.prototype.render = function(vrstate, callback, opt_scope) {
  var gl = this.gl_;

  var nowPresent = vrstate.hmd.present;
  if (nowPresent != this.hmdPresent_) {
    this.hmdPresent_ = true;
    if (nowPresent) {
      // HMD connected! Query info.
      this.hmdInfo_ = vr.getHmdInfo();
    } else {
      // Disconnected. Reset to defaults.
      this.hmdInfo_ = new vr.HmdInfo();
    }
    this.initialize_();
  }

  // Update stereo parameters based on VR state.
  this.stereoParams_.update(this.hmdInfo_);

  // Skip drawing if not ready.
  if (!this.isInitialized_) {
    return;
  }

  // Render.
  var eyes = this.stereoParams_.getEyes();
  for (var n = 0; n < eyes.length; n++) {
    var eye = eyes[n];

    // Render to the render target.
    // The user will clear if needed.
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);
    gl.viewport(
        eye.viewport[0] * this.renderTargetWidth_,
        eye.viewport[1] * this.renderTargetHeight_,
        eye.viewport[2] * this.renderTargetWidth_,
        eye.viewport[3] * this.renderTargetHeight_);
    callback.call(opt_scope,
        eye, this.renderTargetWidth_, this.renderTargetHeight_);

    // Distort to the screen.
    // TODO(benvanik): allow the user to specify a render target?
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.renderEye_(eye);
  }

  // User shouldn't be doing anything after this. Flush now.
  gl.flush();
};


/**
 * Renders the given eye to the target framebuffer with distortion.
 * @param {!StereoEye} eye Eye to render.
 * @private
 */
vr.StereoRenderer.prototype.renderEye_ = function(eye) {
  var gl = this.gl_;

  // Source the input texture.
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, this.renderTexture_);

  // Activate program.
  var program = this.postProcessingProgram_;
  program.use();

  // Update all uniforms, if needed.
  if (this.updateAllUniforms_) {
    this.updateAllUniforms_ = false;
    gl.uniform1i(program.uniforms['u_tex0'], 0);
    gl.uniform4fv(program.uniforms['u_hmdWarpParam'],
        this.hmdInfo_.distortionK);
    gl.uniform4fv(program.uniforms['u_chromAbParam'],
        this.hmdInfo_.chromaAbCorrection);
  }

  // Calculate eye uniforms for offset.
  var fullWidth = this.hmdInfo_.resolutionHorz;
  var fullHeight = this.hmdInfo_.resolutionVert;
  var x = eye.viewport[0];
  var y = eye.viewport[1];
  var w = eye.viewport[2];
  var h = eye.viewport[3];
  var aspect = (w * fullWidth) / (h * fullHeight);
  var scale = 1 / this.stereoParams_.getDistortionScale();

  // Texture matrix used to scale the input render target.
  var texMatrix = this.tmpMat4_;
  vr.mat4f.makeRect(texMatrix, x, y, w, h);
  gl.uniformMatrix4fv(program.uniforms['u_texMatrix'], false,
      texMatrix);

  gl.uniform2f(program.uniforms['u_lensCenter'],
      x + (w + eye.distortionCenterOffsetX / 2) / 2, y + h / 2);
  gl.uniform2f(program.uniforms['u_screenCenter'],
      x + w / 2, y + h / 2);
  gl.uniform2f(program.uniforms['u_scale'],
      w / 2 * scale, h / 2 * scale * aspect);
  gl.uniform2f(program.uniforms['u_scaleIn'],
      2 / w, 2 / h / aspect);

  // Viewport (in screen coordinates).
  gl.viewport(x * fullWidth, 0, w * fullWidth, fullHeight);

  // Setup attribs.
  var a_xy = program.attributes.a_xy;
  var a_uv = program.attributes.a_uv;
  gl.enableVertexAttribArray(a_xy);
  gl.enableVertexAttribArray(a_uv);
  gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer_);
  gl.vertexAttribPointer(a_xy, 2, gl.FLOAT, false, 4 * 4, 0);
  gl.vertexAttribPointer(a_uv, 2, gl.FLOAT, false, 4 * 4, 2 * 4);

  // Draw the quad.
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // NOTE: the user must cleanup attributes themselves.
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
};


/**
 * Attribute names for the programs.
 * @type {!Array.<string>}
 * @private
 */
vr.StereoRenderer.PROGRAM_ATTRIBUTE_NAMES_ = [
  'a_xy', 'a_uv'
];


/**
 * Uniform names for the programs. Some may be unused.
 * @type {!Array.<string>}
 * @private
 */
vr.StereoRenderer.PROGRAM_UNIFORM_NAMES_ = [
  'u_texMatrix',
  'u_tex0',
  'u_lensCenter', 'u_screenCenter', 'u_scale', 'u_scaleIn',
  'u_hmdWarpParam', 'u_chromAbParam'
];


/**
 * Source code for the shared vertex shader.
 * @type {string}
 * @const
 * @private
 */
vr.StereoRenderer.PROGRAM_VERTEX_SOURCE_ = [
  'attribute vec2 a_xy;',
  'attribute vec2 a_uv;',
  'varying vec2 v_uv;',
  'uniform mat4 u_texMatrix;',
  'void main() {',
  '  gl_Position = vec4(2.0 * a_xy - 1.0, 0.0, 1.0);',
  '  v_uv = (u_texMatrix * vec4(a_uv, 0.0, 1.0)).xy;',
  '}'
].join('\n');


/**
 * Source code for the warp fragment shader in debug mode.
 * This just passes the texture right through.
 * @type {string}
 * @const
 * @private
 */
vr.StereoRenderer.STRAIGHT_FRAGMENT_SOURCE_ = [
  'precision highp float;',
  'varying vec2 v_uv;',
  'uniform sampler2D u_tex0;',
  'void main() {',
  '  gl_FragColor = texture2D(u_tex0, v_uv);',
  '}'
].join('\n');


/**
 * Source code for the warp fragment shader.
 * @type {string}
 * @const
 * @private
 */
vr.StereoRenderer.WARP_FRAGMENT_SOURCE_ = [
  'precision highp float;',
  'varying vec2 v_uv;',
  'uniform sampler2D u_tex0;',
  'uniform vec2 u_lensCenter;',
  'uniform vec2 u_screenCenter;',
  'uniform vec2 u_scale;',
  'uniform vec2 u_scaleIn;',
  'uniform vec4 u_hmdWarpParam;',
  'vec2 hmdWarp(vec2 texIn) {',
  '  vec2 theta = (texIn - u_lensCenter) * u_scaleIn;',
  '  float rSq = theta.x * theta.x + theta.y * theta.y;',
  '  vec2 theta1 = theta * (u_hmdWarpParam.x + u_hmdWarpParam.y * rSq + ',
  '      u_hmdWarpParam.z * rSq * rSq + u_hmdWarpParam.w * rSq * rSq * rSq);',
  '  return u_lensCenter + u_scale * theta1;',
  '}',
  'void main() {',
  '  vec2 tc = hmdWarp(v_uv);',
  '  if (any(notEqual(clamp(tc, u_screenCenter - vec2(0.25, 0.5), ',
  '      u_screenCenter + vec2(0.25, 0.5)) - tc, vec2(0.0, 0.0)))) {',
  '    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
  '  } else {',
  //'    gl_FragColor = vec4(0.0, tc.xy, 1.0);',
  '    gl_FragColor = texture2D(u_tex0, tc);',
  '  }',
  '}'
].join('\n');


/**
 * Source code for the warp fragment shader that also fixes
 * chromatic aberration.
 * @type {string}
 * @const
 * @private
 */
vr.StereoRenderer.WARP_CHROMEAB_FRAGMENT_SOURCE_ = [
  'precision highp float;',
  'varying vec2 v_uv;',
  'uniform sampler2D u_tex0;',
  'uniform vec2 u_lensCenter;',
  'uniform vec2 u_screenCenter;',
  'uniform vec2 u_scale;',
  'uniform vec2 u_scaleIn;',
  'uniform vec4 u_hmdWarpParam;',
  'uniform vec4 u_chromAbParam;',
  'void main() {',
  '  vec2 theta = (v_uv - u_lensCenter) * u_scaleIn; // Scales to [-1, 1]',
  '  float rSq = theta.x * theta.x + theta.y * theta.y;',
  '  vec2 theta1 = theta * (u_hmdWarpParam.x + u_hmdWarpParam.y * rSq +',
  '      u_hmdWarpParam.z * rSq * rSq +',
  '      u_hmdWarpParam.w * rSq * rSq * rSq);',
  '  vec2 thetaBlue = theta1 * (u_chromAbParam.z + u_chromAbParam.w * rSq);',
  '  vec2 tcBlue = u_lensCenter + u_scale * thetaBlue;',
  '  if (any(notEqual(clamp(tcBlue, u_screenCenter - vec2(0.25, 0.5),',
  '      u_screenCenter + vec2(0.25, 0.5)) - tcBlue, vec2(0.0, 0.0)))) {',
  '    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);',
  '    return;',
  '  }',
  '  vec2 tcGreen = u_lensCenter + u_scale * theta1;',
  '  vec2 thetaRed = theta1 * (u_chromAbParam.x + u_chromAbParam.y * rSq);',
  '  vec2 tcRed = u_lensCenter + u_scale * thetaRed;',
  '  gl_FragColor = vec4(',
  '      texture2D(u_tex0, tcRed).r,',
  '      texture2D(u_tex0, tcGreen).g,',
  '      texture2D(u_tex0, tcBlue).b,',
  '      1);',
  '}'
].join('\n');



/**
 * @global
 * @alias module vr
 */
global.vr = vr;

})(window);
// ShaderParticleGroup 0.5.0
//
// (c) 2013 Luke Moody (http://www.github.com/squarefeet) & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)
//     Based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
//
// ShaderParticleGroup may be freely distributed under the MIT license (See LICENSE.txt)


function ShaderParticleGroup( options ) {
    var that = this;

    that.fixedTimeStep          = parseFloat( options.fixedTimeStep || 0.016 );

    // Uniform properties ( applied to all particles )
    that.maxAge                 = parseFloat( options.maxAge || 3 );
    that.texture                = options.texture || null;
    that.hasPerspective         = parseInt( typeof options.hasPerspective === 'number' ? options.hasPerspective : 1, 10 );
    that.colorize               = parseInt( options.colorize || 1, 10 );

    // Material properties
    that.blending               = typeof options.blending === 'number' ? options.blending : THREE.AdditiveBlending;
    that.transparent            = options.transparent || true;
    that.alphaTest              = options.alphaTest || 0.5;
    that.depthWrite             = options.depthWrite || false;
    that.depthTest              = options.depthTest || true;

    // Create uniforms
    that.uniforms = {
        duration:       { type: 'f', value: that.maxAge },
        texture:        { type: 't', value: that.texture },
        hasPerspective: { type: 'i', value: that.hasPerspective },
        colorize:       { type: 'i', value: that.colorize }
    };

    // Create a map of attributes that will hold values for each particle in this group.
    that.attributes = {
        acceleration:   { type: 'v3', value: [] },
        velocity:       { type: 'v3', value: [] },
        alive:          { type: 'f', value: [] },
        age:            { type: 'f', value: [] },
        size:           { type: 'f', value: [] },
        sizeEnd:        { type: 'f', value: [] },

        customColor:    { type: 'c', value: [] },
        customColorEnd: { type: 'c', value: [] },

        opacity:        { type: 'f', value: [] },
        opacityMiddle:  { type: 'f', value: [] },
        opacityEnd:     { type: 'f', value: [] }
    };

    // Emitters (that aren't static) will be added to this array for
    // processing during the `tick()` function.
    that.emitters = [];

    // Create properties for use by the emitter pooling functions.
    that._pool = [];
    that._poolCreationSettings = null;
    that._createNewWhenPoolEmpty = 0;
    that.maxAgeMilliseconds = that.maxAge * 1000;

    // Create an empty geometry to hold the particles.
    // Each particle is a vertex pushed into this geometry's
    // vertices array.
    that.geometry = new THREE.Geometry();

    // Create the shader material using the properties we set above.
    that.material = new THREE.ShaderMaterial({
        uniforms:       that.uniforms,
        attributes:     that.attributes,
        vertexShader:   ShaderParticleGroup.shaders.vertex,
        fragmentShader: ShaderParticleGroup.shaders.fragment,
        blending:       that.blending,
        transparent:    that.transparent,
        alphaTest:      that.alphaTest,
        depthWrite:     that.depthWrite,
        depthTest:      that.depthTest
    });

    // And finally create the ParticleSystem. It's got its `dynamic` property
    // set so that THREE.js knows to update it on each frame.
    that.mesh = new THREE.ParticleSystem( that.geometry, that.material );
    that.mesh.dynamic = true;
}

ShaderParticleGroup.prototype = {

    /**
     * Given a base vector and a spread range vector, create
     * a new THREE.Vector3 instance with randomised values.
     *
     * @private
     *
     * @param  {THREE.Vector3} base
     * @param  {THREE.Vector3} spread
     * @return {THREE.Vector3}
     */
    _randomVector3: function( base, spread ) {
        var v = new THREE.Vector3();

        v.copy( base );

        v.x += Math.random() * spread.x - (spread.x/2);
        v.y += Math.random() * spread.y - (spread.y/2);
        v.z += Math.random() * spread.z - (spread.z/2);

        return v;
    },

    /**
     * Create a new THREE.Color instance and given a base vector and
     * spread range vector, assign random values.
     *
     * Note that THREE.Color RGB values are in the range of 0 - 1, not 0 - 255.
     *
     * @private
     *
     * @param  {THREE.Vector3} base
     * @param  {THREE.Vector3} spread
     * @return {THREE.Color}
     */
    _randomColor: function( base, spread ) {
        var v = new THREE.Color();

        v.copy( base );

        v.r += (Math.random() * spread.x) - (spread.x/2);
        v.g += (Math.random() * spread.y) - (spread.y/2);
        v.b += (Math.random() * spread.z) - (spread.z/2);

        v.r = Math.max( 0, Math.min( v.r, 1 ) );
        v.g = Math.max( 0, Math.min( v.g, 1 ) );
        v.b = Math.max( 0, Math.min( v.b, 1 ) );

        return v;
    },


    /**
     * Create a random Number value based on an initial value and
     * a spread range
     *
     * @private
     *
     * @param  {Number} base
     * @param  {Number} spread
     * @return {Number}
     */
    _randomFloat: function( base, spread ) {
        return base + spread * (Math.random() - 0.5);
    },


    /**
     * Create a new THREE.Vector3 instance and project it onto a random point
     * on a sphere with radius `radius`.
     *
     * @param  {THREE.Vector3} base
     * @param  {Number} radius
     * @param  {THREE.Vector3} scale
     *
     * @private
     *
     * @return {THREE.Vector3}
     */
    _randomVector3OnSphere: function( base, radius, scale ) {
        var z = 2 * Math.random() - 1;
        var t = 6.2832 * Math.random();
        var r = Math.sqrt( 1 - z*z );
        var vec = new THREE.Vector3( r * Math.cos(t), r * Math.sin(t), z );

        vec.multiplyScalar( radius );

        if( scale ) {
            vec.multiply( scale );
        }

        vec.add( base );

        return vec;
    },


    /**
     * Create a new THREE.Vector3 instance, and given a base position, and various
     * other values, project it onto a random point on a sphere with radius `radius`.
     *
     * @param  {THREE.Vector3} base
     * @param  {THREE.Vector3} position
     * @param  {Number} speed
     * @param  {Number} speedSpread
     * @param  {THREE.Vector3} scale
     *
     * @private
     *
     * @return {THREE.Vector3}
     */
    _randomVelocityVector3OnSphere: function( base, position, speed, speedSpread, scale ) {
        var direction = new THREE.Vector3().subVectors( base, position );

        direction.normalize().multiplyScalar( this._randomFloat( speed, speedSpread ) );

        if( scale ) {
            direction.multiply( scale );
        }

        return direction;
    },


    /**
     * Given a base vector and a spread vector, randomise the given vector
     * accordingly.
     *
     * @param  {THREE.Vector3} vector
     * @param  {THREE.Vector3} base
     * @param  {THREE.Vector3} spread
     *
     * @private
     *
     * @return {[type]}
     */
    _randomizeExistingVector3: function( vector, base, spread ) {
        vector.set(
            Math.random() * base.x - spread.x,
            Math.random() * base.y - spread.y,
            Math.random() * base.z - spread.z
        );
    },


    /**
     * Tells the age and alive attributes (and the geometry vertices)
     * that they need updating by THREE.js's internal tick functions.
     *
     * @private
     *
     * @return {this}
     */
    _flagUpdate: function() {
        var that = this;

        // Set flags to update (causes less garbage than
        // ```ParticleSystem.sortParticles = true``` in THREE.r58 at least)
        that.attributes.age.needsUpdate = true;
        that.attributes.alive.needsUpdate = true;
        that.geometry.verticesNeedUpdate = true;

        return that;
    },


    /**
     * Add an emitter to this particle group. Once added, an emitter will be automatically
     * updated when ShaderParticleGroup#tick() is called.
     *
     * @param {ShaderParticleEmitter} emitter
     * @return {this}
     */
    addEmitter: function( emitter ) {
        var that = this;

        if( emitter.duration ) {
            emitter.numParticles = emitter.particlesPerSecond * (that.maxAge < emitter.emitterDuration ? that.maxAge : emitter.emitterDuration) | 0;
        }
        else {
            emitter.numParticles = emitter.particlesPerSecond * that.maxAge | 0;
        }

        emitter.numParticles = Math.ceil(emitter.numParticles);

        var vertices = that.geometry.vertices,
            start = vertices.length,
            end = emitter.numParticles + start,
            a = that.attributes,
            acceleration = a.acceleration.value,
            velocity = a.velocity.value,
            alive = a.alive.value,
            age = a.age.value,
            size = a.size.value,
            sizeEnd = a.sizeEnd.value,
            customColor = a.customColor.value,
            customColorEnd = a.customColorEnd.value,
            opacity = a.opacity.value,
            opacityMiddle = a.opacityMiddle.value,
            opacityEnd = a.opacityEnd.value;

        emitter.particleIndex = parseFloat( start );

        // Create the values
        for( var i = start; i < end; ++i ) {

            if( emitter.type === 'sphere' ) {
                vertices[i]     = that._randomVector3OnSphere( emitter.position, emitter.radius, emitter.radiusScale );
                velocity[i]     = that._randomVelocityVector3OnSphere( vertices[i], emitter.position, emitter.speed, emitter.speedSpread, emitter.radiusScale, emitter.radius );
            }
            else {
                vertices[i]     = that._randomVector3( emitter.position, emitter.positionSpread );
                velocity[i]     = that._randomVector3( emitter.velocity, emitter.velocitySpread );
            }


            acceleration[i] = that._randomVector3( emitter.acceleration, emitter.accelerationSpread );

            // Fix for bug #1 (https://github.com/squarefeet/ShaderParticleEngine/issues/1)
            // For some stupid reason I was limiting the size value to a minimum of 0.1. Derp.
            size[i]         = that._randomFloat( emitter.size, emitter.sizeSpread );
            sizeEnd[i]      = emitter.sizeEnd;
            age[i]          = 0.0;
            alive[i]        = emitter.static ? 1.0 : 0.0;


            customColor[i]      = that._randomColor( emitter.colorStart, emitter.colorSpread );
            customColorEnd[i]   = emitter.colorEnd;
            opacity[i]          = emitter.opacityStart;
            opacityMiddle[i]    = emitter.opacityMiddle;
            opacityEnd[i]       = emitter.opacityEnd;
        }

        // Cache properties on the emitter so we can access
        // them from its tick function.
        emitter.verticesIndex   = parseFloat( start );
        emitter.attributes      = that.attributes;
        emitter.vertices        = that.geometry.vertices;
        emitter.maxAge          = that.maxAge;

        // Save this emitter in an array for processing during this.tick()
        if( !emitter.static ) {
            that.emitters.push( emitter );
        }

        return that;
    },


    /**
     * The main particle group update function. Call this once per frame.
     *
     * @param  {Number} dt
     * @return {this}
     */
    tick: function( dt ) {
        var that = this,
            emitters = that.emitters,
            numEmitters = emitters.length;

        dt = dt || that.fixedTimeStep;

        if( numEmitters === 0 ) return;

        for( var i = 0; i < numEmitters; ++i ) {
            emitters[i].tick( dt );
        }

        that._flagUpdate();
        return that;
    },


    /**
     * Fetch a single emitter instance from the pool.
     * If there are no objects in the pool, a new emitter will be
     * created if specified.
     *
     * @return {ShaderParticleEmitter | null}
     */
    getFromPool: function() {
        var that = this,
            pool = that._pool,
            createNew = that._createNewWhenPoolEmpty;

        if( pool.length ) {
            return pool.pop();
        }
        else if( createNew ) {
            return new ShaderParticleEmitter( that._poolCreationSettings );
        }

        return null;
    },


    /**
     * Release an emitter into the pool.
     *
     * @param  {ShaderParticleEmitter} emitter
     * @return {this}
     */
    releaseIntoPool: function( emitter ) {
        if( !(emitter instanceof ShaderParticleEmitter) ) {
            console.error( 'Will not add non-emitter to particle group pool:', emitter );
            return;
        }

        emitter.reset();
        this._pool.unshift( emitter );

        return this;
    },


    /**
     * Get the pool array
     *
     * @return {Array}
     */
    getPool: function() {
        return this._pool;
    },


    /**
     * Add a pool of emitters to this particle group
     *
     * @param {Number} numEmitters      The number of emitters to add to the pool.
     * @param {Object} emitterSettings  An object describing the settings to pass to each emitter.
     * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?
     * @return {this}
     */
    addPool: function( numEmitters, emitterSettings, createNew ) {
        var that = this,
            emitter;

        // Save relevant settings and flags.
        that._poolCreationSettings = emitterSettings;
        that._createNewWhenPoolEmpty = !!createNew;

        // Create the emitters, add them to this group and the pool.
        for( var i = 0; i < numEmitters; ++i ) {
            emitter = new ShaderParticleEmitter( emitterSettings );
            that.addEmitter( emitter );
            that.releaseIntoPool( emitter );
        }

        return that;
    },


    /**
     * Internal method. Sets a single emitter to be alive
     *
     * @private
     *
     * @param  {THREE.Vector3} pos
     * @return {this}
     */
    _triggerSingleEmitter: function( pos ) {
        var that = this,
            emitter = that.getFromPool();

        if( emitter === null ) {
            console.log('ShaderParticleGroup pool ran out.');
            return;
        }

        // TODO: Should an instanceof check happen here? Or maybe at least a typeof?
        if( pos ) {
            emitter.position.copy( pos );
        }

        emitter.enable();

        setTimeout( function() {
            emitter.disable();
            that.releaseIntoPool( emitter );
        }, that.maxAgeMilliseconds );

        return that;
    },


    /**
     * Set a given number of emitters as alive, with an optional position
     * vector3 to move them to.
     *
     * @param  {Number} numEmitters
     * @param  {THREE.Vector3} position
     * @return {this}
     */
    triggerPoolEmitter: function( numEmitters, position ) {
        var that = this;

        if( typeof numEmitters === 'number' && numEmitters > 1) {
            for( var i = 0; i < numEmitters; ++i ) {
                that._triggerSingleEmitter( position );
            }
        }
        else {
            that._triggerSingleEmitter( position );
        }

        return that;
    }
};



// The all-important shaders
ShaderParticleGroup.shaders = {
    vertex: [
        'uniform float duration;',
        'uniform int hasPerspective;',

        'attribute vec3 customColor;',
        'attribute vec3 customColorEnd;',
        'attribute float opacity;',
        'attribute float opacityMiddle;',
        'attribute float opacityEnd;',

        'attribute vec3 acceleration;',
        'attribute vec3 velocity;',
        'attribute float alive;',
        'attribute float age;',
        'attribute float size;',
        'attribute float sizeEnd;',

        'varying vec4 vColor;',

        // Linearly lerp a float
        'float Lerp( float start, float end, float amount ) {',
            'return (start + ((end - start) * amount));',
        '}',

        // Linearly lerp a vector3
        'vec3 Lerp( vec3 start, vec3 end, float amount ) {',
            'return (start + ((end - start) * amount));',
        '}',

        // Integrate acceleration into velocity and apply it to the particle's position
        'vec4 GetPos() {',
            'vec3 newPos = vec3( position );',

            // Move acceleration & velocity vectors to the value they
            // should be at the current age
            'vec3 a = acceleration * age;',
            'vec3 v = velocity * age;',

            // Move velocity vector to correct values at this age
            'v = v + (a * age);',

            // Add velocity vector to the newPos vector
            'newPos = newPos + v;',

            // Convert the newPos vector into world-space
            'vec4 mvPosition = modelViewMatrix * vec4( newPos, 1.0 );',

            'return mvPosition;',
        '}',


        'void main() {',

            'float positionInTime = (age / duration);',
            'float halfDuration = (duration / 2.0);',

            'if( alive > 0.5 ) {',
                // Integrate color "tween"
                'vec3 color = vec3( customColor );',
                'if( customColor != customColorEnd ) {',
                    'color = Lerp( customColor, customColorEnd, positionInTime );',
                '}',

                // Store the color of this particle in the varying vColor,
                // so frag shader can access it.
                'if( opacity == opacityMiddle && opacityMiddle == opacityEnd ) {',
                    'vColor = vec4( color, opacity );',
                '}',

                'else if( positionInTime < 0.5 ) {',
                    'vColor = vec4( color, Lerp( opacity, opacityMiddle, age / halfDuration ) );',
                '}',

                'else if( positionInTime > 0.5 ) {',
                    'vColor = vec4( color, Lerp( opacityMiddle, opacityEnd, (age - halfDuration) / halfDuration ) );',
                '}',

                'else {',
                    'vColor = vec4( color, opacityMiddle );',
                '}',

                // Get the position of this particle so we can use it
                // when we calculate any perspective that might be required.
                'vec4 pos = GetPos();',

                // Determine point size .
                'float pointSize = Lerp( size, sizeEnd, positionInTime );',

                'if( hasPerspective == 1 ) {',
                    'pointSize = pointSize * ( 300.0 / length( pos.xyz ) );',
                '}',

                // Set particle size and position
                'gl_PointSize = pointSize;',
                'gl_Position = projectionMatrix * pos;',
            '}',

            'else {',
                // Hide particle and set its position to the (maybe) glsl
                // equivalent of Number.POSITIVE_INFINITY
                'vColor = vec4( customColor, 0.0 );',
                'gl_Position = vec4(1e20, 1e20, 1e20, 0);',
            '}',
        '}',
    ].join('\n'),

    fragment: [
        'uniform sampler2D texture;',
        'uniform int colorize;',

        'varying vec4 vColor;',

        'void main() {',
            'float c = cos(0.0);',
            'float s = sin(0.0);',

            'vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,',
                                  'c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);',

            'vec4 rotatedTexture = texture2D( texture, rotatedUV );',

            'if( colorize == 1 ) {',
                'gl_FragColor = vColor * rotatedTexture;',
            '}',
            'else {',
                'gl_FragColor = rotatedTexture;',
            '}',
        '}'
    ].join('\n')
};
;

// ShaderParticleEmitter 0.5.0
//
// (c) 2013 Luke Moody (http://www.github.com/squarefeet) & Lee Stemkoski (http://www.adelphi.edu/~stemkoski/)
//     Based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).
//
// ShaderParticleEmitter may be freely distributed under the MIT license (See LICENSE.txt)

function ShaderParticleEmitter( options ) {
    // If no options are provided, fallback to an empty object.
    options = options || {};

    // Helps with minification. Not as easy to read the following code,
    // but should still be readable enough!
    var that = this;


    that.particlesPerSecond     = typeof options.particlesPerSecond === 'number' ? options.particlesPerSecond : 100;
    that.type                   = (options.type === 'cube' || options.type === 'sphere') ? options.type : 'cube';

    that.position               = options.position instanceof THREE.Vector3 ? options.position : new THREE.Vector3();
    that.positionSpread         = options.positionSpread instanceof THREE.Vector3 ? options.positionSpread : new THREE.Vector3();

    // These two properties are only used when this.type === 'sphere'
    that.radius                 = typeof options.radius === 'number' ? options.radius : 10;
    that.radiusScale            = options.radiusScale instanceof THREE.Vector3 ? options.radiusScale : new THREE.Vector3(1, 1, 1);

    that.acceleration           = options.acceleration instanceof THREE.Vector3 ? options.acceleration : new THREE.Vector3();
    that.accelerationSpread     = options.accelerationSpread instanceof THREE.Vector3 ? options.accelerationSpread : new THREE.Vector3();

    that.velocity               = options.velocity instanceof THREE.Vector3 ? options.velocity : new THREE.Vector3();
    that.velocitySpread         = options.velocitySpread instanceof THREE.Vector3 ? options.velocitySpread : new THREE.Vector3();

    // And again here; only used when this.type === 'sphere'
    that.speed                  = parseFloat( typeof options.speed === 'number' ? options.speed : 0 );
    that.speedSpread            = parseFloat( typeof options.speedSpread === 'number' ? options.speedSpread : 0 );

    that.size                   = parseFloat( typeof options.size === 'number' ? options.size : 10.0 );
    that.sizeSpread             = parseFloat( typeof options.sizeSpread === 'number' ? options.sizeSpread : 0 );
    that.sizeEnd                = parseFloat( typeof options.sizeEnd === 'number' ? options.sizeEnd : 10.0 );

    that.colorStart             = options.colorStart instanceof THREE.Color ? options.colorStart : new THREE.Color( 'white' );
    that.colorEnd               = options.colorEnd instanceof THREE.Color ? options.colorEnd : new THREE.Color( 'blue' );
    that.colorSpread            = options.colorSpread instanceof THREE.Vector3 ? options.colorSpread : new THREE.Vector3();

    that.opacityStart           = parseFloat( typeof options.opacityStart !== 'undefined' ? options.opacityStart : 1 );
    that.opacityEnd             = parseFloat( typeof options.opacityEnd === 'number' ? options.opacityEnd : 0 );
    that.opacityMiddle          = parseFloat(
        typeof options.opacityMiddle !== 'undefined' ?
        options.opacityMiddle :
        Math.abs(that.opacityEnd + that.opacityStart) / 2
    );

    that.emitterDuration        = typeof options.emitterDuration === 'number' ? options.emitterDuration : null;
    that.alive                  = parseInt( typeof options.alive === 'number' ? options.alive : 1, 10);

    that.static                 = typeof options.static === 'number' ? options.static : 0;

    // The following properties are used internally, and mostly set when this emitter
    // is added to a particle group.
    that.numParticles           = 0;
    that.attributes             = null;
    that.vertices               = null;
    that.verticesIndex          = 0;
    that.age                    = 0.0;
    that.maxAge                 = 0.0;

    that.particleIndex = 0.0;

    that.userData = {};
}


ShaderParticleEmitter.prototype = {

    /**
     * Reset a particle's position. Accounts for emitter type and spreads.
     *
     * @private
     *
     * @param  {THREE.Vector3} p
     */
    _resetParticle: function( p ) {
        var that = this,
            spread = that.positionSpread,
            type = that.type;

        // Optimise for no position spread or radius
        if(
            ( type === 'cube' && spread.x === 0 && spread.y === 0 && spread.z === 0 ) ||
            ( type === 'sphere' && that.radius === 0 )
        ) {
            p.copy( that.position );
        }

        // If there is a position spread, then get a new position based on this spread.
        else if( type === 'cube' ) {
            that._randomizeExistingVector3( p, that.position, spread );
        }

        else if( type === 'sphere') {
            that._randomizeExistingVector3OnSphere( p, that.position, that.radius );
        }
    },


    /**
     * Given an existing particle vector, randomise it based on base and spread vectors
     *
     * @private
     *
     * @param  {THREE.Vector3} v
     * @param  {THREE.Vector3} base
     * @param  {THREE.Vector3} spread
     */
    _randomizeExistingVector3: function( v, base, spread ) {
        var r = Math.random;

        v.copy( base );

        v.x += r() * spread.x - (spread.x/2);
        v.y += r() * spread.y - (spread.y/2);
        v.z += r() * spread.z - (spread.z/2);
    },


    /**
     * Given an existing particle vector, project it onto a random point on a
     * sphere with radius `radius` and position `base`.
     *
     * @private
     *
     * @param  {THREE.Vector3} v
     * @param  {THREE.Vector3} base
     * @param  {Number} radius
     */
    _randomizeExistingVector3OnSphere: function( v, base, radius ) {
        var rand = Math.random;

        var z = 2 * rand() - 1;
        var t = 6.2832 * rand();
        var r = Math.sqrt( 1 - z*z );

        var x = ((r * Math.cos(t)) * radius);
        var y = ((r * Math.sin(t)) * radius);
        z *= radius;

        v.set(x, y, z).multiply( this.radiusScale );

        v.add( base );
    },


    // This function is called by the instance of `ShaderParticleEmitter` that
    // this emitter has been added to.
    /**
     * Update this emitter's particle's positions. Called by the ShaderParticleGroup
     * that this emitter belongs to.
     *
     * @param  {Number} dt
     */
    tick: function( dt ) {

        if( this.static ) {
            return;
        }

        // Cache some values for quicker access in loops.
        var that = this,
            a = that.attributes,
            alive = a.alive.value,
            age = a.age.value,
            start = that.verticesIndex,
            numParticles = that.numParticles,
            end = start + numParticles,
            pps = that.particlesPerSecond,
            ppsdt = pps * dt,
            m = that.maxAge,
            emitterAge = that.age,
            duration = that.emitterDuration,
            pIndex = that.particleIndex;

        // Loop through all the particles in this emitter and
        // determine whether they're still alive and need advancing
        // or if they should be dead and therefore marked as such
        // and pushed into the recycled vertices array for reuse.
        for( var i = start; i < end; ++i ) {
            if( alive[ i ] === 1.0 ) {
                age[ i ] += dt;
            }

            if( age[ i ] >= m ) {
                age[ i ] = 0.0;
                alive[ i ] = 0.0;
            }
        }

        // If the emitter is dead, reset any particles that are in
        // the recycled vertices array and reset the age of the
        // emitter to zero ready to go again if required, then
        // exit this function.
        if( that.alive === 0 ) {
            that.age = 0.0;
            return;
        }

        // If the emitter has a specified lifetime and we've exceeded it,
        // mark the emitter as dead and exit this function.
        if( typeof duration === 'number' && emitterAge > duration ) {
            that.alive = 0;
            that.age = 0.0;
            return;
        }

        var n = Math.min( end, pIndex + ppsdt );

        for( i = pIndex | 0; i < n; ++i ) {
            if( alive[ i ] !== 1.0 ) {
                alive[ i ] = 1.0;
                that._resetParticle( that.vertices[ i ] );
            }
        }

        that.particleIndex += ppsdt;

        if( pIndex >= start + that.numParticles ) {
            that.particleIndex = parseFloat( start, 10 );
        }

        // Add the delta time value to the age of the emitter.
        that.age += dt;
    },

    /**
     * Reset this emitter back to its starting position.
     * If `force` is truthy, then reset all particles in this
     * emitter as well, even if they're currently alive.
     *
     * @param  {Boolean} force
     * @return {this}
     */
    reset: function( force ) {
        var that = this;

        that.age = 0.0;
        that.alive = 0;

        if( force ) {
            var start = that.verticesIndex,
                end = that.verticesIndex + that.numParticles,
                a = that.attributes,
                alive = a.alive.value,
                age = a.age.value;

            for( var i = start; i < end; ++i ) {
                alive[ i ] = 0.0;
                age[ i ] = 0.0;
            }
        }

        return that;
    },


    /**
     * Enable this emitter.
     */
    enable: function() {
        this.alive = 1;
    },

    /**
     * Disable this emitter.
     */
    disable: function() {
        this.alive = 0;
    }
};// tween.js - http://github.com/sole/tween.js
'use strict';var TWEEN=TWEEN||function(){var a=[];return{REVISION:"10",getAll:function(){return a},removeAll:function(){a=[]},add:function(c){a.push(c)},remove:function(c){c=a.indexOf(c);-1!==c&&a.splice(c,1)},update:function(c){if(0===a.length)return!1;for(var b=0,d=a.length,c=void 0!==c?c:void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();b<d;)a[b].update(c)?b++:(a.splice(b,1),d--);return!0}}}();
TWEEN.Tween=function(a){var c={},b={},d={},e=1E3,g=0,i=0,k=null,u=TWEEN.Easing.Linear.None,v=TWEEN.Interpolation.Linear,p=[],q=null,r=!1,s=null,t=null,j;for(j in a)c[j]=parseFloat(a[j],10);this.to=function(a,c){void 0!==c&&(e=c);b=a;return this};this.start=function(e){TWEEN.add(this);r=!1;k=void 0!==e?e:void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();k+=i;for(var f in b){if(b[f]instanceof Array){if(0===b[f].length)continue;b[f]=[a[f]].concat(b[f])}c[f]=
a[f];!1===c[f]instanceof Array&&(c[f]*=1);d[f]=c[f]||0}return this};this.stop=function(){TWEEN.remove(this);return this};this.delay=function(a){i=a;return this};this.repeat=function(a){g=a;return this};this.easing=function(a){u=a;return this};this.interpolation=function(a){v=a;return this};this.chain=function(){p=arguments;return this};this.onStart=function(a){q=a;return this};this.onUpdate=function(a){s=a;return this};this.onComplete=function(a){t=a;return this};this.update=function(n){if(n<k)return!0;
!1===r&&(null!==q&&q.call(a),r=!0);var f=(n-k)/e,f=1<f?1:f,m=u(f),h;for(h in b){var j=c[h]||0,l=b[h];l instanceof Array?a[h]=v(l,m):("string"===typeof l&&(l=j+parseFloat(l,10)),a[h]=j+(l-j)*m)}null!==s&&s.call(a,m);if(1==f)if(0<g){isFinite(g)&&g--;for(h in d)"string"===typeof b[h]&&(d[h]+=parseFloat(b[h],10)),c[h]=d[h];k=n+i}else{null!==t&&t.call(a);f=0;for(m=p.length;f<m;f++)p[f].start(n);return!1}return!0}};
TWEEN.Easing={Linear:{None:function(a){return a}},Quadratic:{In:function(a){return a*a},Out:function(a){return a*(2-a)},InOut:function(a){return 1>(a*=2)?0.5*a*a:-0.5*(--a*(a-2)-1)}},Cubic:{In:function(a){return a*a*a},Out:function(a){return--a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a:0.5*((a-=2)*a*a+2)}},Quartic:{In:function(a){return a*a*a*a},Out:function(a){return 1- --a*a*a*a},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a:-0.5*((a-=2)*a*a*a-2)}},Quintic:{In:function(a){return a*a*a*
a*a},Out:function(a){return--a*a*a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a*a:0.5*((a-=2)*a*a*a*a+2)}},Sinusoidal:{In:function(a){return 1-Math.cos(a*Math.PI/2)},Out:function(a){return Math.sin(a*Math.PI/2)},InOut:function(a){return 0.5*(1-Math.cos(Math.PI*a))}},Exponential:{In:function(a){return 0===a?0:Math.pow(1024,a-1)},Out:function(a){return 1===a?1:1-Math.pow(2,-10*a)},InOut:function(a){return 0===a?0:1===a?1:1>(a*=2)?0.5*Math.pow(1024,a-1):0.5*(-Math.pow(2,-10*(a-1))+2)}},Circular:{In:function(a){return 1-
Math.sqrt(1-a*a)},Out:function(a){return Math.sqrt(1- --a*a)},InOut:function(a){return 1>(a*=2)?-0.5*(Math.sqrt(1-a*a)-1):0.5*(Math.sqrt(1-(a-=2)*a)+1)}},Elastic:{In:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return-(b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4))},Out:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return b*Math.pow(2,-10*a)*Math.sin((a-c)*
2*Math.PI/0.4)+1},InOut:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return 1>(a*=2)?-0.5*b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4):0.5*b*Math.pow(2,-10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4)+1}},Back:{In:function(a){return a*a*(2.70158*a-1.70158)},Out:function(a){return--a*a*(2.70158*a+1.70158)+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*(3.5949095*a-2.5949095):0.5*((a-=2)*a*(3.5949095*a+2.5949095)+2)}},Bounce:{In:function(a){return 1-
TWEEN.Easing.Bounce.Out(1-a)},Out:function(a){return a<1/2.75?7.5625*a*a:a<2/2.75?7.5625*(a-=1.5/2.75)*a+0.75:a<2.5/2.75?7.5625*(a-=2.25/2.75)*a+0.9375:7.5625*(a-=2.625/2.75)*a+0.984375},InOut:function(a){return 0.5>a?0.5*TWEEN.Easing.Bounce.In(2*a):0.5*TWEEN.Easing.Bounce.Out(2*a-1)+0.5}}};
TWEEN.Interpolation={Linear:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),g=TWEEN.Interpolation.Utils.Linear;return 0>c?g(a[0],a[1],d):1<c?g(a[b],a[b-1],b-d):g(a[e],a[e+1>b?b:e+1],d-e)},Bezier:function(a,c){var b=0,d=a.length-1,e=Math.pow,g=TWEEN.Interpolation.Utils.Bernstein,i;for(i=0;i<=d;i++)b+=e(1-c,d-i)*e(c,i)*a[i]*g(d,i);return b},CatmullRom:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),g=TWEEN.Interpolation.Utils.CatmullRom;return a[0]===a[b]?(0>c&&(e=Math.floor(d=b*(1+c))),g(a[(e-
1+b)%b],a[e],a[(e+1)%b],a[(e+2)%b],d-e)):0>c?a[0]-(g(a[0],a[0],a[1],a[1],-d)-a[0]):1<c?a[b]-(g(a[b],a[b],a[b-1],a[b-1],d-b)-a[b]):g(a[e?e-1:0],a[e],a[b<e+1?b:e+1],a[b<e+2?b:e+2],d-e)},Utils:{Linear:function(a,c,b){return(c-a)*b+a},Bernstein:function(a,c){var b=TWEEN.Interpolation.Utils.Factorial;return b(a)/b(c)/b(a-c)},Factorial:function(){var a=[1];return function(c){var b=1,d;if(a[c])return a[c];for(d=c;1<d;d--)b*=d;return a[c]=b}}(),CatmullRom:function(a,c,b,d,e){var a=0.5*(b-a),d=0.5*(d-c),g=
e*e;return(2*c-2*b+a+d)*e*g+(-3*c+3*b-2*a-d)*g+a*e+c}}};
/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */

if ( !window.requestAnimationFrame ) {

	window.requestAnimationFrame = ( function() {

		return window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.oRequestAnimationFrame ||
		window.msRequestAnimationFrame ||
		function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {

			window.setTimeout( callback, 1000 / 60 );

		};

	} )();

}
var CLOSURE_NO_DEPS = true;
var COMPILED=!0,goog=goog||{};goog.global=this;goog.DEBUG=!0;goog.LOCALE="en";goog.provide=function(a){if(!COMPILED){if(goog.isProvided_(a))throw Error('Namespace "'+a+'" already declared.');delete goog.implicitNamespaces_[a];for(var b=a;(b=b.substring(0,b.lastIndexOf(".")))&&!goog.getObjectByName(b);)goog.implicitNamespaces_[b]=!0}goog.exportPath_(a)};goog.setTestOnly=function(a){if(COMPILED&&!goog.DEBUG)throw a=a||"",Error("Importing test-only code into non-debug environment"+a?": "+a:".");};
COMPILED||(goog.isProvided_=function(a){return!goog.implicitNamespaces_[a]&&!!goog.getObjectByName(a)},goog.implicitNamespaces_={});goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]?c[d]:c[d]={}};goog.getObjectByName=function(a,b){for(var c=a.split("."),d=b||goog.global,e;e=c.shift();)if(goog.isDefAndNotNull(d[e]))d=d[e];else return null;return d};
goog.globalize=function(a,b){var c=b||goog.global,d;for(d in a)c[d]=a[d]};goog.addDependency=function(a,b,c){if(!COMPILED){var d;a=a.replace(/\\/g,"/");for(var e=goog.dependencies_,f=0;d=b[f];f++)e.nameToPath[d]=a,a in e.pathToNames||(e.pathToNames[a]={}),e.pathToNames[a][d]=!0;for(d=0;b=c[d];d++)a in e.requires||(e.requires[a]={}),e.requires[a][b]=!0}};goog.ENABLE_DEBUG_LOADER=!0;
goog.require=function(a){if(!COMPILED&&!goog.isProvided_(a)){if(goog.ENABLE_DEBUG_LOADER){var b=goog.getPathFromDeps_(a);if(b){goog.included_[b]=!0;goog.writeScripts_();return}}a="goog.require could not find: "+a;goog.global.console&&goog.global.console.error(a);throw Error(a);}};goog.basePath="";goog.nullFunction=function(){};goog.identityFunction=function(a){return a};goog.abstractMethod=function(){throw Error("unimplemented abstract method");};
goog.addSingletonGetter=function(a){a.getInstance=function(){return a.instance_||(a.instance_=new a)}};
!COMPILED&&goog.ENABLE_DEBUG_LOADER&&(goog.included_={},goog.dependencies_={pathToNames:{},nameToPath:{},requires:{},visited:{},written:{}},goog.inHtmlDocument_=function(){var a=goog.global.document;return"undefined"!=typeof a&&"write"in a},goog.findBasePath_=function(){if(goog.global.CLOSURE_BASE_PATH)goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_())for(var a=goog.global.document.getElementsByTagName("script"),b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?"),d=
-1==d?c.length:d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}},goog.importScript_=function(a){var b=goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_;!goog.dependencies_.written[a]&&b(a)&&(goog.dependencies_.written[a]=!0)},goog.writeScriptTag_=function(a){return goog.inHtmlDocument_()?(goog.global.document.write('<script type="text/javascript" src="'+a+'">\x3c/script>'),!0):!1},goog.writeScripts_=function(){function a(e){if(!(e in d.written)){if(!(e in d.visited)&&(d.visited[e]=
!0,e in d.requires))for(var h in d.requires[e])if(!goog.isProvided_(h))if(h in d.nameToPath)a(d.nameToPath[h]);else throw Error("Undefined nameToPath for "+h);e in c||(c[e]=!0,b.push(e))}}var b=[],c={},d=goog.dependencies_,e;for(e in goog.included_)d.written[e]||a(e);for(e=0;e<b.length;e++)if(b[e])goog.importScript_(goog.basePath+b[e]);else throw Error("Undefined script input");},goog.getPathFromDeps_=function(a){return a in goog.dependencies_.nameToPath?goog.dependencies_.nameToPath[a]:null},goog.findBasePath_(),
goog.global.CLOSURE_NO_DEPS||goog.importScript_(goog.basePath+"deps.js"));
goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b};goog.propertyIsEnumerableCustom_=function(a,b){if(b in a)for(var c in a)if(c==b&&Object.prototype.hasOwnProperty.call(a,b))return!0;return!1};goog.propertyIsEnumerable_=function(a,b){return a instanceof Object?Object.prototype.propertyIsEnumerable.call(a,b):goog.propertyIsEnumerableCustom_(a,b)};goog.isDef=function(a){return void 0!==a};goog.isNull=function(a){return null===a};
goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return"array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return"array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isString=function(a){return"string"==typeof a};goog.isBoolean=function(a){return"boolean"==typeof a};goog.isNumber=function(a){return"number"==typeof a};
goog.isFunction=function(a){return"function"==goog.typeOf(a)};goog.isObject=function(a){a=goog.typeOf(a);return"object"==a||"array"==a||"function"==a};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.removeUid=function(a){"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_]}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+Math.floor(2147483648*Math.random()).toString(36);goog.uidCounter_=0;
goog.getHashCode=goog.getUid;goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(a.clone)return a.clone();var b="array"==b?[]:{},c;for(c in a)b[c]=goog.cloneObject(a[c]);return b}return a};goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};
goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};
goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=Array.prototype.slice.call(arguments);b.unshift.apply(b,c);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c]};goog.now=Date.now||function(){return+new Date};
goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval)if(null==goog.evalWorksForGlobals_&&(goog.global.eval("var _et_ = 1;"),"undefined"!=typeof goog.global._et_?(delete goog.global._et_,goog.evalWorksForGlobals_=!0):goog.evalWorksForGlobals_=!1),goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("script");c.type="text/javascript";c.defer=!1;c.appendChild(b.createTextNode(a));b.body.appendChild(c);
b.body.removeChild(c)}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;goog.getCssName=function(a,b){var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")},d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};return b?a+"-"+d(b):d(a)};goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b};
!COMPILED&&goog.global.CLOSURE_CSS_NAME_MAPPING&&(goog.cssNameMapping_=goog.global.CLOSURE_CSS_NAME_MAPPING);goog.getMsg=function(a,b){var c=b||{},d;for(d in c){var e=(""+c[d]).replace(/\$/g,"$$$$");a=a.replace(RegExp("\\{\\$"+d+"\\}","gi"),e)}return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c)};goog.exportProperty=function(a,b,c){a[b]=c};goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a};
goog.base=function(a,b,c){var d=arguments.callee.caller;if(d.superClass_)return d.superClass_.constructor.apply(a,Array.prototype.slice.call(arguments,1));for(var e=Array.prototype.slice.call(arguments,2),f=!1,h=a.constructor;h;h=h.superClass_&&h.superClass_.constructor)if(h.prototype[b]===d)f=!0;else if(f)return h.prototype[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};
goog.scope=function(a){a.call(goog.global)};var Vizi={Time:function(){if(Vizi.Time.instance)throw Error("Graphics singleton already exists");}};Vizi.Time.prototype.initialize=function(a){this.currentTime=Date.now();Vizi.Time.instance=this};Vizi.Time.prototype.update=function(){this.currentTime=Date.now()};Vizi.Time.instance=null;Vizi.Service=function(){};Vizi.Service.prototype.initialize=function(a){};Vizi.Service.prototype.terminate=function(){};Vizi.Service.prototype.update=function(){};Vizi.EventService=function(){};goog.inherits(Vizi.EventService,Vizi.Service);Vizi.EventService.prototype.initialize=function(a){};Vizi.EventService.prototype.terminate=function(){};Vizi.EventService.prototype.update=function(){do Vizi.EventService.eventsPending=!1,Vizi.Application.instance.updateObjects();while(Vizi.EventService.eventsPending)};Vizi.EventDispatcher=function(){this.eventTypes={};this.timestamps={};this.connections={}};Vizi.EventDispatcher.prototype.addEventListener=function(a,b){var c=this.eventTypes[a];if(c){if(-1!=c.indexOf(b))return}else c=[],this.eventTypes[a]=c,this.timestamps[a]=0;c.push(b)};Vizi.EventDispatcher.prototype.removeEventListener=function(a,b){if(b){var c=this.eventTypes[a];if(c){var d=c.indexOf(b);-1!=d&&c.splice(d,1)}}else delete this.eventTypes[a],delete this.timestamps[a]};
Vizi.EventDispatcher.prototype.dispatchEvent=function(a){var b=this.eventTypes[a];if(b){var c=Vizi.Time.instance.currentTime;if(this.timestamps[a]<c)for(this.timestamps[a]=c,Vizi.EventService.eventsPending=!0,[].shift.call(arguments),c=0;c<b.length;c++)b[c].apply(this,arguments)}};Vizi.EventDispatcher.prototype.hasEventListener=function(a,b){var c=this.eventTypes[type];return c?-1!=c.indexOf(listener):!1};
Vizi.EventDispatcher.prototype.connect=function(a,b,c){var d=this.connections[a];d||(d=[],this.connections[a]=d);var e=this,f=function(){return function(){e.handleConnection(null,b,c,arguments)}}(),h={listener:f,sourceProp:null,target:b,targetProp:c};d.push(h);h=this.addEventListener(a,f)};Vizi.EventDispatcher.prototype.handleConnection=function(a,b,c,d){var e=b[c];"function"==typeof e?e.apply(b,d):"object"==typeof e?e.copy&&"function"==typeof e.copy&&e.copy(a?d[0][a]:d[0]):b[c]=a?d[0][a]:d[0]};Vizi.Object=function(a){Vizi.EventDispatcher.call(this);this._id=Vizi.Object.nextId++;this._parent=null;this._children=[];this._components=[];this.name="";this._realized=!1;var b=!0;a&&void 0!==a.autoCreateTransform&&(b=a.autoCreateTransform);b&&this.addComponent(new Vizi.Transform(a))};goog.inherits(Vizi.Object,Vizi.EventDispatcher);Vizi.Object.nextId=0;Vizi.Object.prototype.getID=function(){return this._id};Vizi.Object.prototype.setParent=function(a){this._parent=a};
Vizi.Object.prototype.addChild=function(a){if(!a)throw Error("Cannot add a null child");if(a._parent)throw Error("Child is already attached to an Object");a.setParent(this);this._children.push(a);this._realized&&!a._realized&&a.realize()};Vizi.Object.prototype.removeChild=function(a){var b=this._children.indexOf(a);-1!=b&&(this._children.splice(b,1),a.removeAllComponents(),a.setParent(null))};Vizi.Object.prototype.getChild=function(a){return a>=this._children.length?null:this._children[a]};
Vizi.Object.prototype.addComponent=function(a){if(!a)throw Error("Cannot add a null component");if(a._object)throw Error("Component is already attached to an Object");var b=Object.getPrototypeOf(a);if(b._componentProperty){if(this[b._componentProperty]){Vizi.System.warn("Object already has a "+b._componentPropertyType+" component");return}this[b._componentProperty]=a}b._componentCategory&&(this[b._componentCategory]||(this[b._componentCategory]=[]),this[b._componentCategory].push(a));this._components.push(a);
a.setObject(this);this._realized&&!a._realized&&a.realize()};Vizi.Object.prototype.removeComponent=function(a){if(a){var b=this._components.indexOf(a);-1!=b&&(a.removeFromScene&&a.removeFromScene(),this._components.splice(b,1),a.setObject(null));b=Object.getPrototypeOf(a);b._componentProperty&&(this[b._componentProperty]=null);if(b._componentCategory&&this[b._componentCategory]){var c=this[b._componentCategory],b=c.indexOf(a);-1!=b&&c.splice(b,1)}}};
Vizi.Object.prototype.removeAllComponents=function(){var a,b=this._components.length;for(a=0;a<b;a++){var c=this._components[a];c.removeFromScene&&c.removeFromScene();c.setObject(null)}};Vizi.Object.prototype.getComponent=function(a){var b,c=this._components.length;for(b=0;b<c;b++){var d=this._components[b];if(d instanceof a)return d}return null};Vizi.Object.prototype.getComponents=function(a){var b,c=this._components.length,d=[];for(b=0;b<c;b++){var e=this._components[b];e instanceof a&&d.push(e)}return d};
Vizi.Object.prototype.realize=function(){this.realizeComponents();this.realizeChildren();this._realized=!0};Vizi.Object.prototype.realizeComponents=function(){for(var a=this._components.length,b=0;b<a;++b)this._components[b].realize()};Vizi.Object.prototype.realizeChildren=function(){for(var a=this._children.length,b=0;b<a;++b)this._children[b].realize()};Vizi.Object.prototype.update=function(){this.updateComponents();this.updateChildren()};
Vizi.Object.prototype.updateComponents=function(){for(var a=this._components.length,b=0;b<a;++b)this._components[b].update()};Vizi.Object.prototype.updateChildren=function(){for(var a=this._children.length,b=0;b<a;++b)this._children[b].update()};Vizi.Object.prototype.traverse=function(a){a(this);var b,c=this._children.length;for(b=0;b<c;b++)this._children[b].traverse(a)};
Vizi.Object.prototype.findCallback=function(a,b,c){if("string"==typeof b)a.name==b&&c.push(a);else if(b instanceof RegExp)(b=a.name.match(b))&&b.length&&c.push(a);else if(b instanceof Function)if(a instanceof b)c.push(a);else{a=a.getComponents(b);var d=a.length;for(b=0;b<d;b++)c.push(a[b])}};Vizi.Object.prototype.findNode=function(a){var b=this,c=[];this.traverse(function(d){b.findCallback(d,a,c)});return c[0]};
Vizi.Object.prototype.findNodes=function(a){var b=this,c=[];this.traverse(function(d){b.findCallback(d,a,c)});return c};Vizi.Object.prototype.map=function(a,b){var c=this.findNodes(a),d,e=c.length;for(d=0;d<e;d++)b(c[d])};Vizi.Component=function(a){Vizi.EventDispatcher.call(this);this._object=null;this._realized=!1};goog.inherits(Vizi.Component,Vizi.EventDispatcher);Vizi.Component.prototype.getObject=function(){return this._object};Vizi.Component.prototype.setObject=function(a){this._object=a};Vizi.Component.prototype.realize=function(){this._realized=!0};Vizi.Component.prototype.update=function(){};Vizi.SceneComponent=function(a){a=a||{};Vizi.Component.call(this,a);Object.defineProperties(this,{position:{get:function(){return this.object.position}},rotation:{get:function(){return this.object.rotation}},scale:{get:function(){return this.object.scale}},quaternion:{get:function(){return this.object.quaternion}},up:{get:function(){return this.object.up},set:function(a){this.object.up=a}},useQuaternion:{get:function(){return this.object.useQuaternion},set:function(a){this.object.useQuaternion=a}},
visible:{get:function(){return this.object.visible},set:function(a){this.object.visible=a}},lookAt:{value:function(a){this.object.lookAt(a)}},translateOnAxis:{value:function(a,c){this.object.translateOnAxis(a,c)}},translateX:{value:function(a){this.object.translateX(a)}},translateY:{value:function(a){this.object.translateY(a)}},translateZ:{value:function(a){this.object.translateZ(a)}}});this.layer=a.layer};goog.inherits(Vizi.SceneComponent,Vizi.Component);
Vizi.SceneComponent.prototype.realize=function(){this.object&&!this.object.data&&this.addToScene();Vizi.Component.prototype.realize.call(this)};Vizi.SceneComponent.prototype.update=function(){Vizi.Component.prototype.update.call(this)};
Vizi.SceneComponent.prototype.addToScene=function(){var a=this.layer?this.layer.scene:Vizi.Graphics.instance.scene;this._object&&this._object.transform.object!=this.object&&(a=this._object.transform?this._object.transform.object:a)&&(a!=this.object.parent&&a.add(this.object),this.object.data=this)};
Vizi.SceneComponent.prototype.removeFromScene=function(){var a=this.layer?this.layer.scene:Vizi.Graphics.instance.scene;this._object&&(a=this._object.transform?this._object.transform.object:a)&&(this.object.data=null,a.remove(this.object));this._realized=!1};Vizi.Camera=function(a){a=a||{};Vizi.SceneComponent.call(this,a);Object.defineProperties(this,{active:{get:function(){return this._active},set:function(a){(this._active=a)&&Vizi.CameraManager.setActiveCamera(this)}}});this._active=a.active||!1};goog.inherits(Vizi.Camera,Vizi.SceneComponent);Vizi.Camera.prototype._componentProperty="camera";Vizi.Camera.prototype._componentPropertyType="Camera";
Vizi.Camera.prototype.realize=function(){Vizi.SceneComponent.prototype.realize.call(this);this.addToScene();Vizi.CameraManager.addCamera(this);this._active&&!Vizi.CameraManager.activeCamera&&Vizi.CameraManager.setActiveCamera(this)};Vizi.Camera.prototype.lookAt=function(a){this.object.lookAt(a)};Vizi.Camera.DEFAULT_POSITION=new THREE.Vector3(0,0,10);Vizi.Camera.DEFAULT_NEAR=1;Vizi.Camera.DEFAULT_FAR=1E4;Vizi.Script=function(a){a=a||{};Vizi.Component.call(this,a)};goog.inherits(Vizi.Script,Vizi.Component);Vizi.Script.prototype._componentCategory="scripts";Vizi.Script.prototype.realize=function(){Vizi.Component.prototype.realize.call(this)};Vizi.Script.prototype.update=function(){Vizi.Script.WARN_ON_ABSTRACT&&Vizi.System.warn("Abstract Script.evaluate called")};Vizi.Script.WARN_ON_ABSTRACT=!0;Vizi.Prefabs={};Vizi.Prefabs.FirstPersonController=function(a){a=a||{};var b=new Vizi.Object(a),c=new Vizi.FirstPersonControllerScript(a);b.addComponent(c);a=new Vizi.DirectionalLight({intensity:a.headlight?1:0});b.addComponent(a);return b};
Vizi.FirstPersonControllerScript=function(a){Vizi.Script.call(this,a);this._enabled=void 0!==a.enabled?a.enabled:!0;this._move=void 0!==a.move?a.move:!0;this._look=void 0!==a.look?a.look:!0;this._turn=void 0!==a.turn?a.turn:!0;this._tilt=void 0!==a.tilt?a.tilt:!0;this._mouseLook=void 0!==a.mouseLook?a.mouseLook:!1;this.collisionDistance=10;this.moveSpeed=13;this.tiltSpeed=this.turnSpeed=5;this.lookSpeed=1;this.savedCameraPos=new THREE.Vector3;this.movementVector=new THREE.Vector3;Object.defineProperties(this,
{camera:{get:function(){return this._camera},set:function(a){this.setCamera(a)}},enabled:{get:function(){return this._enabled},set:function(a){this.setEnabled(a)}},move:{get:function(){return this._move},set:function(a){this.setMove(a)}},look:{get:function(){return this._look},set:function(a){this.setLook(a)}},mouseLook:{get:function(){return this._mouseLook},set:function(a){this.setMouseLook(a)}},headlightOn:{get:function(){return this._headlightOn},set:function(a){this.setHeadlightOn(a)}}})};
goog.inherits(Vizi.FirstPersonControllerScript,Vizi.Script);Vizi.FirstPersonControllerScript.prototype.realize=function(){this.headlight=this._object.getComponent(Vizi.DirectionalLight);this.headlight.intensity=this._headlightOn?1:0};
Vizi.FirstPersonControllerScript.prototype.createControls=function(a){a=new Vizi.FirstPersonControls(a.object,Vizi.Graphics.instance.container);a.mouseLook=this._mouseLook;a.movementSpeed=this._move?this.moveSpeed:0;a.lookSpeed=this._look?this.lookSpeed:0;a.turnSpeed=this._turn?this.turnSpeed:0;a.tiltSpeed=this._tilt?this.tiltSpeed:0;this.clock=new THREE.Clock;return a};
Vizi.FirstPersonControllerScript.prototype.update=function(){this.saveCamera();this.controls.update(this.clock.getDelta());var a=this.testCollision();a&&a.object&&(this.restoreCamera(),this.dispatchEvent("collide",a));this.testTerrain()&&this.restoreCamera();this._headlightOn&&this.headlight.direction.copy(this._camera.position).negate()};Vizi.FirstPersonControllerScript.prototype.setEnabled=function(a){this._enabled=a;this.controls.enabled=a};
Vizi.FirstPersonControllerScript.prototype.setMove=function(a){this._move=a;this.controls.movementSpeed=a?this.moveSpeed:0};Vizi.FirstPersonControllerScript.prototype.setLook=function(a){this._look=a;this.controls.lookSpeed=a?1:0};Vizi.FirstPersonControllerScript.prototype.setMouseLook=function(a){this._mouseLook=a;this.controls.mouseLook=a};
Vizi.FirstPersonControllerScript.prototype.setCamera=function(a){this._camera=a;this.controls=this.createControls(a);this.controls.movementSpeed=this.moveSpeed;this.controls.lookSpeed=this._look?0.1:0};Vizi.FirstPersonControllerScript.prototype.saveCamera=function(){this.savedCameraPos.copy(this._camera.position)};Vizi.FirstPersonControllerScript.prototype.restoreCamera=function(){this._camera.position.copy(this.savedCameraPos)};
Vizi.FirstPersonControllerScript.prototype.testCollision=function(){this.movementVector.copy(this._camera.position).sub(this.savedCameraPos);if(this.movementVector.length()){var a=Vizi.Graphics.instance.objectFromRay(null,this.savedCameraPos,this.movementVector,1,2);a&&a.object&&this.savedCameraPos.distanceTo(a.hitPointWorld);return a}return null};Vizi.FirstPersonControllerScript.prototype.testTerrain=function(){return!1};
Vizi.FirstPersonControllerScript.prototype.setHeadlightOn=function(a){this._headlightOn=a;this.headlight&&(this.headlight.intensity=a?1:0)};Vizi.Transition=function(a){Vizi.Component.call(this,a);a=a||{};this.running=!1;this.duration=a.duration?a.duration:Vizi.Transition.default_duration;this.loop=a.loop?a.loop:!1;this.autoStart=a.autoStart||!1;this.easing=a.easing||Vizi.Transition.default_easing;this.target=a.target;this.to=a.to};goog.inherits(Vizi.Transition,Vizi.Component);Vizi.Transition.prototype.realize=function(){Vizi.Component.prototype.realize.call(this);this.createTweens();this.autoStart&&this.start()};
Vizi.Transition.prototype.createTweens=function(){var a=this.loop?Infinity:0,b=this;this.tween=(new TWEEN.Tween(this.target)).to(this.to,this.duration).easing(this.easing).repeat(a).onComplete(function(){b.onTweenComplete()})};Vizi.Transition.prototype.start=function(){this.running||(this.running=!0,this.tween.start())};Vizi.Transition.prototype.stop=function(){this.running&&(this.running=!1,this.dispatchEvent("complete"),this.tween.stop())};
Vizi.Transition.prototype.onTweenComplete=function(){this.running=!1;this.dispatchEvent("complete")};Vizi.Transition.default_duration=1E3;Vizi.Transition.default_easing=TWEEN.Easing.Linear.None;Vizi.Picker=function(a){a=a||{};Vizi.Component.call(this,a);this.overCursor=a.overCursor;this.enabled=void 0!==a.enabled?a.enabled:!0};goog.inherits(Vizi.Picker,Vizi.Component);Vizi.Picker.prototype._componentCategory="pickers";Vizi.Picker.prototype.realize=function(){Vizi.Component.prototype.realize.call(this);this.lastHitPoint=new THREE.Vector3;this.lastHitNormal=new THREE.Vector3;this.lastHitFace=new THREE.Face3};Vizi.Picker.prototype.update=function(){};
Vizi.Picker.prototype.toModelSpace=function(a){var b=new THREE.Matrix4;b.getInverse(this._object.transform.object.matrixWorld);a.applyMatrix4(b)};Vizi.Picker.prototype.onMouseOver=function(a){this.dispatchEvent("mouseover",a)};Vizi.Picker.prototype.onMouseOut=function(a){this.dispatchEvent("mouseout",a)};
Vizi.Picker.prototype.onMouseMove=function(a){var b=Vizi.PickManager.objectFromMouse(a);if(this._object==Vizi.PickManager.clickedObject||this._object==b)a.point&&this.lastHitPoint.copy(a.point),a.normal&&this.lastHitNormal.copy(a.normal),a.face&&(this.lastHitFace=a.face),a.point&&this.dispatchEvent("mousemove",a)};
Vizi.Picker.prototype.onMouseDown=function(a){this.lastHitPoint.copy(a.point);a.normal&&this.lastHitNormal.copy(a.normal);a.face&&(this.lastHitFace=a.face);this.dispatchEvent("mousedown",a)};Vizi.Picker.prototype.onMouseUp=function(a){Vizi.PickManager.objectFromMouse(a)!=this._object&&(a.point=this.lastHitPoint,a.normal=this.lastHitNormal,a.face=this.lastHitNormal,this.dispatchEvent("mouseout",a));this.dispatchEvent("mouseup",a)};
Vizi.Picker.prototype.onMouseClick=function(a){this.lastHitPoint.copy(a.point);a.normal&&this.lastHitNormal.copy(a.normal);a.face&&(this.lastHitFace=a.face);this.dispatchEvent("click",a)};Vizi.Picker.prototype.onMouseDoubleClick=function(a){this.lastHitPoint.copy(a.point);a.normal&&this.lastHitNormal.copy(a.normal);a.face&&(this.lastHitFace=a.face);this.dispatchEvent("dblclick",a)};Vizi.Picker.prototype.onMouseScroll=function(a){this.dispatchEvent("mousescroll",a)};
Vizi.Picker.prototype.onTouchMove=function(a){this.dispatchEvent("touchmove",a)};Vizi.Picker.prototype.onTouchStart=function(a){this.dispatchEvent("touchstart",a)};Vizi.Picker.prototype.onTouchEnd=function(a){this.dispatchEvent("touchend",a)};Vizi.SurfaceDragger=function(a){a=a||{};Vizi.Picker.call(this,a);this.reference=a.reference;this.dragPlane=new THREE.Plane};goog.inherits(Vizi.SurfaceDragger,Vizi.Picker);Vizi.SurfaceDragger.prototype.realize=function(){Vizi.Picker.prototype.realize.call(this)};Vizi.SurfaceDragger.prototype.update=function(){};
Vizi.SurfaceDragger.prototype.onMouseDown=function(a){Vizi.Picker.prototype.onMouseDown.call(this,a);var b=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,this.reference.visuals[0].object);b&&(b=b.point.clone(),this.dragOffset=a.point.clone().sub(this._object.transform.position),this.dispatchEvent("dragstart",{type:"dragstart",offset:b}))};Vizi.SurfaceDragger.prototype.onMouseUp=function(a){Vizi.Picker.prototype.onMouseUp.call(this,a);this.dispatchEvent("dragend",{type:"dragend"})};
Vizi.SurfaceDragger.prototype.onMouseMove=function(a){Vizi.Picker.prototype.onMouseMove.call(this,a);var b=this.reference.visuals[0],c=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,b.object);if(c){var d=c.point.clone();a=c.face.normal.clone();var e=b.geometry.vertices,b=e[c.face.a],f=e[c.face.b],c=e[c.face.c];this.dragPlane=(new THREE.Plane).setFromCoplanarPoints(b,f,c);d=d.clone();c=d.clone().add(a);b=(new THREE.Vector3(0,a.z,-a.y)).normalize();b.lengthSq()||b.set(0,a.x,a.y).normalize();
(0>a.x||0>a.z)&&b.negate();this.dispatchEvent("drag",{type:"drag",offset:d,normal:a,up:b,lookAt:c})}};Vizi.Mouse=function(){this.state={x:Vizi.Mouse.NO_POSITION,y:Vizi.Mouse.NO_POSITION,buttons:{left:!1,middle:!1,right:!1},scroll:0};Vizi.Mouse.instance=this};Vizi.Mouse.prototype.onMouseMove=function(a){this.state.x=a.elementX;this.state.y=a.elementY};Vizi.Mouse.prototype.onMouseDown=function(a){this.state.x=a.elementX;this.state.y=a.elementY;this.state.buttons.left=!0};Vizi.Mouse.prototype.onMouseUp=function(a){this.state.x=a.elementX;this.state.y=a.elementY;this.state.buttons.left=!1};
Vizi.Mouse.prototype.onMouseClick=function(a){this.state.x=a.elementX;this.state.y=a.elementY;this.state.buttons.left=!1};Vizi.Mouse.prototype.onMouseDoubleClick=function(a){this.state.x=a.elementX;this.state.y=a.elementY;this.state.buttons.left=!1};Vizi.Mouse.prototype.onMouseScroll=function(a,b){this.state.scroll=0};Vizi.Mouse.prototype.getState=function(){return this.state};Vizi.Mouse.instance=null;Vizi.Mouse.NO_POSITION=Number.MIN_VALUE;Vizi.PointerLockControls=function(a){var b=this;this.speed=0.05;this.speedMultiplier=1;this.fly=!1;this.jumpPower=0.1;this.gravity=0;a.rotation.set(0,0,0);var c=new THREE.Object3D;c.add(a);var d=new THREE.Object3D;d.position.y=10;d.add(c);var e=!1,f=!1,h=!1,m=!1,g=new THREE.Vector3,l=Math.PI/2;document.addEventListener("mousemove",function(a){if(!1!==b.enabled){var e=a.movementY||a.mozMovementY||a.webkitMovementY||0;d.rotation.y-=0.0020*(a.movementX||a.mozMovementX||a.webkitMovementX||0);c.rotation.x-=
0.0020*e;c.rotation.x=Math.max(-l,Math.min(l,c.rotation.x))}},!1);document.addEventListener("keydown",function(a){switch(a.keyCode){case 16:this.speedMultiplier=10;break;case 17:this.speedMultiplier=0.5;break;case 38:case 87:e=!0;break;case 37:case 65:h=!0;break;case 40:case 83:f=!0;break;case 39:case 68:m=!0;break;case 67:g.y+=this.jumpPower;break;case 32:g.y-=this.jumpPower}}.bind(this),!1);document.addEventListener("keyup",function(a){switch(a.keyCode){case 16:this.speedMultiplier=1;break;case 17:this.speedMultiplier=
1;break;case 38:case 87:e=!1;break;case 37:case 65:h=!1;break;case 40:case 83:f=!1;break;case 39:case 68:m=!1;break;case 32:g.y=0;break;case 67:g.y=0}}.bind(this),!1);this.enabled=!1;this.getObject=function(){return d};this.getPosition=function(){return(new THREE.Vector3).copy(d.position)};this.getDirection=function(){var a=new THREE.Vector3(0,0,-1),b=new THREE.Euler(0,0,0,"YXZ");return function(){v=new THREE.Vector3;b.set(c.rotation.x,d.rotation.y,0);v.copy(a).applyEuler(b);return v}}();this.update=
function(a){!1!==b.enabled&&(a*=0.1,g.x+=0.08*-g.x*a,g.z+=0.08*-g.z*a,g.y-=this.gravity*a,e&&(g.z-=this.speed*a*this.speedMultiplier),f&&(g.z+=this.speed*a*this.speedMultiplier),h&&(g.x-=this.speed*a*this.speedMultiplier),m&&(g.x+=this.speed*a*this.speedMultiplier),d.translateX(g.x),d.translateY(g.y),d.translateZ(g.z),10>d.position.y&&(g.y=0,d.position.y=10))}};Vizi.Timer=function(a){Vizi.Component.call(this);a=a||{};this.currentTime=Vizi.Time.instance.currentTime;this.running=!1;this.duration=a.duration?a.duration:0;this.loop=void 0!==a.loop?a.loop:!1;this.lastFraction=0};goog.inherits(Vizi.Timer,Vizi.Component);
Vizi.Timer.prototype.update=function(){if(this.running){var a=Vizi.Time.instance.currentTime;a-this.currentTime&&this.dispatchEvent("time",a);if(this.duration){var b=a%this.duration/this.duration;this.dispatchEvent("fraction",b);b<this.lastFraction&&(this.dispatchEvent("cycleTime"),this.loop||this.stop());this.lastFraction=b}this.currentTime=a}};Vizi.Timer.prototype.start=function(){this.running=!0;this.currentTime=Vizi.Time.instance.currentTime};
Vizi.Timer.prototype.stop=function(){this.running=!1};Vizi.Transform=function(a){a=a||{};Vizi.SceneComponent.call(this,a);this.object=a.object?a.object:new THREE.Object3D};goog.inherits(Vizi.Transform,Vizi.SceneComponent);Vizi.Transform.prototype._componentProperty="transform";Vizi.Transform.prototype._componentPropertyType="Transform";
Vizi.Transform.prototype.addToScene=function(){var a=this.layer?this.layer.scene:Vizi.Graphics.instance.scene;this._object&&(a=this._object._parent&&this._object._parent.transform?this._object._parent.transform.object:a)&&(a.add(this.object),this.object.data=this)};
Vizi.Transform.prototype.removeFromScene=function(){var a=this.layer?this.layer.scene:Vizi.Graphics.instance.scene;this._object&&(a=this._object._parent&&this._object._parent.transform?this._object._parent.transform.object:a)&&(this.object.data=null,a.remove(this.object))};Vizi.Behavior=function(a){a=a||{};this.startTime=0;this.running=!1;this.loop=void 0!==a.loop?a.loop:!1;this.autoStart=void 0!==a.autoStart?a.autoStart:!1;Vizi.Component.call(this,a)};goog.inherits(Vizi.Behavior,Vizi.Component);Vizi.Behavior.prototype._componentCategory="behaviors";Vizi.Behavior.prototype.realize=function(){Vizi.Component.prototype.realize.call(this);this.autoStart&&this.start()};Vizi.Behavior.prototype.start=function(){this.startTime=Vizi.Time.instance.currentTime;this.running=!0};
Vizi.Behavior.prototype.stop=function(){this.startTime=0;this.running=!1};Vizi.Behavior.prototype.toggle=function(){this.running?this.stop():this.start()};Vizi.Behavior.prototype.update=function(){this.running&&this.evaluate((Vizi.Time.instance.currentTime-this.startTime)/1E3)};Vizi.Behavior.prototype.evaluate=function(a){Vizi.Behavior.WARN_ON_ABSTRACT&&Vizi.System.warn("Abstract Behavior.evaluate called")};Vizi.Behavior.WARN_ON_ABSTRACT=!0;Vizi.FadeBehavior=function(a){a=a||{};this.duration=void 0!==a.duration?a.duration:1;this.opacity=void 0!==a.opacity?a.opacity:0.5;this.savedOpacities=[];this.savedTransparencies=[];this.tween=null;Vizi.Behavior.call(this,a)};goog.inherits(Vizi.FadeBehavior,Vizi.Behavior);
Vizi.FadeBehavior.prototype.start=function(){if(!this.running){if(this._realized&&this._object.visuals){var a=this._object.visuals,b,c=a.length;for(b=0;b<c;b++)this.savedOpacities.push(a[b].material.opacity),this.savedTransparencies.push(a[b].material.transparent),a[b].material.transparent=1>this.opacity?!0:!1}this.value={opacity:this.savedOpacities[0]};this.targetValue={opacity:this.opacity};this.tween=(new TWEEN.Tween(this.value)).to(this.targetValue,1E3*this.duration).easing(TWEEN.Easing.Quadratic.InOut).repeat(0).start();
Vizi.Behavior.prototype.start.call(this)}};Vizi.FadeBehavior.prototype.evaluate=function(a){a>=this.duration&&(this.stop(),this.loop&&this.start());if(this._object.visuals){a=this._object.visuals;var b,c=a.length;for(b=0;b<c;b++)a[b].material.opacity=this.value.opacity}};Vizi.FadeBehavior.prototype.stop=function(){this.tween&&this.tween.stop();Vizi.Behavior.prototype.stop.call(this)};Vizi.Light=function(a){a=a||{};Vizi.SceneComponent.call(this,a);Object.defineProperties(this,{color:{get:function(){return this.object.color}},intensity:{get:function(){return this.object.intensity},set:function(a){this.object.intensity=a}}})};goog.inherits(Vizi.Light,Vizi.SceneComponent);Vizi.Light.prototype._componentProperty="light";Vizi.Light.prototype._componentPropertyType="Light";Vizi.Light.prototype.realize=function(){Vizi.SceneComponent.prototype.realize.call(this)};
Vizi.Light.DEFAULT_COLOR=16777215;Vizi.Light.DEFAULT_INTENSITY=1;Vizi.Light.DEFAULT_RANGE=1E4;Vizi.DirectionalLight=function(a){a=a||{};this.scaledDir=new THREE.Vector3;this.castShadows=void 0!==a.castShadows?a.castShadows:Vizi.DirectionalLight.DEFAULT_CAST_SHADOWS;Vizi.Light.call(this,a);a.object?(this.object=a.object,this.direction=a.object.position.clone().normalize().negate(),this.targetPos=a.object.target.position.clone(),this.shadowDarkness=a.object.shadowDarkness):(this.direction=a.direction||new THREE.Vector3(0,0,-1),this.object=new THREE.DirectionalLight(a.color,a.intensity,0),this.targetPos=
new THREE.Vector3,this.shadowDarkness=void 0!==a.shadowDarkness?a.shadowDarkness:Vizi.DirectionalLight.DEFAULT_SHADOW_DARKNESS)};goog.inherits(Vizi.DirectionalLight,Vizi.Light);Vizi.DirectionalLight.prototype.realize=function(){Vizi.Light.prototype.realize.call(this)};
Vizi.DirectionalLight.prototype.update=function(){this.position.copy(this.direction).normalize().negate();this.position.applyMatrix4(this.object.parent.matrixWorld);this.scaledDir.copy(this.direction);this.scaledDir.multiplyScalar(Vizi.Light.DEFAULT_RANGE);this.targetPos.copy(this.position);this.targetPos.add(this.scaledDir);this.object.target.position.copy(this.targetPos);this.updateShadows();Vizi.Light.prototype.update.call(this)};
Vizi.DirectionalLight.prototype.updateShadows=function(){this.castShadows&&(this.object.castShadow=!0,this.object.shadowCameraNear=1,this.object.shadowCameraFar=Vizi.Light.DEFAULT_RANGE,this.object.shadowCameraFov=90,this.object.shadowBias=1E-4,this.object.shadowDarkness=this.shadowDarkness,this.object.shadowMapWidth=1024,this.object.shadowMapHeight=1024,Vizi.Graphics.instance.enableShadows(!0))};Vizi.DirectionalLight.DEFAULT_CAST_SHADOWS=!1;Vizi.DirectionalLight.DEFAULT_SHADOW_DARKNESS=0.3;Vizi.PointLight=function(a){a=a||{};Vizi.Light.call(this,a);this.positionVec=new THREE.Vector3;this.object=a.object?a.object:new THREE.PointLight(a.color,a.intensity,void 0!==a.distance?a.distance:Vizi.PointLight.DEFAULT_DISTANCE);Object.defineProperties(this,{distance:{get:function(){return this.object.distance},set:function(a){this.object.distance=a}}})};goog.inherits(Vizi.PointLight,Vizi.Light);Vizi.PointLight.prototype.realize=function(){Vizi.Light.prototype.realize.call(this)};
Vizi.PointLight.prototype.update=function(){this.object&&(this.positionVec.set(0,0,0),this.positionVec.applyMatrix4(this.object.parent.matrixWorld),this.position.copy(this.positionVec));Vizi.Light.prototype.update.call(this)};Vizi.PointLight.DEFAULT_DISTANCE=0;Vizi.Prefabs.DeviceOrientationController=function(a){a=a||{};var b=new Vizi.Object(a);a=new Vizi.DeviceOrientationControllerScript(a);b.addComponent(a);return b};Vizi.DeviceOrientationControllerScript=function(a){Vizi.Script.call(this,a);this._enabled=void 0!==a.enabled?a.enabled:!0;this.roll=void 0!==a.roll?a.roll:!0;Object.defineProperties(this,{camera:{get:function(){return this._camera},set:function(a){this.setCamera(a)}},enabled:{get:function(){return this._enabled},set:function(a){this.setEnabled(a)}}})};
goog.inherits(Vizi.DeviceOrientationControllerScript,Vizi.Script);Vizi.DeviceOrientationControllerScript.prototype.realize=function(){};Vizi.DeviceOrientationControllerScript.prototype.createControls=function(a){a=new Vizi.DeviceOrientationControls(a.object);this._enabled&&a.connect();a.roll=this.roll;return a};Vizi.DeviceOrientationControllerScript.prototype.update=function(){this._enabled&&this.controls.update()};
Vizi.DeviceOrientationControllerScript.prototype.setEnabled=function(a){(this._enabled=a)?this.controls.connect():this.controls.disconnect()};Vizi.DeviceOrientationControllerScript.prototype.setCamera=function(a){this._camera=a;this.controls=this.createControls(a)};Vizi.Visual=function(a){a=a||{};Vizi.SceneComponent.call(this,a);a.object?(this.object=a.object,this.geometry=this.object.geometry,this.material=this.object.material):(this.geometry=a.geometry,this.material=a.material)};goog.inherits(Vizi.Visual,Vizi.SceneComponent);Vizi.Visual.prototype._componentCategory="visuals";
Vizi.Visual.prototype.realize=function(){Vizi.SceneComponent.prototype.realize.call(this);!this.object&&(this.geometry&&this.material)&&(this.object=new THREE.Mesh(this.geometry,this.material),this.object.ignorePick=!1,this.addToScene())};Vizi.SceneVisual=function(a){a=a||{};Vizi.Visual.call(this,a);this.object=a.scene};goog.inherits(Vizi.SceneVisual,Vizi.Visual);Vizi.SceneVisual.prototype.realize=function(){Vizi.Visual.prototype.realize.call(this);this.addToScene()};Vizi.Keyboard=function(){Vizi.Keyboard.instance=this};Vizi.Keyboard.prototype.onKeyDown=function(a){};Vizi.Keyboard.prototype.onKeyUp=function(a){};Vizi.Keyboard.prototype.onKeyPress=function(a){};Vizi.Keyboard.instance=null;Vizi.Keyboard.KEY_LEFT=37;Vizi.Keyboard.KEY_UP=38;Vizi.Keyboard.KEY_RIGHT=39;Vizi.Keyboard.KEY_DOWN=40;Vizi.Graphics=function(){if(Vizi.Graphics.instance)throw Error("Graphics singleton already exists");Vizi.Graphics.instance=this};Vizi.Graphics.instance=null;Vizi.MoveBehavior=function(a){a=a||{};this.duration=void 0!==a.duration?a.duration:1;this.moveVector=void 0!==a.moveVector?a.moveVector:new THREE.Vector3(0,1,0);this.tween=null;Vizi.Behavior.call(this,a)};goog.inherits(Vizi.MoveBehavior,Vizi.Behavior);
Vizi.MoveBehavior.prototype.start=function(){this.running||(this.movePosition=new THREE.Vector3,this.moveEndPosition=this.moveVector.clone(),this.prevMovePosition=new THREE.Vector3,this.moveDelta=new THREE.Vector3,this.tween=(new TWEEN.Tween(this.movePosition)).to(this.moveEndPosition,1E3*this.duration).easing(TWEEN.Easing.Quadratic.InOut).repeat(0).start(),Vizi.Behavior.prototype.start.call(this))};
Vizi.MoveBehavior.prototype.evaluate=function(a){a>=this.duration&&(this.stop(),this.loop?this.start():this.dispatchEvent("complete"));this.moveDelta.copy(this.movePosition).sub(this.prevMovePosition);this.prevMovePosition.copy(this.movePosition);this._object.transform.position.add(this.moveDelta)};Vizi.MoveBehavior.prototype.stop=function(){this.tween&&this.tween.stop();Vizi.Behavior.prototype.stop.call(this)};Vizi.PickManager={};
Vizi.PickManager.handleMouseMove=function(a){if(Vizi.PickManager.clickedObject){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onMouseMove)b[c].onMouseMove(a)}else{b=Vizi.PickManager.overObject;Vizi.PickManager.overObject=Vizi.PickManager.objectFromMouse(a);if(Vizi.PickManager.overObject!=b){if(b)for(Vizi.Graphics.instance.setCursor(null),a.type="mouseout",b=b.pickers,d=b.length,c=0;c<d;c++)if(b[c].enabled&&b[c].onMouseOut)b[c].onMouseOut(a);if(Vizi.PickManager.overObject)for(a.type=
"mouseover",b=Vizi.PickManager.overObject.pickers,d=b.length,c=0;c<d;c++)if(b[c].enabled&&b[c].overCursor&&Vizi.Graphics.instance.setCursor(b[c].overCursor),b[c].enabled&&b[c].onMouseOver)b[c].onMouseOver(a)}if(Vizi.PickManager.overObject)for(b=Vizi.PickManager.overObject.pickers,d=b.length,c=0;c<d;c++)b[c].enabled&&(b[c].moveWithoutCapture&&b[c].onMouseMove)&&(a.type="mousemove",b[c].onMouseMove(a))}};
Vizi.PickManager.handleMouseDown=function(a){Vizi.PickManager.clickedObject=Vizi.PickManager.objectFromMouse(a);if(Vizi.PickManager.clickedObject){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onMouseDown)b[c].onMouseDown(a)}};
Vizi.PickManager.handleMouseUp=function(a){if(Vizi.PickManager.clickedObject){var b=Vizi.PickManager.objectFromMouse(a),c=Vizi.PickManager.clickedObject.pickers,d,e=c.length;for(d=0;d<e;d++)c[d].enabled&&c[d].onMouseUp&&(c[d].onMouseUp(a),b==Vizi.PickManager.clickedObject&&(a.type="click",c[d].onMouseClick(a)))}Vizi.PickManager.clickedObject=null};Vizi.PickManager.handleMouseClick=function(a){};
Vizi.PickManager.handleMouseDoubleClick=function(a){Vizi.PickManager.clickedObject=Vizi.PickManager.objectFromMouse(a);if(Vizi.PickManager.clickedObject){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onMouseDoubleClick)b[c].onMouseDoubleClick(a)}Vizi.PickManager.clickedObject=null};
Vizi.PickManager.handleMouseScroll=function(a){if(Vizi.PickManager.overObject){var b=Vizi.PickManager.overObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onMouseScroll)b[c].onMouseScroll(a)}Vizi.PickManager.clickedObject=null};
Vizi.PickManager.handleTouchStart=function(a){if(0<a.touches.length&&(a.screenX=a.touches[0].screenX,a.screenY=a.touches[0].screenY,a.clientX=a.touches[0].clientX,a.clientY=a.touches[0].clientY,a.pageX=a.touches[0].pageX,a.pageY=a.touches[0].pageY,a.elementX=a.touches[0].elementX,a.elementY=a.touches[0].elementY,Vizi.PickManager.clickedObject=Vizi.PickManager.objectFromMouse(a),Vizi.PickManager.clickedObject)){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&
b[c].onTouchStart)b[c].onTouchStart(a)}};Vizi.PickManager.handleTouchMove=function(a){if(0<a.touches.length&&(a.screenX=a.touches[0].screenX,a.screenY=a.touches[0].screenY,a.clientX=a.touches[0].clientX,a.clientY=a.touches[0].clientY,a.pageX=a.touches[0].pageX,a.pageY=a.touches[0].pageY,a.elementX=a.touches[0].elementX,a.elementY=a.touches[0].elementY,Vizi.PickManager.clickedObject)){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onTouchMove)b[c].onTouchMove(a)}};
Vizi.PickManager.handleTouchEnd=function(a){if(0<a.changedTouches.length){a.screenX=a.changedTouches[0].screenX;a.screenY=a.changedTouches[0].screenY;a.clientX=a.changedTouches[0].clientX;a.clientY=a.changedTouches[0].clientY;a.pageX=a.changedTouches[0].pageX;a.pageY=a.changedTouches[0].pageY;a.elementX=a.changedTouches[0].elementX;a.elementY=a.changedTouches[0].elementY;if(Vizi.PickManager.clickedObject){var b=Vizi.PickManager.clickedObject.pickers,c,d=b.length;for(c=0;c<d;c++)if(b[c].enabled&&b[c].onTouchEnd)b[c].onTouchEnd(a)}Vizi.PickManager.clickedObject=
null}};Vizi.PickManager.objectFromMouse=function(a){var b=Vizi.Graphics.instance.objectFromMouse(a);if(b.object){a.face=b.face;a.normal=b.normal;a.point=b.point;a.object=b.object;if(b.object._object.pickers){var c=b.object._object.pickers,d,e=c.length;for(d=0;d<e;d++)if(c[d].enabled)return b.object._object}return Vizi.PickManager.findObjectPicker(a,b.hitPointWorld,b.object.object)}return null};
Vizi.PickManager.findObjectPicker=function(a,b,c){for(;c;){if(c.data&&c.data._object.pickers){var d=c.data._object.pickers,e,f=d.length;for(e=0;e<f;e++)if(d[e].enabled)return d=new THREE.Matrix4,d.getInverse(c.matrixWorld),a.point=b.clone(),a.point.applyMatrix4(d),c.data._object}c=c.parent}return null};Vizi.PickManager.clickedObject=null;Vizi.PickManager.overObject=null;Vizi.AmbientLight=function(a){a=a||{};Vizi.Light.call(this,a);this.object=a.object?a.object:new THREE.AmbientLight(a.color)};goog.inherits(Vizi.AmbientLight,Vizi.Light);Vizi.AmbientLight.prototype.realize=function(){Vizi.Light.prototype.realize.call(this)};Vizi.Input=function(){this.mouse=new Vizi.Mouse;this.keyboard=new Vizi.Keyboard;this.gamepad=new Vizi.Gamepad;Vizi.Input.instance=this};goog.inherits(Vizi.Input,Vizi.Service);Vizi.Input.prototype.update=function(){this.gamepad&&this.gamepad.update&&this.gamepad.update()};Vizi.Input.instance=null;Vizi.CylinderDragger=function(a){a=a||{};Vizi.Picker.call(this,a);this.normal=a.normal||new THREE.Vector3(0,1,0);this.position=a.position||new THREE.Vector3;this.color=11141120};goog.inherits(Vizi.CylinderDragger,Vizi.Picker);
Vizi.CylinderDragger.prototype.realize=function(){Vizi.Picker.prototype.realize.call(this);this.dragObject=null;this.dragOffset=new THREE.Euler;this.currentOffset=new THREE.Euler;this.dragHitPoint=new THREE.Vector3;this.dragStartPoint=new THREE.Vector3;this.dragPlane=this.createDragPlane();this.dragPlane.visible=Vizi.CylinderDragger.SHOW_DRAG_PLANE;this.dragPlane.ignorePick=!0;this.dragPlane.ignoreBounds=!0;this._object.transform.object.add(this.dragPlane)};
Vizi.CylinderDragger.prototype.createDragPlane=function(){var a=this.normal,b=this.position,c=(new THREE.Vector3(0,a.z,-a.y)).normalize().multiplyScalar(2E3);c.lengthSq()||(c=(new THREE.Vector3(-a.z,a.x,0)).normalize().multiplyScalar(2E3));var d=c.clone().cross(a).normalize().multiplyScalar(2E3),e=b.clone().sub(c).sub(d),f=b.clone().add(c).sub(d),h=b.clone().add(c).add(d),c=b.clone().sub(c).add(d),b=new THREE.Geometry;b.vertices.push(e,f,h,c);e=new THREE.Face3(0,2,1);e.normal.copy(a);e.vertexNormals.push(a.clone(),
a.clone(),a.clone(),a.clone());b.faces.push(e);e=new THREE.Face3(0,3,2);e.normal.copy(a);e.vertexNormals.push(a.clone(),a.clone(),a.clone(),a.clone());b.faces.push(e);b.computeFaceNormals();b.computeCentroids();a=new THREE.MeshBasicMaterial({color:this.color,transparent:!0,side:THREE.DoubleSide,opacity:0.1});return new THREE.Mesh(b,a)};Vizi.CylinderDragger.prototype.update=function(){};Vizi.CylinderDragger.prototype.onMouseDown=function(a){Vizi.Picker.prototype.onMouseDown.call(this,a);this.handleMouseDown(a)};
Vizi.CylinderDragger.prototype.handleMouseDown=function(a){if(this.dragPlane){var b=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,this.dragPlane);b&&(this.dragStartPoint.copy(b.point).normalize(),this.dragObject=a.object,this.dispatchEvent("dragstart",{type:"dragstart",offset:b.point}))}Vizi.CylinderDragger.SHOW_DRAG_NORMAL&&(this.arrowDecoration&&this._object.removeComponent(this.arrowDecoration),a=new THREE.ArrowHelper(this.normal,new THREE.Vector3,500,65280,5,5),a=new Vizi.Decoration({object:a}),
this._object.addComponent(a),this.arrowDecoration=a)};Vizi.CylinderDragger.prototype.onMouseMove=function(a){Vizi.Picker.prototype.onMouseMove.call(this,a);this.handleMouseMove(a)};
Vizi.CylinderDragger.prototype.handleMouseMove=function(a){if(a=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,this.dragPlane)){var b=a.point.clone().normalize();a=Math.acos(b.dot(this.dragStartPoint));b=b.clone().cross(this.dragStartPoint);0<this.normal.dot(b)&&(a=-a);this.currentOffset.set(this.dragOffset.x+this.normal.x*a,this.dragOffset.y+this.normal.y*a,this.dragOffset.z+this.normal.z*a);this.dispatchEvent("drag",{type:"drag",offset:this.currentOffset})}};
Vizi.CylinderDragger.prototype.onMouseUp=function(a){Vizi.Picker.prototype.onMouseUp.call(this,a);this.handleMouseUp(a)};Vizi.CylinderDragger.prototype.handleMouseUp=function(a){this.arrowDecoration&&this._object.removeComponent(this.arrowDecoration)};Vizi.CylinderDragger.prototype.onTouchStart=function(a){Vizi.Picker.prototype.onTouchStart.call(this,a);this.handleMouseDown(a)};Vizi.CylinderDragger.prototype.onTouchMove=function(a){Vizi.Picker.prototype.onTouchMove.call(this,a);this.handleMouseMove(a)};
Vizi.CylinderDragger.prototype.onTouchEnd=function(a){Vizi.Picker.prototype.onTouchEnd.call(this,a);this.handleMouseUp(a)};Vizi.CylinderDragger.SHOW_DRAG_PLANE=!1;Vizi.CylinderDragger.SHOW_DRAG_NORMAL=!1;Vizi.RotateBehavior=function(a){a=a||{};this.duration=void 0!==a.duration?a.duration:1;this.velocity=void 0!==a.velocity?a.velocity:Math.PI/2/this.duration;this.angle=this.startAngle=0;Vizi.Behavior.call(this,a)};goog.inherits(Vizi.RotateBehavior,Vizi.Behavior);Vizi.RotateBehavior.prototype.start=function(){this.angle=0;this._object.transform.rotation.y%=2*Math.PI;this.startAngle=this._object.transform.rotation.y;Vizi.Behavior.prototype.start.call(this)};
Vizi.RotateBehavior.prototype.evaluate=function(a){var b=2*Math.PI;this.angle=this.velocity*a;this.angle>=b&&(this.angle=this.once?b:this.angle%b);this._object.transform.rotation.y=this.startAngle+this.angle;this.once&&this.angle>=b&&this.stop()};Vizi.FirstPersonControls=function(a,b){function c(a,b){return function(){b.apply(a,arguments)}}this.object=a;this.target=new THREE.Vector3(0,0,0);this.domElement=void 0!==b?b:document;this.lookSpeed=this.movementSpeed=1;this.tiltSpeed=this.turnSpeed=5;this.touchScreenY=this.touchScreenX=this.lastMouseY=this.lastMouseX=this.mouseY=this.mouseX=this.tiltAngle=this.turnAngle=0;this.moveTouchId=this.lookTouchId=-1;this.theta=this.phi=this.lon=this.lat=0;this.mouseLook=this.mouseDragOn=this.tiltDown=this.tiltUp=
this.turnLeft=this.turnRight=this.moveRight=this.moveLeft=this.moveBackward=this.moveForward=!1;this.viewHalfY=this.viewHalfX=0;this.domElement!==document&&this.domElement.setAttribute("tabindex",-1);this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)};this.onMouseDown=function(a){this.domElement===document?(this.mouseX=a.pageX-this.viewHalfX,
this.mouseY=a.pageY-this.viewHalfY):(this.mouseX=a.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=a.pageY-this.domElement.offsetTop-this.viewHalfY);this.lastMouseX=this.mouseX;this.lastMouseY=this.mouseY;this.mouseDragOn=!0};this.onMouseUp=function(a){this.mouseDragOn=!1};this.onMouseMove=function(a){this.domElement===document?(this.mouseX=a.pageX-this.viewHalfX,this.mouseY=a.pageY-this.viewHalfY):(this.mouseX=a.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=a.pageY-this.domElement.offsetTop-
this.viewHalfY)};this.onTouchStart=function(a){a.preventDefault();0<a.touches.length&&(-1==this.lookTouchId?(this.lookTouchId=a.touches[0].identifier,this.onMouseDown({type:"mousedown",view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,detail:a.detail,screenX:a.touches[0].screenX,screenY:a.touches[0].screenY,clientX:a.touches[0].clientX,clientY:a.touches[0].clientY,pageX:a.touches[0].pageX,pageY:a.touches[0].pageY,button:0,preventDefault:a.preventDefault})):(this.touchScreenX=a.touches[1].screenX,
this.touchScreenY=a.touches[1].screenY,this.moveTouchId=a.touches[1].identifier))};this.onTouchMove=function(a){a.preventDefault();for(var b=null,c=null,d=a.changedTouches.length,g=0;g<d;g++)a.changedTouches[g].identifier==this.lookTouchId&&(b=a.changedTouches[g]),a.changedTouches[g].identifier==this.moveTouchId&&(c=a.changedTouches[g]);if(b)this.onMouseMove({type:"mousemove",view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,detail:a.detail,screenX:b.screenX,screenY:b.screenY,clientX:b.clientX,
clientY:b.clientY,pageX:b.pageX,pageY:b.pageY,button:0,preventDefault:a.preventDefault});c&&(a=c.screenX-this.touchScreenX,b=c.screenY-this.touchScreenY,this.touchScreenX=c.screenX,this.touchScreenY=c.screenY,0<a&&(this.moveRight=!0),0>a&&(this.moveLeft=!0),0<b&&(this.moveBackward=!0),0>b&&(this.moveForward=!0))};this.onTouchEnd=function(a){a.preventDefault();for(var b=null,c=null,d=a.changedTouches.length,g=0;g<d;g++)a.changedTouches[g].identifier==this.lookTouchId&&(b=a.changedTouches[g]),a.changedTouches[g].identifier==
this.moveTouchId&&(c=a.changedTouches[g]);b&&(this.onMouseUp({type:"mouseup",view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,detail:a.detail,screenX:b.screenX,screenY:b.screenY,clientX:b.clientX,clientY:b.clientY,pageX:b.pageX,pageY:b.pageY,button:0,preventDefault:a.preventDefault}),this.lookTouchId=-1);c&&(this.touchScreenX=c.screenX,this.touchScreenY=c.screenY,this.moveForward=this.moveBackward=this.moveLeft=this.moveRight=!1,this.moveTouchId=-1)};this.onGamepadButtonsChanged=function(a){};
this.onGamepadAxesChanged=function(a){a=a.changedAxes;var b,c=a.length;for(b=0;b<c;b++){var d=a[b];d.axis==Vizi.Gamepad.AXIS_LEFT_V?-0.2>d.value?(this.moveForward=!0,this.moveBackward=!1):(this.moveBackward=0.2<d.value?!0:!1,this.moveForward=!1):d.axis==Vizi.Gamepad.AXIS_LEFT_H?0.5<d.value?(this.moveRight=!0,this.moveLeft=!1):(this.moveLeft=-0.5>d.value?!0:!1,this.moveRight=!1):d.axis==Vizi.Gamepad.AXIS_RIGHT_V?-0.2>d.value?(this.tiltUp=!0,this.tiltDown=!1):(this.tiltDown=0.2<d.value?!0:!1,this.tiltUp=
!1):d.axis==Vizi.Gamepad.AXIS_RIGHT_H&&(0.5<d.value?(this.turnLeft=!0,this.turnRight=!1):-0.5>d.value?(this.turnRight=!0,this.turnLeft=!1):this.turnRight=this.turnLeft=!1)}};this.onKeyDown=function(a){switch(a.keyCode){case 38:case 87:this.moveForward=!0;break;case 37:case 65:this.moveLeft=!0;break;case 40:case 83:this.moveBackward=!0;break;case 39:case 68:this.moveRight=!0;break;case 82:this.moveUp=!0;break;case 70:this.moveDown=!0}};this.onKeyUp=function(a){switch(a.keyCode){case 38:case 87:this.moveForward=
!1;break;case 37:case 65:this.moveLeft=!1;break;case 40:case 83:this.moveBackward=!1;break;case 39:case 68:this.moveRight=!1;break;case 82:this.moveUp=!1;break;case 70:this.moveDown=!1}};this.update=function(a){if(!1!==this.enabled){this.startY=this.object.position.y;a*=this.movementSpeed;this.moveForward&&this.object.translateZ(-a);this.moveBackward&&this.object.translateZ(a);this.moveLeft&&this.object.translateX(-a);this.moveRight&&this.object.translateX(a);this.object.position.y=this.startY;if((this.mouseDragOn||
this.mouseLook)&&this.lookSpeed){a=this.lastMouseX-this.mouseX;Math.abs(a);a=900*(a/this.viewHalfX);this.lon+=a*this.lookSpeed;a=this.lastMouseY-this.mouseY;Math.abs(a);a=900*(a/this.viewHalfY);this.lat+=a*this.lookSpeed;this.theta=THREE.Math.degToRad(this.lon);this.lat=Math.max(-85,Math.min(85,this.lat));this.phi=THREE.Math.degToRad(this.lat);a=this.target;var b=this.object.position;a.x=b.x-Math.sin(this.theta);a.y=b.y+Math.sin(this.phi);a.z=b.z-Math.cos(this.theta);this.object.lookAt(a);this.lastMouseX=
this.mouseX;this.lastMouseY=this.mouseY}if(this.turnRight||this.turnLeft||this.tiltUp||this.tiltDown)a=0,this.turnRight?a=1:this.turnLeft&&(a=-1),this.lon+=a*this.turnSpeed,a=0,this.tiltUp?a=1:this.tiltDown&&(a=-1),this.lat+=a*this.tiltSpeed,this.theta=THREE.Math.degToRad(this.lon),this.lat=Math.max(-85,Math.min(85,this.lat)),this.phi=THREE.Math.degToRad(this.lat),a=this.target,b=this.object.position,this.turnSpeed&&(a.x=b.x-Math.sin(this.theta)),this.tiltSpeed&&(a.y=b.y+Math.sin(this.phi),a.z=b.z-
Math.cos(this.theta)),(this.turnSpeed||this.tiltSpeed)&&this.object.lookAt(a)}};this.domElement.addEventListener("contextmenu",function(a){a.preventDefault()},!1);this.domElement.addEventListener("mousemove",c(this,this.onMouseMove),!0);this.domElement.addEventListener("mousedown",c(this,this.onMouseDown),!1);this.domElement.addEventListener("mouseup",c(this,this.onMouseUp),!1);this.domElement.addEventListener("touchstart",c(this,this.onTouchStart),!1);this.domElement.addEventListener("touchmove",
c(this,this.onTouchMove),!1);this.domElement.addEventListener("touchend",c(this,this.onTouchEnd),!1);this.domElement.addEventListener("keydown",c(this,this.onKeyDown),!1);this.domElement.addEventListener("keyup",c(this,this.onKeyUp),!1);this.domElement.addEventListener("resize",c(this,this.handleResize),!1);var d=Vizi.Gamepad.instance;d&&(d.addEventListener("buttonsChanged",c(this,this.onGamepadButtonsChanged),!1),d.addEventListener("axesChanged",c(this,this.onGamepadAxesChanged),!1));this.handleResize()};Vizi.OrbitControls=function(a,b){function c(){return 2*Math.PI/60/60*k.autoRotateSpeed}function d(a){!1!==k.enabled&&!1!==k.userRotate&&(a.preventDefault(),0===a.button||k.oneButton&&2===a.button?(p=n.ROTATE,q.set(a.clientX,a.clientY)):1===a.button&&k.userZoom?(p=n.ZOOM,w.set(a.clientX,a.clientY)):2===a.button&&k.userPan&&(p=n.PAN),k.domElement.addEventListener("mousemove",e,!1),k.domElement.addEventListener("mouseup",m,!1),k.domElement.addEventListener("touchmove",f,!1),k.domElement.addEventListener("touchend",
g,!1))}function e(a){!1!==k.enabled&&(a.preventDefault(),p===n.ROTATE?(x.set(a.clientX,a.clientY),y.subVectors(x,q),k.rotateLeft(2*Math.PI*y.x/r*k.userRotateSpeed),k.rotateUp(2*Math.PI*y.y/r*k.userRotateSpeed),q.copy(x)):p===n.ZOOM?(z.set(a.clientX,a.clientY),A.subVectors(z,w),0<A.y?k.zoomIn():k.zoomOut(),w.copy(z)):p===n.PAN&&k.pan(new THREE.Vector3(-(a.movementX||a.mozMovementX||a.webkitMovementX||0),a.movementY||a.mozMovementY||a.webkitMovementY||0,0)))}function f(a){if(!1!==k.enabled)if(1<a.changedTouches.length){for(var b=
null,c=null,d=0;d<a.changedTouches.length;d++)a.changedTouches[d].identifier==k.touchId0?b=a.changedTouches[d]:a.changedTouches[d].identifier==k.touchId1&&(c=a.changedTouches[d]);b&&(c&&k.userZoom)&&(a=h(b,c),b=a-k.touchDistance,0<b?k.zoomIn():0>b&&k.zoomOut(),k.touchDistance=a)}else k.userRotate&&e({type:"mousemove",view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,detail:a.detail,screenX:a.changedTouches[0].screenX,screenY:a.changedTouches[0].screenY,clientX:a.changedTouches[0].clientX,clientY:a.changedTouches[0].clientY,
pageX:a.changedTouches[0].pageX,pageY:a.changedTouches[0].pageY,button:0,preventDefault:function(){}})}function h(a,b){var c=b.clientX-a.clientX,d=b.clientY-a.clientY;return Math.sqrt(c*c+d*d)}function m(a){document.removeEventListener("mousemove",e,!1);document.removeEventListener("mouseup",m,!1);k.domElement.removeEventListener("touchmove",f,!1);k.domElement.removeEventListener("touchend",g,!1);p=n.NONE}function g(a){1<a.changedTouches.length||m({type:"mouseup",view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,
detail:a.detail,screenX:a.changedTouches[0].screenX,screenY:a.changedTouches[0].screenY,clientX:a.changedTouches[0].clientX,clientY:a.changedTouches[0].clientY,pageX:a.changedTouches[0].pageX,pageY:a.changedTouches[0].pageY,button:0,preventDefault:function(){}})}function l(a){a.preventDefault();if(!1!==k.enabled&&!1!==k.userZoom){var b=0;a.wheelDelta?b=a.wheelDelta:a.detail&&(b=-a.detail);0<b?k.zoomIn():k.zoomOut()}}this.object=a;this.domElement=void 0!==b?b:document;this.enabled=!0;this.center=new THREE.Vector3;
this.userZoom=!0;this.userZoomSpeed=1;this.userRotate=!0;this.userRotateSpeed=1;this.userPan=!0;this.userPanSpeed=2;this.autoRotate=!1;this.autoRotateSpeed=2;this.minPolarAngle=0;this.maxPolarAngle=Math.PI;this.minDistance=0;this.maxDistance=Infinity;this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40};this.oneButton=!1;var k=this,r=1800,q=new THREE.Vector2,x=new THREE.Vector2,y=new THREE.Vector2,w=new THREE.Vector2,z=new THREE.Vector2,A=new THREE.Vector2,s=0,t=0,u=1,B=new THREE.Vector3,n={NONE:-1,ROTATE:0,
ZOOM:1,PAN:2},p=n.NONE,C={type:"change"};this.rotateLeft=function(a){void 0===a&&(a=c());t-=a};this.rotateRight=function(a){void 0===a&&(a=c());t+=a};this.rotateUp=function(a){void 0===a&&(a=c());s-=a};this.rotateDown=function(a){void 0===a&&(a=c());s+=a};this.zoomIn=function(a){void 0===a&&(a=Math.pow(1/0.95,k.userZoomSpeed));u/=a};this.zoomOut=function(a){void 0===a&&(a=Math.pow(1/0.95,k.userZoomSpeed));u*=a};this.pan=function(a){a.transformDirection(this.object.matrix);a.multiplyScalar(k.userPanSpeed);
this.object.position.add(a);this.center.add(a)};this.update=function(){var a=this.object.position,b=a.clone().sub(this.center),d=Math.atan2(b.x,b.z),e=Math.atan2(Math.sqrt(b.x*b.x+b.z*b.z),b.y);this.autoRotate&&this.rotateLeft(c());var d=d+t,e=e+s,e=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,e)),e=Math.max(1E-6,Math.min(Math.PI-1E-6,e)),f=b.length()*u,f=Math.max(this.minDistance,Math.min(this.maxDistance,f));b.x=f*Math.sin(e)*Math.sin(d);b.y=f*Math.cos(e);b.z=f*Math.sin(e)*Math.cos(d);
a.copy(this.center).add(b);this.object.lookAt(this.center);s=t=0;u=1;0<B.distanceTo(this.object.position)&&(this.dispatchEvent(C),B.copy(this.object.position))};this.domElement.addEventListener("contextmenu",function(a){a.preventDefault()},!1);this.domElement.addEventListener("mousedown",d,!1);this.domElement.addEventListener("touchstart",function(a){1<a.touches.length?(k.touchDistance=h(a.touches[0],a.touches[1]),k.touchId0=a.touches[0].identifier,k.touchId1=a.touches[1].identifier):d({type:"mousedown",
view:a.view,bubbles:a.bubbles,cancelable:a.cancelable,detail:a.detail,screenX:a.touches[0].screenX,screenY:a.touches[0].screenY,clientX:a.touches[0].clientX,clientY:a.touches[0].clientY,pageX:a.touches[0].pageX,pageY:a.touches[0].pageY,button:0,preventDefault:function(){}})},!1);this.domElement.addEventListener("mousewheel",l,!1);this.domElement.addEventListener("DOMMouseScroll",l,!1);this.domElement.addEventListener("keydown",function(a){if(!1!==k.enabled&&!1!==k.userPan)switch(a.keyCode){case k.keys.UP:k.pan(new THREE.Vector3(0,
1,0));break;case k.keys.BOTTOM:k.pan(new THREE.Vector3(0,-1,0));break;case k.keys.LEFT:k.pan(new THREE.Vector3(-1,0,0));break;case k.keys.RIGHT:k.pan(new THREE.Vector3(1,0,0))}},!1)};Vizi.OrbitControls.prototype=Object.create(THREE.EventDispatcher.prototype);Vizi.GraphicsThreeJS=function(){Vizi.Graphics.call(this)};goog.inherits(Vizi.GraphicsThreeJS,Vizi.Graphics);Vizi.GraphicsThreeJS.prototype.initialize=function(a){a=a||{};this.initOptions(a);this.initPageElements(a);this.initScene();this.initRenderer(a);this.initMouse();this.initKeyboard();this.addDomHandlers()};Vizi.GraphicsThreeJS.prototype.focus=function(){this.renderer&&this.renderer.domElement&&this.renderer.domElement.focus()};
Vizi.GraphicsThreeJS.prototype.initOptions=function(a){this.displayStats=a&&a.displayStats?a.displayStats:Vizi.GraphicsThreeJS.default_display_stats};
Vizi.GraphicsThreeJS.prototype.initPageElements=function(a){a.container?this.container=a.container:(this.container=document.createElement("div"),document.body.appendChild(this.container));this.saved_cursor=this.container.style.cursor;this.displayStats&&(window.Stats?(a=new Stats,a.domElement.style.position="absolute",a.domElement.style.top="0px",a.domElement.style.left="0px",a.domElement.style.height="40px",this.container.appendChild(a.domElement),this.stats=a):Vizi.System.warn("No Stats module found. Make sure to include stats.min.js"))};
Vizi.GraphicsThreeJS.prototype.initScene=function(){var a=new THREE.Scene,b=new THREE.PerspectiveCamera(45,this.container.offsetWidth/this.container.offsetHeight,1,1E4);b.position.copy(Vizi.Camera.DEFAULT_POSITION);a.add(b);this.scene=a;this.camera=b;this.backgroundLayer={};a=new THREE.Scene;b=new THREE.PerspectiveCamera(45,this.container.offsetWidth/this.container.offsetHeight,0.01,1E4);b.position.set(0,0,10);a.add(b);this.backgroundLayer.scene=a;this.backgroundLayer.camera=b};
Vizi.GraphicsThreeJS.prototype.initRenderer=function(a){var b=new THREE.WebGLRenderer({antialias:void 0!==a.antialias?a.antialias:!0,alpha:void 0!==a.alpha?a.alpha:!0});b.sortObjects=!1;b.setSize(this.container.offsetWidth,this.container.offsetHeight);a&&a.backgroundColor&&(b.domElement.style.backgroundColor=a.backgroundColor,b.domElement.setAttribute("z-index",-1));this.container.appendChild(b.domElement);var c=new THREE.Projector;this.renderer=b;this.projector=c;this.lastFrameTime=0;a.riftRender&&
(this.riftCam=new THREE.OculusRiftEffect(this.renderer))};
Vizi.GraphicsThreeJS.prototype.initMouse=function(){var a=this.renderer.domElement,b=this;a.addEventListener("mousemove",function(a){b.onDocumentMouseMove(a)},!1);a.addEventListener("mousedown",function(a){b.onDocumentMouseDown(a)},!1);a.addEventListener("mouseup",function(a){b.onDocumentMouseUp(a)},!1);a.addEventListener("click",function(a){b.onDocumentMouseClick(a)},!1);a.addEventListener("dblclick",function(a){b.onDocumentMouseDoubleClick(a)},!1);a.addEventListener("mousewheel",function(a){b.onDocumentMouseScroll(a)},
!1);a.addEventListener("DOMMouseScroll",function(a){b.onDocumentMouseScroll(a)},!1);a.addEventListener("touchstart",function(a){b.onDocumentTouchStart(a)},!1);a.addEventListener("touchmove",function(a){b.onDocumentTouchMove(a)},!1);a.addEventListener("touchend",function(a){b.onDocumentTouchEnd(a)},!1)};
Vizi.GraphicsThreeJS.prototype.initKeyboard=function(){var a=this.renderer.domElement,b=this;a.addEventListener("keydown",function(a){b.onKeyDown(a)},!1);a.addEventListener("keyup",function(a){b.onKeyUp(a)},!1);a.addEventListener("keypress",function(a){b.onKeyPress(a)},!1);a.setAttribute("tabindex",1)};Vizi.GraphicsThreeJS.prototype.addDomHandlers=function(){var a=this;window.addEventListener("resize",function(b){a.onWindowResize(b)},!1)};
Vizi.GraphicsThreeJS.prototype.objectFromMouse=function(a){a=new THREE.Vector3(2*(a.elementX/this.container.offsetWidth)-1,2*-(a.elementY/this.container.offsetHeight)+1,0.5);this.projector.unprojectVector(a,this.camera);var b=new THREE.Vector3,b=b.applyMatrix4(this.camera.matrixWorld);a=(new THREE.Raycaster(b,a.sub(b).normalize())).intersectObjects(this.scene.children,!0);if(0<a.length){for(b=0;b<a.length&&(!a[b].object.visible||a[b].object.ignorePick);)b++;var c=a[b];return b>=a.length?{object:null,
point:null,normal:null}:this.findObjectFromIntersected(c.object,c.point,c.face)}return{object:null,point:null,normal:null}};
Vizi.GraphicsThreeJS.prototype.objectFromRay=function(a,b,c,d,e){b=new THREE.Raycaster(b,c,d,e);c=null;c=a?a.transform.object.children:this.scene.children;a=b.intersectObjects(c,!0);if(0<a.length){for(b=0;b<a.length&&(!a[b].object.visible||a[b].object.ignoreCollision);)b++;c=a[b];return b>=a.length?{object:null,point:null,normal:null}:this.findObjectFromIntersected(c.object,c.point,c.face)}return{object:null,point:null,normal:null}};
Vizi.GraphicsThreeJS.prototype.findObjectFromIntersected=function(a,b,c){if(a.data){var d=b.clone(),e=new THREE.Matrix4;e.getInverse(a.matrixWorld);b.applyMatrix4(e);return{object:a.data,point:b,hitPointWorld:d,face:c,normal:c?c.normal:null}}return a.parent?this.findObjectFromIntersected(a.parent,b,c):{object:null,point:null,face:null,normal:null}};
Vizi.GraphicsThreeJS.prototype.nodeFromMouse=function(a){a=new THREE.Vector3(2*(a.elementX/this.container.offsetWidth)-1,2*-(a.elementY/this.container.offsetHeight)+1,0.5);this.projector.unprojectVector(a,this.camera);var b=new THREE.Vector3,b=b.applyMatrix4(this.camera.matrixWorld);a=(new THREE.Raycaster(b,a.sub(b).normalize())).intersectObjects(this.scene.children,!0);if(0<a.length){for(b=0;!a[b].object.visible;)b++;return(a=a[b])?{node:a.object,point:a.point,normal:a.face.normal}:null}return null};
Vizi.GraphicsThreeJS.prototype.getObjectIntersection=function(a,b,c){a=new THREE.Vector3(2*(a/this.renderer.domElement.offsetWidth)-1,2*-(b/this.renderer.domElement.offsetHeight)+1,0.5);this.projector.unprojectVector(a,this.camera);b=new THREE.Vector3;b=b.applyMatrix4(this.camera.matrixWorld);c=(new THREE.Raycaster(b,a.sub(b).normalize())).intersectObject(c,!0);return c.length?(c=c[0],a=new THREE.Matrix4,a.getInverse(c.object.matrixWorld),c.point.applyMatrix4(a),c):null};
Vizi.GraphicsThreeJS.prototype.calcElementOffset=function(a){a.left=this.renderer.domElement.offsetLeft;a.top=this.renderer.domElement.offsetTop;for(var b=this.renderer.domElement.offsetParent;b;)a.left+=b.offsetLeft,a.top+=b.offsetTop,b=b.offsetParent};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseMove=function(a){a.preventDefault();var b={};this.calcElementOffset(b);a={type:a.type,pageX:a.pageX,pageY:a.pageY,elementX:a.pageX-b.left,elementY:a.pageY-b.top,button:a.button,altKey:a.altKey,ctrlKey:a.ctrlKey,shiftKey:a.shiftKey};Vizi.Mouse.instance.onMouseMove(a);Vizi.PickManager&&Vizi.PickManager.handleMouseMove(a);Vizi.Application.handleMouseMove(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseDown=function(a){a.preventDefault();var b={};this.calcElementOffset(b);a={type:a.type,pageX:a.pageX,pageY:a.pageY,elementX:a.pageX-b.left,elementY:a.pageY-b.top,button:a.button,altKey:a.altKey,ctrlKey:a.ctrlKey,shiftKey:a.shiftKey};Vizi.Mouse.instance.onMouseDown(a);Vizi.PickManager&&Vizi.PickManager.handleMouseDown(a);Vizi.Application.handleMouseDown(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseUp=function(a){a.preventDefault();var b={};this.calcElementOffset(b);a={type:a.type,pageX:a.pageX,pageY:a.pageY,elementX:a.pageX-b.left,elementY:a.pageY-b.top,button:a.button,altKey:a.altKey,ctrlKey:a.ctrlKey,shiftKey:a.shiftKey};Vizi.Mouse.instance.onMouseUp(a);Vizi.PickManager&&Vizi.PickManager.handleMouseUp(a);Vizi.Application.handleMouseUp(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseClick=function(a){a.preventDefault();var b={};this.calcElementOffset(b);a={type:a.type,pageX:a.pageX,pageY:a.pageY,elementX:a.pageX-b.left,elementY:a.pageY-b.top,button:a.button,altKey:a.altKey,ctrlKey:a.ctrlKey,shiftKey:a.shiftKey};Vizi.Mouse.instance.onMouseClick(a);Vizi.PickManager&&Vizi.PickManager.handleMouseClick(a);Vizi.Application.handleMouseClick(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseDoubleClick=function(a){a.preventDefault();var b={};this.calcElementOffset(b);var c=a.pageX-b.left,d=a.pageY-b.top,c=a.pageX-b.left,d=a.pageY-b.top;a={type:a.type,pageX:a.pageX,pageY:a.pageY,elementX:c,elementY:d,button:a.button,altKey:a.altKey,ctrlKey:a.ctrlKey,shiftKey:a.shiftKey};Vizi.Mouse.instance.onMouseDoubleClick(a);Vizi.PickManager&&Vizi.PickManager.handleMouseDoubleClick(a);Vizi.Application.handleMouseDoubleClick(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentMouseScroll=function(a){a.preventDefault();var b=0;a.wheelDelta?b=a.wheelDelta:a.detail&&(b=-a.detail);a={type:"mousescroll",delta:b};Vizi.Mouse.instance.onMouseScroll(a);Vizi.PickManager&&Vizi.PickManager.handleMouseScroll(a);Vizi.Application.handleMouseScroll(a)};
Vizi.GraphicsThreeJS.prototype.translateTouch=function(a,b){return{screenX:a.screenX,screenY:a.screenY,clientX:a.clientX,clientY:a.clientY,pageX:a.pageX,pageY:a.pageY,elementX:a.pageX-b.left,elementY:a.pageY-b.top}};
Vizi.GraphicsThreeJS.prototype.onDocumentTouchStart=function(a){a.preventDefault();var b={};this.calcElementOffset(b);var c=[],d,e=a.touches.length;for(d=0;d<e;d++)c.push(this.translateTouch(a.touches[d],b));a={type:a.type,touches:c};Vizi.PickManager&&Vizi.PickManager.handleTouchStart(a);Vizi.Application.handleTouchStart(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentTouchMove=function(a){a.preventDefault();var b={};this.calcElementOffset(b);var c=[],d,e=a.touches.length;for(d=0;d<e;d++)c.push(this.translateTouch(a.touches[d],b));var f=[],e=a.changedTouches.length;for(d=0;d<e;d++)f.push(this.translateTouch(a.changedTouches[d],b));a={type:a.type,touches:c,changedTouches:f};Vizi.PickManager&&Vizi.PickManager.handleTouchMove(a);Vizi.Application.handleTouchMove(a)};
Vizi.GraphicsThreeJS.prototype.onDocumentTouchEnd=function(a){a.preventDefault();var b={};this.calcElementOffset(b);var c=[],d,e=a.touches.length;for(d=0;d<e;d++)c.push(this.translateTouch(a.touches[d],b));var f=[],e=a.changedTouches.length;for(d=0;d<e;d++)f.push(this.translateTouch(a.changedTouches[d],b));a={type:a.type,touches:c,changedTouches:f};Vizi.PickManager&&Vizi.PickManager.handleTouchEnd(a);Vizi.Application.handleTouchEnd(a)};
Vizi.GraphicsThreeJS.prototype.onKeyDown=function(a){a.preventDefault();Vizi.Keyboard.instance.onKeyDown(a);Vizi.Application.handleKeyDown(a)};Vizi.GraphicsThreeJS.prototype.onKeyUp=function(a){a.preventDefault();Vizi.Keyboard.instance.onKeyUp(a);Vizi.Application.handleKeyUp(a)};Vizi.GraphicsThreeJS.prototype.onKeyPress=function(a){a.preventDefault();Vizi.Keyboard.instance.onKeyPress(a);Vizi.Application.handleKeyPress(a)};
Vizi.GraphicsThreeJS.prototype.onWindowResize=function(a){this.renderer.setSize(this.container.offsetWidth,this.container.offsetHeight);Vizi.CameraManager&&Vizi.CameraManager.handleWindowResize(this.container.offsetWidth,this.container.offsetHeight)||(this.camera.aspect=this.container.offsetWidth/this.container.offsetHeight,this.camera.updateProjectionMatrix())};Vizi.GraphicsThreeJS.prototype.setCursor=function(a){a||(a=this.saved_cursor);this.container.style.cursor=a};
Vizi.GraphicsThreeJS.prototype.update=function(){if(this.riftCam)this.riftCam.render([this.backgroundLayer.scene,this.scene],[this.backgroundLayer.camera,this.camera]);else{this.renderer.setClearColor(0,0);this.renderer.autoClearColor=!0;this.renderer.render(this.backgroundLayer.scene,this.backgroundLayer.camera);this.renderer.setClearColor(0,1);this.renderer.autoClearColor=!1;this.renderer.render(this.scene,this.camera);var a=Date.now();this.frameRate=1/((a-this.lastFrameTime)/1E3);this.lastFrameTime=
a;this.stats&&this.stats.update()}};Vizi.GraphicsThreeJS.prototype.enableShadows=function(a){this.renderer.shadowMapEnabled=a;this.renderer.shadowMapSoft=a;this.renderer.shadowMapCullFrontFaces=!1};Vizi.GraphicsThreeJS.default_display_stats=!1;Vizi.TweenService=function(){};goog.inherits(Vizi.TweenService,Vizi.Service);Vizi.TweenService.prototype.initialize=function(a){};Vizi.TweenService.prototype.terminate=function(){};Vizi.TweenService.prototype.update=function(){window.TWEEN&&TWEEN.update()};Vizi.Services={};Vizi.Services._serviceMap={time:{object:Vizi.Time},input:{object:Vizi.Input},tween:{object:Vizi.TweenService},events:{object:Vizi.EventService},graphics:{object:Vizi.GraphicsThreeJS}};
Vizi.Services.create=function(a){var b=Vizi.Services._serviceMap[a];if(b){if(Vizi.Services[a])throw Error("Cannot create two "+a+" service instances");if(b.object)return b=new b.object,Vizi.Services[a]=b;throw Error("No object type supplied for creating service "+a+"; cannot create");}throw Error("Unknown service: "+a+"; cannot create");};
Vizi.Services.registerService=function(a,b){if(Vizi.Services._serviceMap[a])throw Error("Service "+a+"already registered; cannot register twice");Vizi.Services._serviceMap[a]={object:b}};Vizi.Application=function(a){Vizi.EventDispatcher.call(this);Vizi.Application.instance=this;this.initialize(a)};goog.inherits(Vizi.Application,Vizi.EventDispatcher);Vizi.Application.prototype.initialize=function(a){a=a||{};this.running=!1;this.tabstop=a.tabstop;this._services=[];this._objects=[];this.addService("time");this.addService("input");this.addOptionalServices();this.addService("tween");this.addService("events");this.addService("graphics");this.initServices(a)};
Vizi.Application.prototype.addService=function(a){a=Vizi.Services.create(a);this._services.push(a)};Vizi.Application.prototype.initServices=function(a){var b,c;c=this._services.length;for(b=0;b<c;b++)this._services[b].initialize(a)};Vizi.Application.prototype.addOptionalServices=function(){};Vizi.Application.prototype.focus=function(){Vizi.Graphics.instance.focus()};Vizi.Application.prototype.run=function(){this.realizeObjects();this.lastFrameTime=Date.now();this.running=!0;this.runloop()};
Vizi.Application.prototype.runloop=function(){var a=Date.now();a-this.lastFrameTime>=Vizi.Application.minFrameTime&&(this.updateServices(),this.lastFrameTime=a);var b=this;requestAnimationFrame(function(){b.runloop()})};Vizi.Application.prototype.updateServices=function(){var a,b;b=this._services.length;for(a=0;a<b;a++)this._services[a].update()};Vizi.Application.prototype.updateObjects=function(){var a,b=this._objects.length;for(a=0;a<b;a++)this._objects[a].update()};
Vizi.Application.prototype.addObject=function(a){this._objects.push(a);this.running&&a.realize()};Vizi.Application.prototype.removeObject=function(a){a=this._objects.indexOf(a);-1!=a&&this._objects.splice(a,1)};Vizi.Application.prototype.realizeObjects=function(){var a,b=this._objects.length;for(a=0;a<b;a++)this._objects[a].realize()};Vizi.Application.prototype.onMouseMove=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseMove)this.mouseDelegate.onMouseMove(a)};
Vizi.Application.prototype.onMouseDown=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseDown)this.mouseDelegate.onMouseDown(a)};Vizi.Application.prototype.onMouseUp=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseUp)this.mouseDelegate.onMouseUp(a)};Vizi.Application.prototype.onMouseClick=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseClick)this.mouseDelegate.onMouseClick(a)};Vizi.Application.prototype.onMouseDoubleClick=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseDoubleClick)this.mouseDelegate.onMouseDoubleClick(a)};
Vizi.Application.prototype.onMouseScroll=function(a){if(this.mouseDelegate&&this.mouseDelegate.onMouseScroll)this.mouseDelegate.onMouseScroll(a)};Vizi.Application.prototype.onKeyDown=function(a){if(this.keyboardDelegate&&this.keyboardDelegate.onKeyDown)this.keyboardDelegate.onKeyDown(a)};Vizi.Application.prototype.onKeyUp=function(a){if(this.keyboardDelegate&&this.keyboardDelegate.onKeyUp)this.keyboardDelegate.onKeyUp(a)};
Vizi.Application.prototype.onKeyPress=function(a){if(this.keyboardDelegate&&this.keyboardDelegate.onKeyPress)this.keyboardDelegate.onKeyPress(a)};Vizi.Application.instance=null;Vizi.Application.curObjectID=0;Vizi.Application.minFrameTime=1;Vizi.Application.handleMouseMove=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onMouseMove)Vizi.Application.instance.onMouseMove(a)};
Vizi.Application.handleMouseDown=function(a){Vizi.Application.instance.tabstop&&Vizi.Application.instance.focus();if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onMouseDown)Vizi.Application.instance.onMouseDown(a)};Vizi.Application.handleMouseUp=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onMouseUp)Vizi.Application.instance.onMouseUp(a)};
Vizi.Application.handleMouseClick=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onMouseClick)Vizi.Application.instance.onMouseClick(a)};Vizi.Application.handleMouseDoubleClick=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onMouseDoubleClick)Vizi.Application.instance.onMouseDoubleClick(a)};Vizi.Application.handleMouseScroll=function(a){if((!Vizi.PickManager||!Vizi.PickManager.overObject)&&Vizi.Application.instance.onMouseScroll)Vizi.Application.instance.onMouseScroll(a)};
Vizi.Application.handleTouchStart=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onTouchStart)Vizi.Application.instance.onTouchStart(a)};Vizi.Application.handleTouchMove=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onTouchMove)Vizi.Application.instance.onTouchMove(a)};Vizi.Application.handleTouchEnd=function(a){if((!Vizi.PickManager||!Vizi.PickManager.clickedObject)&&Vizi.Application.instance.onTouchEnd)Vizi.Application.instance.onTouchEnd(a)};
Vizi.Application.handleKeyDown=function(a){if(Vizi.Application.instance.onKeyDown)Vizi.Application.instance.onKeyDown(a)};Vizi.Application.handleKeyUp=function(a){if(Vizi.Application.instance.onKeyUp)Vizi.Application.instance.onKeyUp(a)};Vizi.Application.handleKeyPress=function(a){if(Vizi.Application.instance.onKeyPress)Vizi.Application.instance.onKeyPress(a)};Vizi.Application.prototype.onTouchMove=function(a){if(this.touchDelegate&&this.touchDelegate.onTouchMove)this.touchDelegate.onTouchMove(a)};
Vizi.Application.prototype.onTouchStart=function(a){if(this.touchDelegate&&this.touchDelegate.onTouchStart)this.touchDelegate.onTouchStart(a)};Vizi.Application.prototype.onTouchEnd=function(a){if(this.touchDelegate&&this.touchDelegate.onTouchEnd)this.touchDelegate.onTouchEnd(a)};Vizi.AnimationService=function(){};goog.inherits(Vizi.AnimationService,Vizi.Service);Vizi.AnimationService.prototype.initialize=function(a){};Vizi.AnimationService.prototype.terminate=function(){};Vizi.AnimationService.prototype.update=function(){window.TWEEN&&THREE.glTFAnimator.update()};Vizi.Prefabs.ModelController=function(a){a=a||{};var b=new Vizi.Object(a),c=new Vizi.ModelControllerScript(a);b.addComponent(c);a=new Vizi.DirectionalLight({intensity:a.headlight?1:0});b.addComponent(a);return b};
Vizi.ModelControllerScript=function(a){Vizi.Script.call(this,a);this.radius=a.radius||Vizi.ModelControllerScript.default_radius;this.minRadius=a.minRadius||Vizi.ModelControllerScript.default_min_radius;this.minAngle=void 0!==a.minAngle?a.minAngle:Vizi.ModelControllerScript.default_min_angle;this.maxAngle=void 0!==a.maxAngle?a.maxAngle:Vizi.ModelControllerScript.default_max_angle;this.minDistance=void 0!==a.minDistance?a.minDistance:Vizi.ModelControllerScript.default_min_distance;this.maxDistance=
void 0!==a.maxDistance?a.maxDistance:Vizi.ModelControllerScript.default_max_distance;this.allowPan=void 0!==a.allowPan?a.allowPan:!0;this.allowZoom=void 0!==a.allowZoom?a.allowZoom:!0;this.allowRotate=void 0!==a.allowRotate?a.allowRotate:!0;this.oneButton=void 0!==a.oneButton?a.oneButton:!0;this._enabled=void 0!==a.enabled?a.enabled:!0;this._headlightOn=a.headlight;this.cameras=[];this.controlsList=[];Object.defineProperties(this,{camera:{get:function(){return this._camera},set:function(a){this.setCamera(a)}},
center:{get:function(){return this.controls.center},set:function(a){this.controls.center.copy(a)}},enabled:{get:function(){return this._enabled},set:function(a){this.setEnabled(a)}},headlightOn:{get:function(){return this._headlightOn},set:function(a){this.setHeadlightOn(a)}}})};goog.inherits(Vizi.ModelControllerScript,Vizi.Script);Vizi.ModelControllerScript.prototype.realize=function(){this.headlight=this._object.getComponent(Vizi.DirectionalLight);this.headlight.intensity=this._headlightOn?1:0};
Vizi.ModelControllerScript.prototype.createControls=function(a){a=new Vizi.OrbitControls(a.object,Vizi.Graphics.instance.container);a.userMinY=this.minY;a.userMinZoom=this.minZoom;a.userMaxZoom=this.maxZoom;a.minPolarAngle=this.minAngle;a.maxPolarAngle=this.maxAngle;a.minDistance=this.minDistance;a.maxDistance=this.maxDistance;a.oneButton=this.oneButton;a.userPan=this.allowPan;a.userZoom=this.allowZoom;a.userRotate=this.allowRotate;a.enabled=this._enabled;return a};
Vizi.ModelControllerScript.prototype.update=function(){this.controls.update();this._headlightOn&&this.headlight.direction.copy(this._camera.position).negate()};Vizi.ModelControllerScript.prototype.setCamera=function(a){this._camera=a;this._camera.position.set(0,this.radius/2,this.radius);this.controls=this.createControls(a)};Vizi.ModelControllerScript.prototype.setHeadlightOn=function(a){this._headlightOn=a;this.headlight&&(this.headlight.intensity=a?1:0)};
Vizi.ModelControllerScript.prototype.setEnabled=function(a){this._enabled=a;this.controls.enabled=a};Vizi.ModelControllerScript.default_radius=10;Vizi.ModelControllerScript.default_min_radius=1;Vizi.ModelControllerScript.default_min_angle=0;Vizi.ModelControllerScript.default_max_angle=Math.PI;Vizi.ModelControllerScript.default_min_distance=0;Vizi.ModelControllerScript.default_max_distance=Infinity;Vizi.ModelControllerScript.MAX_X_ROTATION=0;Vizi.ModelControllerScript.MIN_X_ROTATION=-Math.PI/2;
Vizi.ModelControllerScript.MAX_Y_ROTATION=2*Math.PI;Vizi.ModelControllerScript.MIN_Y_ROTATION=2*-Math.PI;Vizi.Prefabs.Skybox=function(a){a=a||{};var b=new Vizi.Object({layer:Vizi.Graphics.instance.backgroundLayer}),c=THREE.ShaderLib.cube;c.uniforms.tCube.value=null;c=new THREE.ShaderMaterial({fragmentShader:c.fragmentShader,vertexShader:c.vertexShader,uniforms:c.uniforms,side:THREE.BackSide});c=new Vizi.Visual({geometry:new THREE.CubeGeometry(1E4,1E4,1E4),material:c});b.addComponent(c);a=new Vizi.SkyboxScript(a);b.addComponent(a);b.realize();return b};
Vizi.SkyboxScript=function(a){Vizi.Script.call(this,a);this.maincampos=new THREE.Vector3;this.maincamrot=new THREE.Quaternion;this.maincamscale=new THREE.Vector3;Object.defineProperties(this,{texture:{get:function(){return this.uniforms.tCube.value},set:function(a){this.uniforms.tCube.value=a}}})};goog.inherits(Vizi.SkyboxScript,Vizi.Script);
Vizi.SkyboxScript.prototype.realize=function(){this.uniforms=this._object.getComponent(Vizi.Visual).material.uniforms;this.camera=Vizi.Graphics.instance.backgroundLayer.camera;this.camera.far=2E4;this.camera.position.set(0,0,0)};Vizi.SkyboxScript.prototype.update=function(){var a=Vizi.Graphics.instance.camera;a.updateMatrixWorld();a.matrixWorld.decompose(this.maincampos,this.maincamrot,this.maincamscale);this.camera.quaternion.copy(this.maincamrot)};Vizi.Prefabs.Skysphere=function(a){a=a||{};var b=new Vizi.Object({layer:Vizi.Graphics.instance.backgroundLayer}),c=new THREE.MeshBasicMaterial({color:16777215}),d=new THREE.SphereGeometry(500,32,32);d.applyMatrix((new THREE.Matrix4).makeScale(-1,1,1));c=new Vizi.Visual({geometry:d,material:c});b.addComponent(c);a=new Vizi.SkysphereScript(a);b.addComponent(a);b.realize();return b};
Vizi.SkysphereScript=function(a){Vizi.Script.call(this,a);this.maincampos=new THREE.Vector3;this.maincamrot=new THREE.Quaternion;this.maincamscale=new THREE.Vector3;Object.defineProperties(this,{texture:{get:function(){return this.material.map},set:function(a){this.material.map=a}}})};goog.inherits(Vizi.SkysphereScript,Vizi.Script);
Vizi.SkysphereScript.prototype.realize=function(){this.material=this._object.getComponent(Vizi.Visual).material;this.camera=Vizi.Graphics.instance.backgroundLayer.camera;this.camera.far=2E4;this.camera.position.set(0,0,0)};Vizi.SkysphereScript.prototype.update=function(){var a=Vizi.Graphics.instance.camera;a.updateMatrixWorld();a.matrixWorld.decompose(this.maincampos,this.maincamrot,this.maincamscale);this.camera.quaternion.copy(this.maincamrot)};Vizi.KeyFrameAnimator=function(a){Vizi.Component.call(this,a);a=a||{};this.interpdata=a.interps||[];this.animationData=a.animations;this.running=!1;this.direction=Vizi.KeyFrameAnimator.FORWARD_DIRECTION;this.duration=a.duration?a.duration:Vizi.KeyFrameAnimator.default_duration;this.loop=a.loop?a.loop:!1;this.easing=a.easing};goog.inherits(Vizi.KeyFrameAnimator,Vizi.Component);
Vizi.KeyFrameAnimator.prototype.realize=function(){Vizi.Component.prototype.realize.call(this);this.interpdata&&this.createInterpolators(this.interpdata);if(this.animationData){this.animations=[];var a,b=this.animationData.length;for(a=0;a<b;a++){var c=this.animationData[a];c instanceof THREE.glTFAnimation||(THREE.AnimationHandler.add(c),c=new THREE.KeyFrameAnimation(c.node,c.name));this.animations.push(c)}}};
Vizi.KeyFrameAnimator.prototype.createInterpolators=function(a){this.interps=[];var b,c=a.length;for(b=0;b<c;b++){var d=a[b],d=new Vizi.Interpolator({keys:d.keys,values:d.values,target:d.target});d.realize();this.interps.push(d)}};
Vizi.KeyFrameAnimator.prototype.start=function(){if(!this.running&&(this.lastTime=this.startTime=Date.now(),this.running=!0,this.animations)){var a,b=this.animations.length;for(a=0;a<b;a++)this.animations[a].loop=this.loop,this.animations[a]instanceof THREE.glTFAnimation&&(this.animations[a].direction=this.direction==Vizi.KeyFrameAnimator.FORWARD_DIRECTION?THREE.glTFAnimation.FORWARD_DIRECTION:THREE.glTFAnimation.REVERSE_DIRECTION),this.animations[a].play(this.loop,0),this.endTime=this.startTime+
this.animations[a].endTime/this.animations[a].timeScale,isNaN(this.endTime)&&(this.endTime=this.startTime+1E3*this.animations[a].duration)}};Vizi.KeyFrameAnimator.prototype.stop=function(){this.running=!1;this.dispatchEvent("complete");if(this.animations){var a,b=this.animations.length;for(a=0;a<b;a++)this.animations[a].stop()}};
Vizi.KeyFrameAnimator.prototype.update=function(){if(this.running)if(this.animations)this.updateAnimations();else{var a=Date.now(),b=Math.floor((a-this.startTime)/this.duration),a=(a-this.startTime)%this.duration/this.duration;this.easing&&(a=this.easing(a));if(1<=b&&!this.loop){this.running=!1;this.dispatchEvent("complete");for(var c=this.interps.length,b=0;b<c;b++)this.interps[b].interp(1)}else for(c=this.interps.length,b=0;b<c;b++)this.interps[b].interp(a)}};
Vizi.KeyFrameAnimator.prototype.updateAnimations=function(){var a=Date.now(),b=a-this.lastTime,c=!1,d,e=this.animations.length;for(d=0;d<e;d++)this.animations[d].update(b),!this.loop&&a>=this.endTime&&(c=!0);this.lastTime=a;c&&this.stop()};Vizi.KeyFrameAnimator.default_duration=1E3;Vizi.KeyFrameAnimator.FORWARD_DIRECTION=0;Vizi.KeyFrameAnimator.REVERSE_DIRECTION=1;Vizi.Prefabs.RiftController=function(a){a=a||{};var b=new Vizi.Object(a);a=new Vizi.RiftControllerScript(a);b.addComponent(a);return b};Vizi.RiftControllerScript=function(a){Vizi.Script.call(this,a);this._enabled=void 0!==a.enabled?a.enabled:!0;this.riftControls=this.oculusBridge=null;this.useVRJS=void 0!==a.useVRJS?a.useVRJS:!1;Object.defineProperties(this,{camera:{get:function(){return this._camera},set:function(a){this.setCamera(a)}},enabled:{get:function(){return this._enabled},set:function(a){this.setEnabled(a)}}})};
goog.inherits(Vizi.RiftControllerScript,Vizi.Script);
Vizi.RiftControllerScript.prototype.realize=function(){this.bodyAngle=0;this.bodyAxis=new THREE.Vector3(0,1,0);this.bodyPosition=new THREE.Vector3(0,15,0);this.velocity=new THREE.Vector3;var a=this;this.useVRJS?(this.vrstate=null,vr.load(function(){a.vrstate=new vr.State})):(this.oculusBridge=new OculusBridge({debug:!0,onOrientationUpdate:function(b){a.bridgeOrientationUpdated(b)},onConfigUpdate:function(b){a.bridgeConfigUpdated(b)},onConnect:function(b){a.bridgeConnected(b)},onDisconnect:function(b){a.bridgeDisconnected(b)}}),
this.oculusBridge.connect())};Vizi.RiftControllerScript.prototype.update=function(){if(this._enabled&&this.useVRJS&&this.vrstate){var a=vr.pollState(this.vrstate);this.riftControls.update(this.clock.getDelta(),a?this.vrstate:null)}};Vizi.RiftControllerScript.prototype.setEnabled=function(a){this._enabled=a};Vizi.RiftControllerScript.prototype.setCamera=function(a){this._camera=a;this.useVRJS&&(this.riftControls=this.createControls(a))};
Vizi.RiftControllerScript.prototype.createControls=function(a){a=new Vizi.OculusRiftControls(a.object);this.clock=new THREE.Clock;return a};Vizi.RiftControllerScript.prototype.bridgeOrientationUpdated=function(a){var b=new THREE.Quaternion;b.setFromAxisAngle(this.bodyAxis,this.bodyAngle);a=new THREE.Quaternion(a.x,a.y,a.z,a.w);b.multiply(a);a=new THREE.Vector3(0,0,1);a.applyQuaternion(b);viewAngle=Math.atan2(a.z,a.x)+Math.PI;this._camera.quaternion.copy(b)};
Vizi.RiftControllerScript.prototype.bridgeConnected=function(){};Vizi.RiftControllerScript.prototype.bridgeDisconnected=function(){};Vizi.RiftControllerScript.prototype.bridgeConfigUpdated=function(a){};Vizi.Interpolator=function(a){Vizi.EventDispatcher.call(a);a=a||{};this.keys=a.keys||[];this.values=a.values||[];this.target=a.target?a.target:null;this.running=!1};goog.inherits(Vizi.Interpolator,Vizi.EventDispatcher);Vizi.Interpolator.prototype.realize=function(){this.keys&&this.values&&this.setValue(this.keys,this.values)};Vizi.Interpolator.prototype.setValue=function(a,b){this.keys=[];this.values=[];a&&(a.length&&b&&b.length)&&(this.copyKeys(a,this.keys),this.copyValues(b,this.values))};
Vizi.Interpolator.prototype.copyKeys=function(a,b){for(var c=0,d=a.length,c=0;c<d;c++)b[c]=a[c]};Vizi.Interpolator.prototype.copyValues=function(a,b){for(var c=0,d=a.length,c=0;c<d;c++){var e={};this.copyValue(a[c],e);b[c]=e}};Vizi.Interpolator.prototype.copyValue=function(a,b){for(var c in a)null!==a[c]&&(b[c]=a[c])};
Vizi.Interpolator.prototype.interp=function(a){var b,c,d=this.keys.length;a==this.keys[0]?b=this.values[0]:a>=this.keys[d-1]&&(b=this.values[d-1]);for(c=0;c<d-1;c++){var e=this.keys[c],f=this.keys[c+1];a>=e&&a<=f&&(b=this.tween(this.values[c],this.values[c+1],(a-e)/(f-e)))}this.target?this.copyValue(b,this.target):this.publish("value",b)};Vizi.Interpolator.prototype.tween=function(a,b,c){var d={},e;for(e in a)null!==a[e]&&(d[e]=a[e]+(b[e]-a[e])*c);return d};Vizi.Prefabs.PointerLockController=function(a){a=a||{};var b=new Vizi.Object(a),c=new Vizi.PointerLockControllerScript(a);b.addComponent(c);a=new Vizi.DirectionalLight({intensity:a.headlight?1:0});b.addComponent(a);return b};
Vizi.PointerLockControllerScript=function(a){Vizi.Script.call(this,a);this._enabled=void 0!==a.enabled?a.enabled:!0;this._move=void 0!==a.move?a.move:!0;this._look=void 0!==a.look?a.look:!0;this._turn=void 0!==a.turn?a.turn:!0;this._tilt=void 0!==a.tilt?a.tilt:!0;this._mouseLook=void 0!==a.mouseLook?a.mouseLook:!1;this.collisionDistance=10;this.moveSpeed=13;this.tiltSpeed=this.turnSpeed=5;this.lookSpeed=1;this.savedCameraPos=new THREE.Vector3;this.movementVector=new THREE.Vector3;Object.defineProperties(this,
{camera:{get:function(){return this._camera},set:function(a){this.setCamera(a)}},enabled:{get:function(){return this._enabled},set:function(a){this.setEnabled(a)}},move:{get:function(){return this._move},set:function(a){this.setMove(a)}},look:{get:function(){return this._look},set:function(a){this.setLook(a)}},mouseLook:{get:function(){return this._mouseLook},set:function(a){this.setMouseLook(a)}},headlightOn:{get:function(){return this._headlightOn},set:function(a){this.setHeadlightOn(a)}}})};
goog.inherits(Vizi.PointerLockControllerScript,Vizi.Script);Vizi.PointerLockControllerScript.prototype.realize=function(){this.headlight=this._object.getComponent(Vizi.DirectionalLight);this.headlight.intensity=this._headlightOn?1:0};
Vizi.PointerLockControllerScript.prototype.createControls=function(a){a=new Vizi.PointerLockControls(a.object,Vizi.Graphics.instance.container);a.mouseLook=this._mouseLook;a.movementSpeed=this._move?this.moveSpeed:0;a.lookSpeed=this._look?this.lookSpeed:0;a.turnSpeed=this._turn?this.turnSpeed:0;a.tiltSpeed=this._tilt?this.tiltSpeed:0;this.clock=new THREE.Clock;return a};
Vizi.PointerLockControllerScript.prototype.update=function(){this.saveCamera();this.controls.update(this.clock.getDelta());var a=this.testCollision();a&&a.object&&(this.restoreCamera(),this.dispatchEvent("collide",a));this.testTerrain()&&this.restoreCamera();this._headlightOn&&this.headlight.direction.copy(this._camera.position).negate()};Vizi.PointerLockControllerScript.prototype.setEnabled=function(a){this._enabled=a;this.controls.enabled=a};
Vizi.PointerLockControllerScript.prototype.setMove=function(a){this._move=a;this.controls.movementSpeed=a?this.moveSpeed:0};Vizi.PointerLockControllerScript.prototype.setLook=function(a){this._look=a;this.controls.lookSpeed=a?1:0};Vizi.PointerLockControllerScript.prototype.setMouseLook=function(a){this._mouseLook=a;this.controls.mouseLook=a};
Vizi.PointerLockControllerScript.prototype.setCamera=function(a){this._camera=a;this.controls=this.createControls(a);this.controls.movementSpeed=this.moveSpeed;this.controls.lookSpeed=this._look?0.1:0};Vizi.PointerLockControllerScript.prototype.saveCamera=function(){this.savedCameraPos.copy(this._camera.position)};Vizi.PointerLockControllerScript.prototype.restoreCamera=function(){this._camera.position.copy(this.savedCameraPos)};
Vizi.PointerLockControllerScript.prototype.testCollision=function(){this.movementVector.copy(this._camera.position).sub(this.savedCameraPos);if(this.movementVector.length()){var a=Vizi.Graphics.instance.objectFromRay(null,this.savedCameraPos,this.movementVector,1,2);a&&a.object&&this.savedCameraPos.distanceTo(a.hitPointWorld);return a}return null};Vizi.PointerLockControllerScript.prototype.testTerrain=function(){return!1};
Vizi.PointerLockControllerScript.prototype.setHeadlightOn=function(a){this._headlightOn=a;this.headlight&&(this.headlight.intensity=a?1:0)};Vizi.PerspectiveCamera=function(a){a=a||{};if(a.object)this.object=a.object;else{var b=a.fov||45,c=a.near||Vizi.Camera.DEFAULT_NEAR,d=a.far||Vizi.Camera.DEFAULT_FAR,e=Vizi.Graphics.instance.container,e=a.aspect||e.offsetWidth/e.offsetHeight;this.updateProjection=!1;this.object=new THREE.PerspectiveCamera(b,e,c,d)}Object.defineProperties(this,{fov:{get:function(){return this.object.fov},set:function(a){this.object.fov=a;this.updateProjection=!0}},aspect:{get:function(){return this.object.aspect},set:function(a){this.object.aspect=
a;this.updateProjection=!0}},near:{get:function(){return this.object.near},set:function(a){this.object.near=a;this.updateProjection=!0}},far:{get:function(){return this.object.far},set:function(a){this.object.far=a;this.updateProjection=!0}}});Vizi.Camera.call(this,a)};goog.inherits(Vizi.PerspectiveCamera,Vizi.Camera);Vizi.PerspectiveCamera.prototype.realize=function(){Vizi.Camera.prototype.realize.call(this)};
Vizi.PerspectiveCamera.prototype.update=function(){this.updateProjection&&(this.object.updateProjectionMatrix(),this.updateProjection=!1)};Vizi.Helpers={};Vizi.Helpers.BoundingBoxDecoration=function(a){a=a||{};if(!a.object)return Vizi.warn("Vizi.Helpers.BoundingBoxDecoration requires an object"),null;var b=void 0!==a.color?a.color:8947848;a=Vizi.SceneUtils.computeBoundingBox(a.object);var c=a.max.x-a.min.x,d=a.max.y-a.min.y,e=a.max.z-a.min.z,f=new THREE.BoxHelper;f.material.color.setHex(b);f.scale.set(c/2,d/2,e/2);b=new Vizi.Decoration({object:f});a=a.max.clone().add(a.min).multiplyScalar(0.5);b.position.add(a);return b};
Vizi.Helpers.VectorDecoration=function(a){a=a||{};var b=a.start||new THREE.Vector3,c=a.end||new THREE.Vector3(0,1,0),d=void 0!==a.color?a.color:8947848;a=new THREE.Geometry;a.vertices.push(b,c);b=new THREE.LineBasicMaterial({color:d});b=new THREE.Line(a,b);return new Vizi.Decoration({object:b})};
Vizi.Helpers.PlaneDecoration=function(a){a=a||{};if(!a.normal&&!a.triangle)return Vizi.warn("Vizi.Helpers.PlaneDecoration requires either a normal or three coplanar points"),null;var b=a.normal;if(!b)return Vizi.warn("Vizi.Helpers.PlaneDecoration creating plane from coplanar points not implemented yet"),null;var c=a.position||new THREE.Vector3,d=a.size||1;a=void 0!==a.color?a.color:8947848;var e=(new THREE.Vector3(0,b.z,-b.y)).normalize().multiplyScalar(d),f=e.clone().cross(b).normalize().multiplyScalar(d),
d=c.clone().sub(e).sub(f),h=c.clone().add(e).sub(f),m=c.clone().add(e).add(f),e=c.clone().sub(e).add(f),c=new THREE.Geometry;c.vertices.push(d,h,m,e);d=new THREE.Face3(0,1,2);d.normal.copy(b);d.vertexNormals.push(b.clone(),b.clone(),b.clone(),b.clone());c.faces.push(d);d=new THREE.Face3(0,2,3);d.normal.copy(b);d.vertexNormals.push(b.clone(),b.clone(),b.clone(),b.clone());c.faces.push(d);c.computeFaceNormals();c.computeCentroids();b=new THREE.MeshBasicMaterial({color:a,transparent:!0,side:THREE.DoubleSide,
opacity:0.1});b=new THREE.Mesh(c,b);return new Vizi.Decoration({object:b})};Vizi.SceneUtils={};
Vizi.SceneUtils.computeBoundingBox=function(a){var b=function(a){if(a instanceof THREE.Mesh&&!a.ignoreBounds){var d=a.geometry;return d?(d.boundingBox||d.computeBoundingBox(),d=d.boundingBox.clone(),a.updateMatrix(),d.applyMatrix4(a.matrix),d):new THREE.Box3(new THREE.Vector3,new THREE.Vector3)}for(var e=a.children.length,f=new THREE.Box3,d=0;d<e;d++){var h=b(a.children[d]);h.min.x<f.min.x&&(f.min.x=h.min.x);h.max.x>f.max.x&&(f.max.x=h.max.x);h.min.y<f.min.y&&(f.min.y=h.min.y);h.max.y>f.max.y&&(f.max.y=
h.max.y);h.min.z<f.min.z&&(f.min.z=h.min.z);h.max.z>f.max.z&&(f.max.z=h.max.z)}isFinite(f.min.x)&&(a.updateMatrix(),f.applyMatrix4(a.matrix));return f};return a instanceof Vizi.Object?b(a.transform.object):a instanceof Vizi.Visual?b(a.object):new THREE.Box3(new THREE.Vector3,new THREE.Vector3)};Vizi.OculusRiftControls=function(a){var b=this,c=!1,d=!1,e=!1,f=!1,h=!1,m=!1,g=new THREE.Vector3;this.moveSpeed=0.03;this.jumpSpeed=2;var l=new THREE.Quaternion,k=new THREE.Vector3(1,0,0),r=new THREE.Vector3(0,0,1),q=function(a){switch(a.keyCode){case 38:case 87:c=!0;break;case 37:case 65:e=!0;break;case 40:case 83:d=!0;break;case 39:case 68:f=!0;break;case 32:!0===m&&(g.y+=this.jumpSpeed),m=!1}}.bind(this);document.addEventListener("mousemove",function(c){if(!1!==b.enabled){var d=c.movementX||c.mozMovementX||
c.webkitMovementX||0;c=c.movementY||c.mozMovementY||c.webkitMovementY||0;console.log(d,c);l.setFromAxisAngle(r,0.0020*d);a.quaternion.multiplySelf(l);l.setFromAxisAngle(k,0.0020*c);a.quaternion.multiplySelf(l)}},!1);document.addEventListener("keydown",q,!1);document.addEventListener("keyup",function(a){switch(a.keyCode){case 38:case 87:c=!1;break;case 37:case 65:e=!1;break;case 40:case 83:d=!1;break;case 39:case 68:f=!1}},!1);this.enabled=!1;this.getObject=function(){return a};this.isOnObject=function(a){m=
h=a};this.update=function(b,k){b*=0.1;g.x+=0.08*-g.x*b;g.z+=0.08*-g.z*b;g.y-=0.1*b;c&&(g.z-=this.moveSpeed*b);d&&(g.z+=this.moveSpeed*b);e&&(g.x-=this.moveSpeed*b);f&&(g.x+=this.moveSpeed*b);!0===h&&(g.y=Math.max(0,g.y));var l=new THREE.Quaternion;new THREE.Euler;k&&(l.set(k.hmd.rotation[0],k.hmd.rotation[1],k.hmd.rotation[2],k.hmd.rotation[3]),0==l.x&&0==l.y&&0==l.z&&0==l.w||a.quaternion.copy(l));10>a.position.y&&(g.y=0,m=!0)}};Vizi.System={log:function(){var a=["[Vizi] "].concat([].slice.call(arguments));console.log.apply(console,a)},warn:function(){var a=["[Vizi] "].concat([].slice.call(arguments));console.warn.apply(console,a)},error:function(){var a=["[Vizi] "].concat([].slice.call(arguments));console.error.apply(console,a)}};Vizi.HighlightBehavior=function(a){a=a||{};this.highlightColor=void 0!==a.highlightColor?a.highlightColor:16777215;this.savedColors=[];Vizi.Behavior.call(this,a)};goog.inherits(Vizi.HighlightBehavior,Vizi.Behavior);Vizi.HighlightBehavior.prototype.start=function(){Vizi.Behavior.prototype.start.call(this);if(this._realized&&this._object.visuals){var a=this._object.visuals,b,c=a.length;for(b=0;b<c;b++)this.savedColors.push(a[b].material.color.getHex()),a[b].material.color.setHex(this.highlightColor)}};
Vizi.HighlightBehavior.prototype.evaluate=function(a){};Vizi.HighlightBehavior.prototype.stop=function(){Vizi.Behavior.prototype.stop.call(this);if(this._realized&&this._object.visuals){var a=this._object.visuals,b,c=a.length;for(b=0;b<c;b++)a[b].material.color.setHex(this.savedColors[b])}};Vizi.HighlightBehavior.prototype.on=Vizi.HighlightBehavior.prototype.start;Vizi.HighlightBehavior.prototype.off=Vizi.HighlightBehavior.prototype.stop;Vizi.BounceBehavior=function(a){a=a||{};this.duration=void 0!==a.duration?a.duration:1;this.bounceVector=void 0!==a.bounceVector?a.bounceVector:new THREE.Vector3(0,1,0);this.tweenDown=this.tweenUp=null;Vizi.Behavior.call(this,a)};goog.inherits(Vizi.BounceBehavior,Vizi.Behavior);
Vizi.BounceBehavior.prototype.start=function(){this.running||(this.bouncePosition=new THREE.Vector3,this.bounceEndPosition=this.bounceVector.clone(),this.prevBouncePosition=new THREE.Vector3,this.bounceDelta=new THREE.Vector3,this.tweenUp=(new TWEEN.Tween(this.bouncePosition)).to(this.bounceEndPosition,1E3*(this.duration/2)).easing(TWEEN.Easing.Quadratic.InOut).repeat(0).start(),Vizi.Behavior.prototype.start.call(this))};
Vizi.BounceBehavior.prototype.evaluate=function(a){this.bounceDelta.copy(this.bouncePosition).sub(this.prevBouncePosition);this.prevBouncePosition.copy(this.bouncePosition);this._object.transform.position.add(this.bounceDelta);a>=this.duration/2&&(this.tweenUp&&(this.tweenUp.stop(),this.tweenUp=null),this.tweenDown||(this.bouncePosition=this._object.transform.position.clone(),this.bounceEndPosition=this.bouncePosition.clone().sub(this.bounceVector),this.prevBouncePosition=this.bouncePosition.clone(),
this.bounceDelta=new THREE.Vector3,this.tweenDown=(new TWEEN.Tween(this.bouncePosition)).to(this.bounceEndPosition,1E3*(this.duration/2)).easing(TWEEN.Easing.Quadratic.InOut).repeat(0).start()));a>=this.duration&&(this.tweenDown.stop(),this.tweenDown=null,this.stop(),this.loop&&this.start())};Vizi.CameraManager={};Vizi.CameraManager.addCamera=function(a){Vizi.CameraManager.cameraList.push(a)};Vizi.CameraManager.removeCamera=function(a){a=Vizi.CameraManager.cameraList.indexOf(a);-1!=a&&Vizi.CameraManager.cameraList.splice(a,1)};Vizi.CameraManager.setActiveCamera=function(a){Vizi.CameraManager.activeCamera&&Vizi.CameraManager.activeCamera!=a&&(Vizi.CameraManager.activeCamera.active=!1);Vizi.CameraManager.activeCamera=a;Vizi.Graphics.instance.camera=a.object};
Vizi.CameraManager.handleWindowResize=function(a,b){var c=Vizi.CameraManager.cameraList;if(0==c.length)return!1;var d,e=c.length;for(d=0;d<e;d++)c[d].aspect=a/b;return!0};Vizi.CameraManager.cameraList=[];Vizi.CameraManager.activeCamera=null;Vizi.Prefabs.HUD=function(a){a=a||{};var b=new Vizi.Object;a=new Vizi.HUDScript(a);b.addComponent(a);return b};Vizi.HUDScript=function(a){Vizi.Script.call(this,a);this.zDistance=void 0!==a.zDistance?a.zDistance:Vizi.HUDScript.DEFAULT_Z_DISTANCE;this.position=new THREE.Vector3(0,0,-this.zDistance);this.scale=new THREE.Vector3;this.quaternion=new THREE.Quaternion};goog.inherits(Vizi.HUDScript,Vizi.Script);Vizi.HUDScript.prototype.realize=function(){};
Vizi.HUDScript.prototype.update=function(){var a=Vizi.Graphics.instance.camera;a.updateMatrixWorld();a.matrixWorld.decompose(this.position,this.quaternion,this.scale);this._object.transform.quaternion.copy(this.quaternion);this._object.transform.position.copy(this.position);this._object.transform.translateZ(-this.zDistance)};Vizi.HUDScript.DEFAULT_Z_DISTANCE=1;Vizi.Loader=function(){Vizi.EventDispatcher.call(this)};goog.inherits(Vizi.Loader,Vizi.EventDispatcher);Vizi.Loader.prototype.loadModel=function(a,b){var c=a.split("."),d=c.length,e="";d&&(e=c[d-1]);if(e&&e.length){var f;switch(e.toUpperCase()){case "JS":f=THREE.JSONLoader}if(f){var h=this;(new f).load(a,function(c,d){h.handleModelLoaded(a,b,c,d)})}}};
Vizi.Loader.prototype.handleModelLoaded=function(a,b,c,d){a=new THREE.MeshFaceMaterial(d);a=new THREE.Mesh(c,a);c=new Vizi.Object;a=new Vizi.Visual({object:a});c.addComponent(a);this.dispatchEvent("loaded",{scene:c,cameras:[],lights:[],keyFrameAnimators:[],userData:b})};
Vizi.Loader.prototype.loadScene=function(a,b){var c=a.split("."),d=c.length,e="";d&&(e=c[d-1]);if(e&&e.length){var f;switch(e.toUpperCase()){case "DAE":f=THREE.ColladaLoader;break;case "JS":return this.loadModel(a,b);case "JSON":f=THREE.glTFLoader}if(f){var h=this;(new f).load(a,function(c){h.handleSceneLoaded(a,c,b)},function(b){h.handleSceneProgress(a,b)})}}};
Vizi.Loader.prototype.traverseCallback=function(a,b){a instanceof THREE.Camera&&(b.cameras||(b.cameras=[]),b.cameras.push(a));a instanceof THREE.Light&&(b.lights||(b.lights=[]),b.lights.push(a))};
Vizi.Loader.prototype.handleSceneLoaded=function(a,b,c){var d={},e=!1;b.scene&&(console.log("In loaded callback for ",a),e=this.convertScene(b.scene),d.scene=e,d.cameras=e.findNodes(Vizi.Camera),d.lights=e.findNodes(Vizi.Light),d.url=a,d.userData=c,e=!0);if(b.animations)for(d.keyFrameAnimators=[],c=b.animations.length,a=0;a<c;a++){var f=[];f.push(b.animations[a]);d.keyFrameAnimators.push(new Vizi.KeyFrameAnimator({animations:f}))}e&&this.dispatchEvent("loaded",d)};
Vizi.Loader.prototype.handleSceneProgress=function(a,b){this.dispatchEvent("progress",b)};
Vizi.Loader.prototype.convertScene=function(a){function b(a){if(a instanceof THREE.Mesh){a.matrixAutoUpdate=!0;a.geometry.dynamic=!0;var d=new Vizi.Visual({object:a});d.name=a.name;return d}if(a instanceof THREE.Camera){if(a instanceof THREE.PerspectiveCamera)return new Vizi.PerspectiveCamera({object:a})}else if(a instanceof THREE.Light){if(a instanceof THREE.AmbientLight)return new Vizi.AmbientLight({object:a});if(a instanceof THREE.DirectionalLight)return new Vizi.DirectionalLight({object:a});if(a instanceof
THREE.PointLight)return new Vizi.PointLight({object:a});if(a instanceof THREE.SpotLight)return new Vizi.SpotLight({object:a})}else if(a.children){d=new Vizi.Object({autoCreateTransform:!1});d.addComponent(new Vizi.Transform({object:a}));d.name=a.name;a.matrixAutoUpdate=!0;var e,f=a.children.length;for(e=0;e<f;e++){var h=b(a.children[e]);h instanceof Vizi.Object?d.addChild(h):h instanceof Vizi.Component&&d.addComponent(h)}}return d}a.updateMatrixWorld();return b(a)};Vizi.ParticleEmitter=function(a){this.param=a||{};Vizi.Component.call(this,a);a=this.param.size||Vizi.ParticleEmitter.DEFAULT_SIZE;var b=this.param.sizeEnd||Vizi.ParticleEmitter.DEFAULT_SIZE_END,c=this.param.colorStart||Vizi.ParticleEmitter.DEFAULT_COLOR_START,d=this.param.colorEnd||Vizi.ParticleEmitter.DEFAULT_COLOR_END,e=this.param.particlesPerSecond||Vizi.ParticleEmitter.DEFAULT_PARTICLES_PER_SECOND,f=this.param.opacityStart||Vizi.ParticleEmitter.DEFAULT_OPACITY_START,h=this.param.opacityMiddle||
Vizi.ParticleEmitter.DEFAULT_OPACITY_MIDDLE,m=this.param.opacityEnd||Vizi.ParticleEmitter.DEFAULT_OPACITY_END,g=this.param.velocity||Vizi.ParticleEmitter.DEFAULT_VELOCITY,l=this.param.acceleration||Vizi.ParticleEmitter.DEFAULT_ACCELERATION,k=this.param.positionSpread||Vizi.ParticleEmitter.DEFAULT_POSITION_SPREAD,r=this.param.accelerationSpread||Vizi.ParticleEmitter.DEFAULT_ACCELERATION_SPREAD,q=this.param.blending||Vizi.ParticleEmitter.DEFAULT_BLENDING;this._active=!1;this.object=new ShaderParticleEmitter({size:a,
sizeEnd:b,colorStart:c,colorEnd:d,particlesPerSecond:e,opacityStart:f,opacityMiddle:h,opacityEnd:m,velocity:g,acceleration:l,positionSpread:k,accelerationSpread:r,blending:q});Object.defineProperties(this,{active:{get:function(){return this._active},set:function(a){this.setActive(a)}}})};goog.inherits(Vizi.ParticleEmitter,Vizi.Component);Vizi.ParticleEmitter.prototype.realize=function(){};Vizi.ParticleEmitter.prototype.update=function(){};
Vizi.ParticleEmitter.prototype.setActive=function(a){(this._active=a)?this.object.enable():this.object.disable()};Vizi.ParticleEmitter.DEFAULT_SIZE=1;Vizi.ParticleEmitter.DEFAULT_SIZE_END=1;Vizi.ParticleEmitter.DEFAULT_COLOR_START=new THREE.Color;Vizi.ParticleEmitter.DEFAULT_COLOR_END=new THREE.Color;Vizi.ParticleEmitter.DEFAULT_PARTICLES_PER_SECOND=10;Vizi.ParticleEmitter.DEFAULT_OPACITY_START=0.1;Vizi.ParticleEmitter.DEFAULT_OPACITY_MIDDLE=0.5;Vizi.ParticleEmitter.DEFAULT_OPACITY_END=0;
Vizi.ParticleEmitter.DEFAULT_VELOCITY=new THREE.Vector3(0,10,0);Vizi.ParticleEmitter.DEFAULT_ACCELERATION=new THREE.Vector3(0,1,0);Vizi.ParticleEmitter.DEFAULT_POSITION_SPREAD=new THREE.Vector3(0,0,0);Vizi.ParticleEmitter.DEFAULT_ACCELERATION_SPREAD=new THREE.Vector3(0,1,0);Vizi.ParticleEmitter.DEFAULT_BLENDING=THREE.NoBlending;Vizi.Gamepad=function(){Vizi.EventDispatcher.call(this);this.controllers={};this.values={};Vizi.Gamepad.instance=this};goog.inherits(Vizi.Gamepad,Vizi.EventDispatcher);Vizi.Gamepad.prototype.update=function(){this.scanGamepads();var a={changedButtons:[]},b={changedAxes:[]},c;for(c in this.controllers){var d=this.controllers[c];this.testValues(d,a,b);this.saveValues(d)}a.changedButtons.length&&this.dispatchEvent("buttonsChanged",a);b.changedAxes.length&&this.dispatchEvent("axesChanged",b)};
Vizi.Gamepad.prototype.testValues=function(a,b,c){var d=this.values[a.index];if(d){for(var e=0;e<a.buttons.length;e++){var f=a.buttons[e],h=1==f;"object"==typeof f&&(h=f.pressed);h!=d.buttons[e]&&b.changedButtons.push({gamepad:a.index,button:e,pressed:h})}for(e=0;e<a.axes.length;e++)f=a.axes[e],f!=d.axes[e]&&c.changedAxes.push({gamepad:a.index,axis:e,value:f})}};
Vizi.Gamepad.prototype.saveValues=function(a){var b=this.values[a.index];if(b){for(var c=0;c<a.buttons.length;c++){var d=a.buttons[c],e=1==d;"object"==typeof d&&(e=d.pressed);b.buttons[c]=e}for(c=0;c<a.axes.length;c++)d=a.axes[c],b.axes[c]=d}};Vizi.Gamepad.prototype.addGamepad=function(a){this.controllers[a.index]=a;this.values[a.index]={buttons:[],axes:[]};this.saveValues(a);console.log("Gamepad added! ",a.id)};
Vizi.Gamepad.prototype.scanGamepads=function(){for(var a=navigator.getGamepads?navigator.getGamepads():navigator.webkitGetGamepads?navigator.webkitGetGamepads():[],b=0;b<a.length;b++)a[b]&&(a[b].index in this.controllers?this.controllers[a[b].index]=a[b]:this.addGamepad(a[b]))};Vizi.Gamepad.instance=null;Vizi.Gamepad.BUTTON_A=Vizi.Gamepad.BUTTON_CROSS=0;Vizi.Gamepad.BUTTON_B=Vizi.Gamepad.BUTTON_CIRCLE=1;Vizi.Gamepad.BUTTON_X=Vizi.Gamepad.BUTTON_SQUARE=2;
Vizi.Gamepad.BUTTON_Y=Vizi.Gamepad.BUTTON_TRIANGLE=3;Vizi.Gamepad.SHOULDER_LEFT=4;Vizi.Gamepad.SHOULDER_RIGHT=5;Vizi.Gamepad.TRIGGER_LEFT=6;Vizi.Gamepad.TRIGGER_RIGHT=7;Vizi.Gamepad.SELECT=Vizi.Gamepad.BACK=8;Vizi.Gamepad.START=9;Vizi.Gamepad.STICK_LEFT=10;Vizi.Gamepad.STICK_RIGHT=11;Vizi.Gamepad.DPAD_UP=12;Vizi.Gamepad.DPAD_DOWN=13;Vizi.Gamepad.DPAD_LEFT=14;Vizi.Gamepad.DPAD_RIGHT=15;Vizi.Gamepad.HOME=Vizi.Gamepad.MENU=16;Vizi.Gamepad.AXIS_LEFT_H=0;Vizi.Gamepad.AXIS_LEFT_V=1;
Vizi.Gamepad.AXIS_RIGHT_H=2;Vizi.Gamepad.AXIS_RIGHT_V=3;Vizi.DeviceOrientationControls=function(a){function b(a,b){return function(){b.apply(a,arguments)}}this.object=a;this.object.rotation.reorder("YXZ");this.roll=this.freeze=!0;this.deviceOrientation={};this.screenOrientation=0;this.onDeviceOrientationChangeEvent=function(a){this.deviceOrientation=a};this.onScreenOrientationChangeEvent=function(){this.screenOrientation=window.orientation||0};this.update=function(){var a,b,e;return function(){this.freeze||(a=this.deviceOrientation.gamma?THREE.Math.degToRad(this.deviceOrientation.alpha):
0,b=this.deviceOrientation.beta?THREE.Math.degToRad(this.deviceOrientation.beta):0,e=this.deviceOrientation.gamma?THREE.Math.degToRad(this.deviceOrientation.gamma):0,orient=this.screenOrientation?THREE.Math.degToRad(this.screenOrientation):0,setObjectQuaternion(this.object.quaternion,a,b,e,orient))}}();this.connect=function(){this.onScreenOrientationChangeEvent();window.addEventListener("orientationchange",b(this,this.onScreenOrientationChangeEvent),!1);window.addEventListener("deviceorientation",
b(this,this.onDeviceOrientationChangeEvent),!1);this.freeze=!1};this.disconnect=function(){this.freeze=!0;window.removeEventListener("orientationchange",b(this,this.onScreenOrientationChangeEvent),!1);window.removeEventListener("deviceorientation",b(this,this.onDeviceOrientationChangeEvent),!1)};setObjectQuaternion=function(){var a=new THREE.Vector3(0,0,1),b=new THREE.Euler,e=new THREE.Quaternion,f=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));return function(h,m,g,l,k){this.roll||(Math.abs(k)==
Math.PI/2?g=0:k!=Math.PI&&(l=0));b.set(g,m,-l,"YXZ");h.setFromEuler(b);h.multiply(f);h.multiply(e.setFromAxisAngle(a,-k))}}()};Vizi.PlaneDragger=function(a){a=a||{};Vizi.Picker.call(this,a);this.normal=a.normal||new THREE.Vector3(0,0,1);this.position=a.position||new THREE.Vector3;this.color=170};goog.inherits(Vizi.PlaneDragger,Vizi.Picker);
Vizi.PlaneDragger.prototype.realize=function(){Vizi.Picker.prototype.realize.call(this);this.dragObject=null;this.dragOffset=new THREE.Vector3;this.dragHitPoint=new THREE.Vector3;this.dragStartPoint=new THREE.Vector3;this.dragPlane=this.createDragPlane();this.dragPlane.visible=Vizi.PlaneDragger.SHOW_DRAG_PLANE;this.dragPlane.ignorePick=!0;this.dragPlane.ignoreBounds=!0;this._object._parent.transform.object.add(this.dragPlane)};
Vizi.PlaneDragger.prototype.createDragPlane=function(){var a=this.normal,b=this.position,c=(new THREE.Vector3(0,a.z,-a.y)).normalize().multiplyScalar(2E3);c.lengthSq()||(c=(new THREE.Vector3(-a.z,a.x,0)).normalize().multiplyScalar(2E3));var d=c.clone().cross(a).normalize().multiplyScalar(2E3),e=b.clone().sub(c).sub(d),f=b.clone().add(c).sub(d),h=b.clone().add(c).add(d),c=b.clone().sub(c).add(d),b=new THREE.Geometry;b.vertices.push(e,f,h,c);e=new THREE.Face3(0,2,1);e.normal.copy(a);e.vertexNormals.push(a.clone(),
a.clone(),a.clone(),a.clone());b.faces.push(e);e=new THREE.Face3(0,3,2);e.normal.copy(a);e.vertexNormals.push(a.clone(),a.clone(),a.clone(),a.clone());b.faces.push(e);b.computeFaceNormals();b.computeCentroids();a=new THREE.MeshBasicMaterial({color:this.color,transparent:!0,side:THREE.DoubleSide,opacity:0.1});return new THREE.Mesh(b,a)};Vizi.PlaneDragger.prototype.update=function(){};Vizi.PlaneDragger.prototype.onMouseMove=function(a){Vizi.Picker.prototype.onMouseMove.call(this,a);this.handleMouseMove(a)};
Vizi.PlaneDragger.prototype.handleMouseMove=function(a){if(a=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,this.dragPlane))this.dragHitPoint.copy(a.point).sub(this.dragOffset),this.dragHitPoint.add(this.dragStartPoint),this.dispatchEvent("drag",{type:"drag",object:this.dragObject,offset:this.dragHitPoint})};Vizi.PlaneDragger.prototype.onMouseDown=function(a){Vizi.Picker.prototype.onMouseDown.call(this,a);this.handleMouseDown(a)};
Vizi.PlaneDragger.prototype.handleMouseDown=function(a){var b=Vizi.Graphics.instance.getObjectIntersection(a.elementX,a.elementY,this.dragPlane);b&&(this.dragOffset.copy(b.point),this.dragStartPoint.copy(a.object.position),this.dragHitPoint.copy(b.point).sub(this.dragOffset),this.dragHitPoint.add(this.dragStartPoint),this.dragObject=a.object,this.dispatchEvent("dragstart",{type:"dragstart",object:this.dragObject,offset:this.dragHitPoint}))};
Vizi.PlaneDragger.prototype.onMouseUp=function(a){Vizi.Picker.prototype.onMouseUp.call(this,a);this.handleMouseUp(a)};Vizi.PlaneDragger.prototype.handleMouseUp=function(a){};Vizi.PlaneDragger.prototype.onTouchStart=function(a){Vizi.Picker.prototype.onTouchStart.call(this,a);this.handleMouseDown(a)};Vizi.PlaneDragger.prototype.onTouchMove=function(a){Vizi.Picker.prototype.onTouchMove.call(this,a);this.handleMouseMove(a)};
Vizi.PlaneDragger.prototype.onTouchEnd=function(a){Vizi.Picker.prototype.onTouchEnd.call(this,a);this.handleMouseUp(a)};Vizi.PlaneDragger.SHOW_DRAG_PLANE=!1;Vizi.PlaneDragger.SHOW_DRAG_NORMAL=!1;Vizi.ScaleBehavior=function(a){a=a||{};this.duration=void 0!==a.duration?a.duration:1;this.startScale=void 0!==a.startScale?a.startScale.clone():new THREE.Vector3(1,1,1);this.endScale=void 0!==a.endScale?a.endScale.clone():new THREE.Vector3(2,2,2);this.tween=null;Vizi.Behavior.call(this,a)};goog.inherits(Vizi.ScaleBehavior,Vizi.Behavior);
Vizi.ScaleBehavior.prototype.start=function(){this.running||(this.scale=this.startScale.clone(),this.originalScale=this._object.transform.scale.clone(),this.tween=(new TWEEN.Tween(this.scale)).to(this.endScale,1E3*this.duration).easing(TWEEN.Easing.Quadratic.InOut).repeat(0).start(),Vizi.Behavior.prototype.start.call(this))};
Vizi.ScaleBehavior.prototype.evaluate=function(a){a>=this.duration&&(this.stop(),this.loop?this.start():this.dispatchEvent("complete"));this._object.transform.scale.set(this.originalScale.x*this.scale.x,this.originalScale.y*this.scale.y,this.originalScale.z*this.scale.z)};Vizi.ScaleBehavior.prototype.stop=function(){this.tween&&this.tween.stop();Vizi.Behavior.prototype.stop.call(this)};Vizi.Viewer=function(a){Vizi.Application.call(this,a);this.lastFPSUpdateTime=0;this.renderStats={fps:0};this.sceneStats={meshCount:0,faceCount:0,boundingBox:new THREE.Box3};this.renderStatsUpdateInterval=void 0!==a.renderStatsUpdateInterval?a.renderStatsUpdateInterval:1E3;this.loopAnimations=void 0!==a.loopAnimations?a.loopAnimations:!1;this.headlightOn=void 0!==a.headlight?a.headlight:!0;this.headlightIntensity=a.headlightIntensity||Vizi.Viewer.DEFAULT_HEADLIGHT_INTENSITY;this.riftController=void 0!==
a.riftController?a.riftController:!1;this.firstPerson=void 0!==a.firstPerson?a.firstPerson:!1;this.showGrid=void 0!==a.showGrid?a.showGrid:!1;this.createBoundingBoxes=void 0!==a.createBoundingBoxes?a.createBoundingBoxes:!1;this.showBoundingBoxes=void 0!==a.showBoundingBoxes?a.showBoundingBoxes:!1;this.allowPan=void 0!==a.allowPan?a.allowPan:!0;this.allowZoom=void 0!==a.allowZoom?a.allowZoom:!0;this.oneButton=void 0!==a.oneButton?a.oneButton:!1;this.gridSize=a.gridSize||Vizi.Viewer.DEFAULT_GRID_SIZE;
this.gridStepSize=a.gridStepSize||Vizi.Viewer.DEFAULT_GRID_STEP_SIZE;this.flipY=void 0!==a.flipY?a.flipY:!1;this.highlightDecoration=this.highlightedObject=null;this.initScene();Vizi.Graphics.instance.enableShadows(!0)};goog.inherits(Vizi.Viewer,Vizi.Application);
Vizi.Viewer.prototype.initScene=function(){this.sceneRoot=new Vizi.Object;this.addObject(this.sceneRoot);this.flipY&&(this.sceneRoot.transform.rotation.x=-Math.PI/2);this.gridRoot=new Vizi.Object;this.addObject(this.gridRoot);this.gridPicker=this.grid=null;this.createGrid();this.firstPerson?(this.controller=Vizi.Prefabs.FirstPersonController({active:!0,headlight:!0,turn:!this.riftController,look:!this.riftController}),this.controllerScript=this.controller.getComponent(Vizi.FirstPersonControllerScript)):
(this.controller=Vizi.Prefabs.ModelController({active:!0,headlight:!0,allowPan:this.allowPan,allowZoom:this.allowZoom,oneButton:this.oneButton}),this.controllerScript=this.controller.getComponent(Vizi.ModelControllerScript));this.addObject(this.controller);var a=new Vizi.Object;this.defaultCamera=new Vizi.PerspectiveCamera({active:!0});a.addComponent(this.defaultCamera);a.name="[default]";this.addObject(a);this.controllerScript.camera=this.defaultCamera;if(this.riftController){var a=Vizi.Prefabs.RiftController({active:!0,
headlight:!1,mouseLook:!1,useVRJS:!0}),b=a.getComponent(Vizi.RiftControllerScript);b.camera=this.defaultCamera;b.moveSpeed=6;this.riftControllerScript=b;this.addObject(a)}a=new Vizi.Object;this.ambientLight=new Vizi.AmbientLight({color:16777215,intensity:this.ambientOn?1:0});this.addObject(a);this.scenes=[];this.keyFrameAnimators=[];this.keyFrameAnimatorNames=[];this.cameras=[];this.cameraNames=[];this.lights=[];this.lightNames=[];this.lightIntensities=[];this.lightColors=[]};
Vizi.Viewer.prototype.runloop=function(){var a=this.renderStatsUpdateInterval;Vizi.Application.prototype.runloop.call(this);if(Vizi.Graphics.instance.frameRate){var b=Date.now();b-this.lastFPSUpdateTime>a&&(this.renderStats.fps=Vizi.Graphics.instance.frameRate,this.dispatchEvent("renderstats",this.renderStats),this.lastFPSUpdateTime=b)}};
Vizi.Viewer.prototype.replaceScene=function(a){var b,c=this.sceneRoot._children.length,d=[];for(b=0;b<c;b++)d.push(this.sceneRoot._children[b]);for(b=0;b<c;b++)this.sceneRoot.removeChild(d[b]);this.sceneRoot.removeComponent(this.sceneRoot.findNode(Vizi.Decoration));this.scenes=[a.scene];this.sceneRoot.addChild(a.scene);Vizi.SceneUtils.computeBoundingBox(a.scene);if(this.keyFrameAnimators){c=this.keyFrameAnimators.length;for(b=0;b<c;b++)this.sceneRoot.removeComponent(this.keyFrameAnimators[b]);this.keyFrameAnimators=
[];this.keyFrameAnimatorNames=[]}if(a.keyFrameAnimators)for(c=a.keyFrameAnimators.length,b=0;b<c;b++)this.sceneRoot.addComponent(a.keyFrameAnimators[b]),this.keyFrameAnimators.push(a.keyFrameAnimators[b]),this.keyFrameAnimatorNames.push(a.keyFrameAnimators[b].animationData[0].name);this.cameras=[];this.cameraNames=[];this.cameras.push(this.defaultCamera);this.camera=this.defaultCamera;this.cameraNames.push("[default]");this.controllerScript.camera=this.defaultCamera;this.controllerScript.camera.active=
!0;if(a.cameras)for(c=a.cameras.length,b=0;b<c;b++)d=a.cameras[b],d.aspect=container.offsetWidth/container.offsetHeight,this.cameras.push(d),this.cameraNames.push(d._object.name);this.lights=[];this.lightNames=[];this.lightIntensities=[];this.lightColors=[];if(a.lights){c=a.lights.length;for(b=0;b<c;b++)d=a.lights[b],d instanceof THREE.SpotLight&&(d.castShadow=!0,d.shadowCameraNear=1,d.shadowCameraFar=Vizi.Light.DEFAULT_RANGE,d.shadowCameraFov=90,d.shadowBias=1E-4,d.shadowDarkness=0.3,d.shadowMapWidth=
2048,d.shadowMapHeight=2048,d.target.position.set(0,0,0)),this.lights.push(a.lights[b]),this.lightNames.push(a.lights[b]._object.name),this.lightIntensities.push(a.lights[b].intensity),this.lightColors.push(a.lights[b].color.clone());this.controllerScript.headlight.intensity=c?0:this.headlightIntensity;this.headlightOn=0>=c}else this.controllerScript.headlight.intensity=this.headlightIntensity,this.headlightOn=!0;this.initHighlight();this.fitToScene();this.calcSceneStats()};
Vizi.Viewer.prototype.addToScene=function(a){this.sceneRoot.addChild(a.scene);this.cameras.length||(this.cameras=[],this.cameraNames=[],this.cameras.push(this.defaultCamera),this.camera=this.defaultCamera,this.cameraNames.push("[default]"),this.controllerScript.camera=this.defaultCamera,this.controllerScript.camera.active=!0);if(a.keyFrameAnimators){var b,c=a.keyFrameAnimators.length;for(b=0;b<c;b++)this.sceneRoot.addComponent(a.keyFrameAnimators[b]),this.keyFrameAnimators.push(a.keyFrameAnimators[b]),
this.keyFrameAnimatorNames.push(a.keyFrameAnimators[b].animationData[0].name)}if(a.cameras)for(c=a.cameras.length,b=0;b<c;b++){var d=a.cameras[b];d.aspect=container.offsetWidth/container.offsetHeight;this.cameras.push(d);this.cameraNames.push(d._object.name)}if(a.lights)for(c=a.lights.length,b=0;b<c;b++)d=a.lights[b],d instanceof THREE.SpotLight&&(d.castShadow=!0,d.shadowCameraNear=1,d.shadowCameraFar=Vizi.Light.DEFAULT_RANGE,d.shadowCameraFov=90,d.shadowBias=1E-4,d.shadowDarkness=0.3,d.shadowMapWidth=
2048,d.shadowMapHeight=2048,d.target.position.set(0,0,0)),this.lights.push(a.lights[b]),this.lightNames.push(a.lights[b]._object.name),this.lightIntensities.push(a.lights[b].intensity),this.lightColors.push(a.lights[b].color.clone());else this.lights.length||(this.controllerScript.headlight.intensity=this.headlightIntensity,this.headlightOn=!0);this.scenes.push(a.scene);this.initHighlight();this.fitToScene();this.calcSceneStats()};
Vizi.Viewer.prototype.createDefaultCamera=function(){var a=this.controllerScript.viewpoint.camera.object;a.updateMatrixWorld();var b=new THREE.Vector3,c=new THREE.Quaternion,d=new THREE.Vector3;a.matrixWorld.decompose(b,c,d);(new THREE.Euler).setFromQuaternion(c);a=new THREE.PerspectiveCamera(a.fov,a.aspect,a.near,a.far);return new Vizi.PerspectiveCamera({object:a})};
Vizi.Viewer.prototype.copyCameraValues=function(a,b){var c=a.object;c.updateMatrixWorld();var d=new THREE.Vector3,e=new THREE.Quaternion,f=new THREE.Vector3;c.matrixWorld.decompose(d,e,f);c=(new THREE.Euler).setFromQuaternion(e);b.position.copy(d);b.rotation.copy(c);b.fov=a.fov;b.aspect=a.aspect;b.near=a.near;b.far=a.far};
Vizi.Viewer.prototype.useCamera=function(a){var b=a;"string"==typeof a&&this.cameraNames&&(b=this.cameraNames.indexOf(a));0<=b&&(this.cameras&&this.cameras[b])&&(this.cameras[b].active=!0,this.controllerScript.enabled=0==b)};Vizi.Viewer.prototype.addCamera=function(a,b){this.cameras.push(a);this.cameraNames.push(b)};Vizi.Viewer.prototype.getCamera=function(a){var b=a;"string"==typeof a&&this.cameraNames&&(b=this.cameraNames.indexOf(a));return 0<=b&&this.cameras&&this.cameras[b]?this.cameras[b]:null};
Vizi.Viewer.prototype.toggleLight=function(a){if(this.lights&&this.lights[a]){var b=this.lights[a];b instanceof Vizi.AmbientLight?(b=b.color,0!=b.r||0!=b.g||0!=b.b?b.setRGB(0,0,0):b.copy(this.lightColors[a])):b.intensity=b.intensity?0:this.lightIntensities[a]}};
Vizi.Viewer.prototype.playAnimation=function(a,b,c){void 0===b&&(b=this.loopAnimations);this.keyFrameAnimators&&this.keyFrameAnimators[a]&&(this.keyFrameAnimators[a].loop=b,this.keyFrameAnimators[a].direction=c?Vizi.KeyFrameAnimator.REVERSE_DIRECTION:Vizi.KeyFrameAnimator.FORWARD_DIRECTION,b||this.keyFrameAnimators[a].stop(),this.keyFrameAnimators[a].start())};Vizi.Viewer.prototype.stopAnimation=function(a){this.keyFrameAnimators&&this.keyFrameAnimators[a]&&this.keyFrameAnimators[a].stop()};
Vizi.Viewer.prototype.playAllAnimations=function(a,b){void 0===a&&(a=this.loopAnimations);if(this.keyFrameAnimators){var c,d=this.keyFrameAnimators.length;for(c=0;c<d;c++)this.keyFrameAnimators[c].stop(),a&&(this.keyFrameAnimators[c].loop=!0),this.keyFrameAnimators[c].direction=b?Vizi.KeyFrameAnimator.REVERSE_DIRECTION:Vizi.KeyFrameAnimator.FORWARD_DIRECTION,this.keyFrameAnimators[c].start()}};
Vizi.Viewer.prototype.stopAllAnimations=function(){if(this.keyFrameAnimators){var a,b=this.keyFrameAnimators.length;for(a=0;a<b;a++)this.keyFrameAnimators[a].stop()}};Vizi.Viewer.prototype.setLoopAnimations=function(a){this.loopAnimations=a};Vizi.Viewer.prototype.setHeadlightOn=function(a){this.controllerScript.headlight.intensity=this.headlightIntensity?this.headlightIntensity:0;this.headlightOn=a};
Vizi.Viewer.prototype.setHeadlightIntensity=function(a){this.controllerScript.headlight.intensity=a};Vizi.Viewer.prototype.setGridOn=function(a){this.grid&&(this.grid.visible=a)};Vizi.Viewer.prototype.setBoundingBoxesOn=function(a){this.showBoundingBoxes=a;var b=this;this.sceneRoot.map(Vizi.Decoration,function(a){b.highlightedObject&&a==b.highlightDecoration||(a.visible=b.showBoundingBoxes)})};
Vizi.Viewer.prototype.setAmbientLightOn=function(a){this.ambientLight.intensity=a?1:0;this.ambientLightOn=a};Vizi.Viewer.prototype.setFlipY=function(a){(this.flipY=a)?(this.sceneRoot.transform.rotation.x=-Math.PI/2,this.fitToScene()):this.sceneRoot.transform.rotation.x=0};Vizi.Viewer.prototype.initHighlight=function(){this.highlightedObject&&this.highlightedObject.removeComponent(this.highlightDecoration);this.highlightedObject=null};
Vizi.Viewer.prototype.highlightObject=function(a){this.highlightedObject&&this.highlightParent.removeComponent(this.highlightDecoration);a?(this.highlightDecoration=Vizi.Helpers.BoundingBoxDecoration({object:a,color:11184640}),a instanceof Vizi.Object?(a._parent.addComponent(this.highlightDecoration),this.highlightedObject=a,this.highlightParent=a._parent):a instanceof Vizi.Visual&&(a._object.addComponent(this.highlightDecoration),this.highlightParent=this.highlightedObject=a._object)):this.highlightParent=
this.highlightedObject=null};
Vizi.Viewer.prototype.createGrid=function(){this.gridRoot&&(this.grid&&this.gridRoot.removeComponent(this.grid),this.gridPicker&&this.gridRoot.removeComponent(this.gridPicker));for(var a=this.gridStepSize,b=this.gridSize,c=new THREE.Geometry,d=0;d<=2*(b/a);d++)c.vertices.push(new THREE.Vector3(-b,-0.04,d*a-b)),c.vertices.push(new THREE.Vector3(b,-0.04,d*a-b)),c.vertices.push(new THREE.Vector3(d*a-b,-0.04,-b)),c.vertices.push(new THREE.Vector3(d*a-b,-0.04,b));a=new THREE.LineBasicMaterial({color:Vizi.Viewer.GRID_COLOR,opacity:Vizi.Viewer.GRID_OPACITY});
c=new THREE.Line(c,a,THREE.LinePieces);c.visible=this.showGrid;this.grid=new Vizi.Visual({object:c});this.gridRoot.addComponent(this.grid);this.gridPicker=new Vizi.Picker;var e=this;this.gridPicker.addEventListener("mouseup",function(a){e.highlightObject(null)});this.gridRoot.addComponent(this.gridPicker)};
Vizi.Viewer.prototype.fitToScene=function(){this.boundingBox=Vizi.SceneUtils.computeBoundingBox(this.sceneRoot);this.controllerScript.controls.userPanSpeed=1;1>this.boundingBox.max.z?(this.controllerScript.camera.near=0.01,this.controllerScript.controls.userPanSpeed=0.01):1E4<this.boundingBox.max.z?this.controllerScript.camera.far=2*this.boundingBox.max.z*Math.sqrt(2):1E3<this.boundingBox.max.z&&(this.controllerScript.camera.far=2E4);var a=this.boundingBox.max.clone().add(this.boundingBox.min).multiplyScalar(0.5);
this.controllerScript.center=a;1==this.scenes.length&&(a=new THREE.Vector3(0,this.boundingBox.max.y,2*this.boundingBox.max.z),this.controllerScript.camera.position.copy(a),this.controllerScript.camera.position.z*=2,this.cameras[0].position.copy(this.controllerScript.camera.position));if(this.createBoundingBoxes){var b=this;this.sceneRoot.map(Vizi.Object,function(a){if(a._parent){var d=Vizi.Helpers.BoundingBoxDecoration({object:a,color:65280});a._parent.addComponent(d);d.visible=b.showBoundingBoxes}})}this.sceneRadius=
this.boundingBox.max.clone().sub(this.boundingBox.min).length();this.gridSize=a=Math.pow(10,Math.ceil(Math.log(this.sceneRadius)/Math.LN10));this.gridStepSize=a/100;this.createGrid()};
Vizi.Viewer.prototype.calcSceneStats=function(){this.faceCount=this.meshCount=0;var a=this.sceneRoot.findNodes(Vizi.Visual),b,c=a.length;for(b=0;b<c;b++){var d=a[b].geometry;this.faceCount+=d.faces?d.faces.length:d.attributes.index.array.length/3;this.meshCount++}this.sceneStats.meshCount=this.meshCount;this.sceneStats.faceCount=this.faceCount;this.sceneStats.boundingBox=this.boundingBox;this.dispatchEvent("scenestats",this.sceneStats)};
Vizi.Viewer.prototype.setController=function(a){this.boundingBox||(this.boundingBox=Vizi.SceneUtils.computeBoundingBox(this.sceneRoot));var b;b=isFinite(this.boundingBox.max.x)?this.boundingBox.max.clone().add(this.boundingBox.min).multiplyScalar(0.5):new THREE.Vector3;switch(a){case "FPS":b.y=0}this.controllerScript.center=b};Vizi.Viewer.DEFAULT_GRID_SIZE=100;Vizi.Viewer.DEFAULT_GRID_STEP_SIZE=1;Vizi.Viewer.GRID_COLOR=2105376;Vizi.Viewer.GRID_OPACITY=0.2;Vizi.Viewer.DEFAULT_HEADLIGHT_INTENSITY=1;Vizi.ParticleSystem=function(a){a=a||{};var b=new Vizi.Object,c=a.texture||null,d=a.maxAge||Vizi.ParticleSystemScript.DEFAULT_MAX_AGE,e=null;if(a.geometry)c=new THREE.ParticleSystemMaterial({color:void 0!==a.color?a.color:Vizi.ParticleSystem.DEFAULT_COLOR,size:a.size,map:a.map,transparent:null!==a.map,vertexColors:0<a.geometry.colors.length}),c=new THREE.ParticleSystem(a.geometry,c),a.map&&(c.sortParticles=!0),e=new Vizi.Visual({object:c});else var f=new ShaderParticleGroup({texture:c,maxAge:d}),
e=new Vizi.Visual({object:f.mesh});b.addComponent(e);a.particleGroup=f;a=new Vizi.ParticleSystemScript(a);b.addComponent(a);return b};Vizi.ParticleSystemScript=function(a){Vizi.Script.call(this,a);this.particleGroup=a.particleGroup;this._active=!0;Object.defineProperties(this,{active:{get:function(){return this._active},set:function(a){this.setActive(a)}}})};goog.inherits(Vizi.ParticleSystemScript,Vizi.Script);Vizi.ParticleSystemScript.prototype.realize=function(){this.initEmitters()};
Vizi.ParticleSystemScript.prototype.initEmitters=function(){for(var a=this._object.getComponents(Vizi.ParticleEmitter),b=0,c=a.length,b=0;b<c;b++){var d=a[b];this.particleGroup.addEmitter(d.object);d.active=this._active}this.emitters=a};Vizi.ParticleSystemScript.prototype.setActive=function(a){var b=this.emitters;if(b){for(var c=0,d=b.length,c=0;c<d;c++)b[c].active=a;this._active=a}};Vizi.ParticleSystemScript.prototype.update=function(){this.particleGroup&&this.particleGroup.tick()};
Vizi.ParticleSystem.DEFAULT_COLOR=16777215;Vizi.ParticleSystemScript.DEFAULT_MAX_AGE=1;Vizi.SpotLight=function(a){a=a||{};this.scaledDir=new THREE.Vector3;this.positionVec=new THREE.Vector3;this.castShadows=void 0!==a.castShadows?a.castShadows:Vizi.SpotLight.DEFAULT_CAST_SHADOWS;Vizi.Light.call(this,a);a.object?(this.object=a.object,this.direction=a.object.position.clone().normalize().negate(),this.targetPos=a.object.target.position.clone(),this.shadowDarkness=a.object.shadowDarkness):(this.direction=a.direction||new THREE.Vector3(0,0,-1),this.targetPos=new THREE.Vector3,this.shadowDarkness=
void 0!==a.shadowDarkness?a.shadowDarkness:Vizi.SpotLight.DEFAULT_SHADOW_DARKNESS,this.object=new THREE.SpotLight(a.color,a.intensity,void 0!==a.distance?a.distance:Vizi.SpotLight.DEFAULT_DISTANCE,void 0!==a.angle?a.angle:Vizi.SpotLight.DEFAULT_ANGLE,void 0!==a.exponent?a.exponent:Vizi.SpotLight.DEFAULT_EXPONENT));Object.defineProperties(this,{angle:{get:function(){return this.object.angle},set:function(a){this.object.angle=a}},distance:{get:function(){return this.object.distance},set:function(a){this.object.distance=
a}},exponent:{get:function(){return this.object.exponent},set:function(a){this.object.exponent=a}}})};goog.inherits(Vizi.SpotLight,Vizi.Light);Vizi.SpotLight.prototype.realize=function(){Vizi.Light.prototype.realize.call(this)};
Vizi.SpotLight.prototype.update=function(){this.object&&(this.positionVec.set(0,0,0),this.positionVec.applyMatrix4(this.object.parent.matrixWorld),this.position.copy(this.positionVec),this.scaledDir.copy(this.direction),this.scaledDir.multiplyScalar(Vizi.Light.DEFAULT_RANGE),this.targetPos.copy(this.position),this.targetPos.add(this.scaledDir),this.updateShadows());Vizi.Light.prototype.update.call(this)};
Vizi.SpotLight.prototype.updateShadows=function(){this.castShadows&&(this.object.castShadow=!0,this.object.shadowCameraNear=1,this.object.shadowCameraFar=Vizi.Light.DEFAULT_RANGE,this.object.shadowCameraFov=90,this.object.shadowBias=1E-4,this.object.shadowDarkness=this.shadowDarkness,this.object.shadowMapWidth=1024,this.object.shadowMapHeight=1024,Vizi.Graphics.instance.enableShadows(!0))};Vizi.SpotLight.DEFAULT_DISTANCE=0;Vizi.SpotLight.DEFAULT_ANGLE=Math.PI/2;Vizi.SpotLight.DEFAULT_EXPONENT=10;
Vizi.SpotLight.DEFAULT_CAST_SHADOWS=!1;Vizi.SpotLight.DEFAULT_SHADOW_DARKNESS=0.3;Vizi.Decoration=function(a){a=a||{};Vizi.Visual.call(this,a)};goog.inherits(Vizi.Decoration,Vizi.Visual);Vizi.Decoration.prototype._componentCategory="decorations";Vizi.Decoration.prototype.realize=function(){Vizi.Visual.prototype.realize.call(this);this.object.ignorePick=!0};Vizi.Modules=function(){};var CLOSURE_NO_DEPS=!0;Vizi.loadUrl=function(a,b,c){c=c||{};c.container=b;var d=new Vizi.Viewer(c);b=new Vizi.Loader;b.addEventListener("loaded",function(a){var b=e,b=(Date.now()-b)/1E3;Vizi.System.log("Vizi.loadUrl, scene loaded in ",b," seconds.");d.replaceScene(a);1<d.cameras.length&&d.useCamera(1);c.headlight&&d.setHeadlightOn(!0)});b.addEventListener("progress",function(a){Vizi.System.log("Vizi.loadUrl, ",100*(a.loaded/a.total)," % loaded.")});var e=Date.now();b.loadScene(a);d.run();return{viewer:d}};
